/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/********************************************************************

*********************************************************************/

/**
 * @namespace Main ViniSketch toolkit namespace
 * @name vs
 */
window.vs = {};

/**
 * Contains a collections of facilities, internationalization, and miscellaneous
 * utility classes and methods.
 *
 * @namespace Main ViniSketch utility elements.
 * @name vs.util
 */
window.vs.util = {};

/**
 * @namespace Main ViniSketch components
 * @name vs.core
 */
window.vs.core = {};

/**
 * @namespace Main ViniSketch Data components
 * @name vs.data
 */
window.vs.data = {};

/**
 * @namespace Main ViniSketch User Interface components
 * @name vs.ui
 */
window.vs.ui = {};

/**
 * @namespace Main ViniSketch animation...
 * @name vs.fx
 */
window.vs.fx = {};

/**
 * @namespace Main ViniSketch Audio and Video...
 * @name vs.av
 */
window.vs.av = {};

/**
 * @namespace ViniSketch extensions...
 * @name vs.ext
 */
window.vs.ext = {};

/**
 * @namespace ViniSketch GUI extensions...
 * @name vs.ext.ui
 */
window.vs.ext.ui = {};
  
/**
 * @namespace ViniSketch FX extensions...
 * @name vs.ext.fx
 */
window.vs.ext.fx = {};

window.vs.SUPPORT_3D_TRANSFORM = false;

(function () {

/**
 *  class FirminCSSMatrix
 *
 *  The [[FirminCSSMatrix]] class is a concrete implementation of the
 *  `CSSMatrix` interface defined in the [CSS 2D Transforms][2d] and
 *  [CSS 3D Transforms][3d] Module specifications.
 *
 *  [2d]: http://www.w3.org/TR/css3-2d-transforms/
 *  [3d]: http://www.w3.org/TR/css3-3d-transforms/
 *
 *  The implementation was largely copied from the `WebKitCSSMatrix` class, and
 *  the supparting maths libraries in the [WebKit][webkit] project. This is one
 *  reason why much of the code looks more like C++ than JavaScript.
 *
 *  [webkit]: http://webkit.org/
 *
 *  Its API is a superset of that provided by `WebKitCSSMatrix`, largely
 *  because various pieces of supporting code have been added as instance
 *  methods rather than pollute the global namespace. Examples of these include
 *  [[FirminCSSMatrix#isAffine]], [[FirminCSSMatrix#isIdentityOrTranslation]]
 *  and [[FirminCSSMatrix#adjoint]].
 **/

/**
 *  new FirminCSSMatrix(domstr)
 *  - domstr (String): a string representation of a 2D or 3D transform matrix
 *    in the form given by the CSS transform property, i.e. just like the
 *    output from [[FirminCSSMatrix#toString]].
 **/
var FirminCSSMatrix = function(domstr) {
  this.m11 = this.m22 = this.m33 = this.m44 = 1;

         this.m12 = this.m13 = this.m14 =
  this.m21 =        this.m23 = this.m24 =
  this.m31 = this.m32 =      this.m34 =
  this.m41 = this.m42 = this.m43        = 0;

  if (typeof domstr == "string") {
    this.setMatrixValue(domstr);
  }
};

/**
 *  FirminCSSMatrix.displayName = "FirminCSSMatrix"
 **/
FirminCSSMatrix.displayName = "FirminCSSMatrix";

/**
 *  FirminCSSMatrix.degreesToRadians(angle) -> Number
 *  - angle (Number): an angle in degrees.
 *
 *  Converts angles in degrees, which are used by the external API, to angles
 *  in radians used in internal calculations.
 **/
FirminCSSMatrix.degreesToRadians = function(angle) {
  return angle * Math.PI / 180;
};

/**
 *  FirminCSSMatrix.determinant2x2(a, b, c, d) -> Number
 *  - a (Number): top-left value of the matrix.
 *  - b (Number): top-right value of the matrix.
 *  - c (Number): bottom-left value of the matrix.
 *  - d (Number): bottom-right value of the matrix.
 *
 *  Calculates the determinant of a 2x2 matrix.
 **/
FirminCSSMatrix.determinant2x2 = function(a, b, c, d) {
  return a * d - b * c;
};

/**
 *  FirminCSSMatrix.determinant3x3(matrix) -> Number
 *  - a1 (Number): matrix value in position [1, 1].
 *  - a2 (Number): matrix value in position [1, 2].
 *  - a3 (Number): matrix value in position [1, 3].
 *  - b1 (Number): matrix value in position [2, 1].
 *  - b2 (Number): matrix value in position [2, 2].
 *  - b3 (Number): matrix value in position [2, 3].
 *  - c1 (Number): matrix value in position [3, 1].
 *  - c2 (Number): matrix value in position [3, 2].
 *  - c3 (Number): matrix value in position [3, 3].
 *
 *  Calculates the determinant of a 3x3 matrix.
 **/
FirminCSSMatrix.determinant3x3 = function(a1, a2, a3, b1, b2, b3, c1, c2, c3) {
  var determinant2x2 = FirminCSSMatrix.determinant2x2;
  return a1 * determinant2x2(b2, b3, c2, c3) -
       b1 * determinant2x2(a2, a3, c2, c3) +
       c1 * determinant2x2(a2, a3, b2, b3);
};

/**
 *  FirminCSSMatrix.determinant4x4(matrix) -> Number
 *  - matrix (FirminCSSMatrix): the matrix to calculate the determinant of.
 *
 *  Calculates the determinant of a 4x4 matrix.
 **/
FirminCSSMatrix.determinant4x4 = function(m) {
  var determinant3x3 = FirminCSSMatrix.determinant3x3,

  // Assign to individual variable names to aid selecting correct elements
  a1 = m.m11, b1 = m.m21, c1 = m.m31, d1 = m.m41,
  a2 = m.m12, b2 = m.m22, c2 = m.m32, d2 = m.m42,
  a3 = m.m13, b3 = m.m23, c3 = m.m33, d3 = m.m43,
  a4 = m.m14, b4 = m.m24, c4 = m.m34, d4 = m.m44;

  return a1 * determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4) -
       b1 * determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4) +
       c1 * determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4) -
       d1 * determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
};

/**
 *  FirminCSSMatrix#a -> Number
 *  The first 2D vector value.
 **/

/**
 *  FirminCSSMatrix#b -> Number
 *  The second 2D vector value.
 **/

/**
 *  FirminCSSMatrix#c -> Number
 *  The third 2D vector value.
 **/

/**
 *  FirminCSSMatrix#d -> Number
 *  The fourth 2D vector value.
 **/

/**
 *  FirminCSSMatrix#e -> Number
 *  The fifth 2D vector value.
 **/

/**
 *  FirminCSSMatrix#f -> Number
 *  The sixth 2D vector value.
 **/

/**
 *  FirminCSSMatrix#m11 -> Number
 *  The 3D matrix value in the first row and first column.
 **/

/**
 *  FirminCSSMatrix#m12 -> Number
 *  The 3D matrix value in the first row and second column.
 **/

/**
 *  FirminCSSMatrix#m13 -> Number
 *  The 3D matrix value in the first row and third column.
 **/

/**
 *  FirminCSSMatrix#m14 -> Number
 *  The 3D matrix value in the first row and fourth column.
 **/

/**
 *  FirminCSSMatrix#m21 -> Number
 *  The 3D matrix value in the second row and first column.
 **/

/**
 *  FirminCSSMatrix#m22 -> Number
 *  The 3D matrix value in the second row and second column.
 **/

/**
 *  FirminCSSMatrix#m23 -> Number
 *  The 3D matrix value in the second row and third column.
 **/

/**
 *  FirminCSSMatrix#m24 -> Number
 *  The 3D matrix value in the second row and fourth column.
 **/

/**
 *  FirminCSSMatrix#m31 -> Number
 *  The 3D matrix value in the third row and first column.
 **/

/**
 *  FirminCSSMatrix#m32 -> Number
 *  The 3D matrix value in the third row and second column.
 **/

/**
 *  FirminCSSMatrix#m33 -> Number
 *  The 3D matrix value in the third row and third column.
 **/

/**
 *  FirminCSSMatrix#m34 -> Number
 *  The 3D matrix value in the third row and fourth column.
 **/

/**
 *  FirminCSSMatrix#m41 -> Number
 *  The 3D matrix value in the fourth row and first column.
 **/

/**
 *  FirminCSSMatrix#m42 -> Number
 *  The 3D matrix value in the fourth row and second column.
 **/

/**
 *  FirminCSSMatrix#m43 -> Number
 *  The 3D matrix value in the fourth row and third column.
 **/

/**
 *  FirminCSSMatrix#m44 -> Number
 *  The 3D matrix value in the fourth row and fourth column.
 **/

[["m11", "a"],
 ["m12", "b"],
 ["m21", "c"],
 ["m22", "d"],
 ["m41", "e"],
 ["m42", "f"]].forEach(function(pair) {
  var key3d = pair[0], key2d = pair[1];

  Object.defineProperty(FirminCSSMatrix.prototype, key2d, {
    set: function(val) {
      this[key3d] = val;
    },
  
    get: function() {
      return this[key3d];
    }
  });
});

/**
 *  FirminCSSMatrix#isAffine() -> Boolean
 *
 *  Determines whether the matrix is affine.
 **/
FirminCSSMatrix.prototype.isAffine = function() {
  return this.m13 === 0 && this.m14 === 0 &&
       this.m23 === 0 && this.m24 === 0 &&
       this.m31 === 0 && this.m32 === 0 &&
       this.m33 === 1 && this.m34 === 0 &&
       this.m43 === 0 && this.m44 === 1;
};

/**
 *  FirminCSSMatrix#multiply(otherMatrix) -> FirminCSSMatrix
 *  - otherMatrix (FirminCSSMatrix): the matrix to multiply this one by.
 *
 *  Multiplies the matrix by a given matrix and returns the result.
 **/
FirminCSSMatrix.prototype.multiply = function(otherMatrix) {
  var a = otherMatrix,
    b = this,
    c = new FirminCSSMatrix();

  c.m11 = a.m11 * b.m11 + a.m12 * b.m21 + a.m13 * b.m31 + a.m14 * b.m41;
  c.m12 = a.m11 * b.m12 + a.m12 * b.m22 + a.m13 * b.m32 + a.m14 * b.m42;
  c.m13 = a.m11 * b.m13 + a.m12 * b.m23 + a.m13 * b.m33 + a.m14 * b.m43;
  c.m14 = a.m11 * b.m14 + a.m12 * b.m24 + a.m13 * b.m34 + a.m14 * b.m44;

  c.m21 = a.m21 * b.m11 + a.m22 * b.m21 + a.m23 * b.m31 + a.m24 * b.m41;
  c.m22 = a.m21 * b.m12 + a.m22 * b.m22 + a.m23 * b.m32 + a.m24 * b.m42;
  c.m23 = a.m21 * b.m13 + a.m22 * b.m23 + a.m23 * b.m33 + a.m24 * b.m43;
  c.m24 = a.m21 * b.m14 + a.m22 * b.m24 + a.m23 * b.m34 + a.m24 * b.m44;

  c.m31 = a.m31 * b.m11 + a.m32 * b.m21 + a.m33 * b.m31 + a.m34 * b.m41;
  c.m32 = a.m31 * b.m12 + a.m32 * b.m22 + a.m33 * b.m32 + a.m34 * b.m42;
  c.m33 = a.m31 * b.m13 + a.m32 * b.m23 + a.m33 * b.m33 + a.m34 * b.m43;
  c.m34 = a.m31 * b.m14 + a.m32 * b.m24 + a.m33 * b.m34 + a.m34 * b.m44;

  c.m41 = a.m41 * b.m11 + a.m42 * b.m21 + a.m43 * b.m31 + a.m44 * b.m41;
  c.m42 = a.m41 * b.m12 + a.m42 * b.m22 + a.m43 * b.m32 + a.m44 * b.m42;
  c.m43 = a.m41 * b.m13 + a.m42 * b.m23 + a.m43 * b.m33 + a.m44 * b.m43;
  c.m44 = a.m41 * b.m14 + a.m42 * b.m24 + a.m43 * b.m34 + a.m44 * b.m44;

  return c;
};

/**
 *  FirminCSSMatrix#isIdentityOrTranslation() -> Boolean
 *
 *  Returns whether the matrix is the identity matrix or a translation matrix.
 **/
FirminCSSMatrix.prototype.isIdentityOrTranslation = function() {
  var t = this;
  return t.m11 === 1 && t.m12 === 0 && t.m13 === 0 && t.m14 === 0 &&
       t.m21 === 0 && t.m22 === 1 && t.m23 === 0 && t.m24 === 0 &&
       t.m31 === 0 && t.m31 === 0 && t.m33 === 1 && t.m34 === 0 &&
  /* m41, m42 and m43 are the translation points */ t.m44 === 1;
};

/**
 *  FirminCSSMatrix#adjoint() -> FirminCSSMatrix
 *
 *  Returns the adjoint matrix.
 **/
FirminCSSMatrix.prototype.adjoint = function() {
  var result = new FirminCSSMatrix(), t = this,
    determinant3x3 = FirminCSSMatrix.determinant3x3,
  
    a1 = t.m11, b1 = t.m12, c1 = t.m13, d1 = t.m14,
    a2 = t.m21, b2 = t.m22, c2 = t.m23, d2 = t.m24,
    a3 = t.m31, b3 = t.m32, c3 = t.m33, d3 = t.m34,
    a4 = t.m41, b4 = t.m42, c4 = t.m43, d4 = t.m44;

  // Row column labeling reversed since we transpose rows & columns
  result.m11 =  determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4);
  result.m21 = -determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4);
  result.m31 =  determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4);
  result.m41 = -determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);

  result.m12 = -determinant3x3(b1, b3, b4, c1, c3, c4, d1, d3, d4);
  result.m22 =  determinant3x3(a1, a3, a4, c1, c3, c4, d1, d3, d4);
  result.m32 = -determinant3x3(a1, a3, a4, b1, b3, b4, d1, d3, d4);
  result.m42 =  determinant3x3(a1, a3, a4, b1, b3, b4, c1, c3, c4);

  result.m13 =  determinant3x3(b1, b2, b4, c1, c2, c4, d1, d2, d4);
  result.m23 = -determinant3x3(a1, a2, a4, c1, c2, c4, d1, d2, d4);
  result.m33 =  determinant3x3(a1, a2, a4, b1, b2, b4, d1, d2, d4);
  result.m43 = -determinant3x3(a1, a2, a4, b1, b2, b4, c1, c2, c4);

  result.m14 = -determinant3x3(b1, b2, b3, c1, c2, c3, d1, d2, d3);
  result.m24 =  determinant3x3(a1, a2, a3, c1, c2, c3, d1, d2, d3);
  result.m34 = -determinant3x3(a1, a2, a3, b1, b2, b3, d1, d2, d3);
  result.m44 =  determinant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3);

  return result;
};

/**
 *  FirminCSSMatrix#inverse() -> FirminCSSMatrix | null
 *
 *  If the matrix is invertible, returns its inverse, otherwise returns null.
 **/
FirminCSSMatrix.prototype.inverse = function() {
  var inv, det, result, i, j;

  if (this.isIdentityOrTranslation()) {
    inv = new FirminCSSMatrix();
  
    if (!(this.m41 === 0 && this.m42 === 0 && this.m43 === 0)) {
      inv.m41 = -this.m41;
      inv.m42 = -this.m42;
      inv.m43 = -this.m43;
    }
  
    return inv;
  }

  // Calculate the adjoint matrix
  result = this.adjoint();

  // Calculate the 4x4 determinant
  det = FirminCSSMatrix.determinant4x4(this);

  // If the determinant is zero, then the inverse matrix is not unique
  if (Math.abs(det) < 1e-8) return null;

  // Scale the adjoint matrix to get the inverse
  for (i = 1; i < 5; i++) {
    for (j = 1; j < 5; j++) {
      result[("m" + i) + j] /= det;
    }
  }

  return result;
};

/**
 *  FirminCSSMatrix#rotate(rotX, rotY, rotZ) -> FirminCSSMatrix
 *  - rotX (Number): the rotation around the x axis.
 *  - rotY (Number): the rotation around the y axis. If undefined, the x
 *    component is used.
 *  - rotZ (Number): the rotation around the z axis. If undefined, the x
 *    component is used.
 *
 *  Returns the result of rotating the matrix by a given vector.
 *
 *  If only the first argument is provided, the matrix is only rotated about
 *  the z axis.
 **/
FirminCSSMatrix.prototype.rotate = function(rx, ry, rz) {
  var degreesToRadians = FirminCSSMatrix.degreesToRadians;

  if (typeof rx != "number" || isNaN(rx)) rx = 0;

  if ((typeof ry != "number" || isNaN(ry)) &&
    (typeof rz != "number" || isNaN(rz))) {
    rz = rx;
    rx = 0;
    ry = 0;
  }

  if (typeof ry != "number" || isNaN(ry)) ry = 0;
  if (typeof rz != "number" || isNaN(rz)) rz = 0;

  rx = degreesToRadians(rx);
  ry = degreesToRadians(ry);
  rz = degreesToRadians(rz);

  var tx = new FirminCSSMatrix(),
    ty = new FirminCSSMatrix(),
    tz = new FirminCSSMatrix(),
    sinA, cosA, sinA2;

  rz /= 2;
  sinA = Math.sin(rz);
  cosA = Math.cos(rz);
  sinA2 = sinA * sinA;

  // Matrices are identity outside the assigned values
  tz.m11 = tz.m22 = 1 - 2 * sinA2;
  tz.m12 = tz.m21 = 2 * sinA * cosA;
  tz.m21 *= -1;

  ry /= 2;
  sinA  = Math.sin(ry);
  cosA  = Math.cos(ry);
  sinA2 = sinA * sinA;

  ty.m11 = ty.m33 = 1 - 2 * sinA2;
  ty.m13 = ty.m31 = 2 * sinA * cosA;
  ty.m13 *= -1;

  rx /= 2;
  sinA = Math.sin(rx);
  cosA = Math.cos(rx);
  sinA2 = sinA * sinA;

  tx.m22 = tx.m33 = 1 - 2 * sinA2;
  tx.m23 = tx.m32 = 2 * sinA * cosA;
  tx.m32 *= -1;

  return tz.multiply(ty).multiply(tx).multiply(this);
};

/**
 *  FirminCSSMatrix#rotateAxisAngle(rotX, rotY, rotZ, angle) -> FirminCSSMatrix
 *  - rotX (Number): the rotation around the x axis.
 *  - rotY (Number): the rotation around the y axis. If undefined, the x
 *    component is used.
 *  - rotZ (Number): the rotation around the z axis. If undefined, the x
 *    component is used.
 *  - angle (Number): the angle of rotation about the axis vector, in degrees.
 *
 *  Returns the result of rotating the matrix around a given vector by a given
 *  angle.
 *
 *  If the given vector is the origin vector then the matrix is rotated by the
 *  given angle around the z axis.
 **/
FirminCSSMatrix.prototype.rotateAxisAngle = function(x, y, z, a) {
  if (typeof x != "number" || isNaN(x)) x = 0;
  if (typeof y != "number" || isNaN(y)) y = 0;
  if (typeof z != "number" || isNaN(z)) z = 0;
  if (typeof a != "number" || isNaN(a)) a = 0;
  if (x === 0 && y === 0 && z === 0) z = 1;

  var t = new FirminCSSMatrix(),
    len = Math.sqrt(x * x + y * y + z * z),
    cosA, sinA, sinA2, csA, x2, y2, z2;

  a   = (FirminCSSMatrix.degreesToRadians(a) || 0) / 2;
  cosA  = Math.cos(a);
  sinA  = Math.sin(a);
  sinA2 = sinA * sinA;

  // Bad vector, use something sensible
  if (len === 0) {
    x = 0;
    y = 0;
    z = 1;
  } else if (len !== 1) {
    x /= len;
    y /= len;
    z /= len;
  }

  // Optimise cases where axis is along major axis
  if (x === 1 && y === 0 && z === 0) {
    t.m22 = t.m33 = 1 - 2 * sinA2;
    t.m23 = t.m32 = 2 * cosA * sinA;
    t.m32 *= -1;
  } else if (x === 0 && y === 1 && z === 0) {
    t.m11 = t.m33 = 1 - 2 * sinA2;
    t.m13 = t.m31 = 2 * cosA * sinA;
    t.m13 *= -1;
  } else if (x === 0 && y === 0 && z === 1) {
    t.m11 = t.m22 = 1 - 2 * sinA2;
    t.m12 = t.m21 = 2 * cosA * sinA;
    t.m21 *= -1;
  } else {
    csA = sinA * cosA;
    x2  = x * x;
    y2  = y * y;
    z2  = z * z;
  
    t.m11 = 1 - 2 * (y2 + z2) * sinA2;
    t.m12 = 2 * (x * y * sinA2 + z * csA);
    t.m13 = 2 * (x * z * sinA2 - y * csA);
    t.m21 = 2 * (y * x * sinA2 - z * csA);
    t.m22 = 1 - 2 * (z2 + x2) * sinA2;
    t.m23 = 2 * (y * z * sinA2 + x * csA);
    t.m31 = 2 * (z * x * sinA2 + y * csA);
    t.m32 = 2 * (z * y * sinA2 - x * csA);
    t.m33 = 1 - 2 * (x2 + y2) * sinA2;
  }

  return this.multiply(t);
};

/**
 *  FirminCSSMatrix#scale(scaleX, scaleY, scaleZ) -> FirminCSSMatrix
 *  - scaleX (Number): the scaling factor in the x axis.
 *  - scaleY (Number): the scaling factor in the y axis. If undefined, the x
 *    component is used.
 *  - scaleZ (Number): the scaling factor in the z axis. If undefined, 1 is
 *    used.
 *
 *  Returns the result of scaling the matrix by a given vector.
 **/
FirminCSSMatrix.prototype.scale = function(scaleX, scaleY, scaleZ) {
  var transform = new FirminCSSMatrix();

  if (typeof scaleX != "number" || isNaN(scaleX)) scaleX = 1;
  if (typeof scaleY != "number" || isNaN(scaleY)) scaleY = scaleX;
  if (typeof scaleZ != "number" || isNaN(scaleZ)) scaleZ = 1;

  transform.m11 = scaleX;
  transform.m22 = scaleY;
  transform.m33 = scaleZ;

  return this.multiply(transform);
};

/**
 *  FirminCSSMatrix#translate(x, y, z) -> FirminCSSMatrix
 *  - x (Number): the x component of the vector.
 *  - y (Number): the y component of the vector.
 *  - z (Number): the z component of the vector. If undefined, 0 is used.
 *
 *  Returns the result of translating the matrix by a given vector.
 **/
FirminCSSMatrix.prototype.translate = function(x, y, z) {
  var t = new FirminCSSMatrix();

  if (typeof x != "number" || isNaN(x)) x = 0;
  if (typeof y != "number" || isNaN(y)) y = 0;
  if (typeof z != "number" || isNaN(z)) z = 0;

  t.m41 = x;
  t.m42 = y;
  t.m43 = z;

  return this.multiply(t);
};

/**
 *  FirminCSSMatrix#setMatrixValue(domstr) -> undefined
 *  - domstr (String): a string representation of a 2D or 3D transform matrix
 *    in the form given by the CSS transform property, i.e. just like the
 *    output from [[FirminCSSMatrix#toString]].
 *
 *  Sets the matrix values using a string representation, such as that produced
 *  by the [[FirminCSSMatrix#toString]] method.
 **/
FirminCSSMatrix.prototype.setMatrixValue = function(domstr) {
    domstr = domstr.trim();
  var mstr   = domstr.match(/^matrix(3d)?\(\s*(.+)\s*\)$/),
    is3d, chunks, len, points, i, chunk;

  if (!mstr) return;

  is3d   = !!mstr[1];
  chunks = mstr[2].split(/\s*,\s*/);
  len    = chunks.length;
  points = new Array(len);

  if ((is3d && len !== 16) || !(is3d || len === 6)) return;

  for (i = 0; i < len; i++) {
    chunk = chunks[i];
    if (chunk.match(/^-?\d+(\.\d+)?$/)) {
      points[i] = parseFloat(chunk);
    } else return;
  }

  for (i = 0; i < len; i++) {
    point = is3d ?
      ("m" + (Math.floor(i / 4) + 1)) + (i % 4 + 1) :
      String.fromCharCode(i + 97); // ASCII char 97 == 'a'
    this[point] = points[i];
  }
};

/**
 *  FirminCSSMatrix#toString() -> String
 *
 *  Returns a string representation of the matrix.
 **/
FirminCSSMatrix.prototype.toString = function() {
  var self = this, points, prefix;

  if (this.isAffine()) {
    prefix = "matrix(";
    points = ["a", "b", "c", "d", "e", "f"];
  } else {
    prefix = "matrix3d(";
    points = ["m11", "m12", "m13", "m14",
          "m21", "m22", "m23", "m24",
          "m31", "m32", "m33", "m34",
          "m41", "m42", "m43", "m44"];
  }

  return prefix + points.map(function(p) {
    return self[p].toFixed(6);
  }).join(", ") + ")";
};
this.FirminCSSMatrix = FirminCSSMatrix;
}).call(this);
(function(){ 
 var vs = this.vs = this.vs || {}, util = vs.util = {};

/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
 
 Use code from Canto.js Copyright 2010 Steven Levithan <stevenlevithan.com>
*/
  
/**
 *  @class
 *  vs.Point is an (x, y) coordinate pair. 
 *  When you use an vs.Point object in matrix operations, the object is 
 *  treated as a vector of the following form <x, y, 1>
 *
 * @author David Thevenin
 *
 *  @constructor
 *  Main constructor
 *
 * @name vs.Point
 *
 * @param {Number} the x-coordinate value.
 * @param {Number} the y-coordinate value.
*/
function Point (x, y)
{
  if (util.isNumber (x))
  this.x = x;
  if (util.isNumber (y))
  this.y = y;
}

Point.prototype = {

  /*****************************************************************
   *
   ****************************************************************/
 
   x: 0,
   y: 0,

  /*****************************************************************
   *              
   ****************************************************************/
 
  /**
   * Applies the given 2×3 matrix transformation on this Point object and 
   * returns a new, transformed Point object.
   *
   * @name vs.Point#matrixTransform
   * @function
   * @public
   * @param {vs.CSSMatrix} matrix he matrix
   * @returns {vs.Point} the matrix
   */
  matrixTransform : function (matrix)
  {
    var matrix_tmp = new CSSMatrix ();

    matrix_tmp = matrix_tmp.translate (this.x, this.y, this.z || 0);
    matrix = matrix.multiply (matrix_tmp);

    var result = new Point (matrix.m41, matrix.m42);

    delete (matrix_tmp);
    delete (matrix);

    return result;
  }
};

/********************************************************************
                      Export
*********************************************************************/
vs.Point = Point;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and
  contributors. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/********************************************************************

*********************************************************************/

var document = (typeof window != "undefined")?window.document:null;

/**
 * Create our "vsTest" element and style that we do most feature tests on.
 * @private
 */
var vsTestElem = (document)?document.createElement ('vstestelem'):null;

/**
 * @private
 */
var vsTestStyle = (vsTestElem)?vsTestElem.style:null;
var __date_reg_exp = /\/Date\((-?\d+)\)\//;

if (vsTestStyle)
{
  if (vsTestStyle.webkitTransform !== undefined)
    vs.SUPPORT_3D_TRANSFORM =
      'WebKitCSSMatrix' in window && 'm11' in new WebKitCSSMatrix ();

  else if (vsTestStyle.MozTransform !== undefined)
    vs.SUPPORT_3D_TRANSFORM = 'MozPerspective' in vsTestStyle;

  else if (vsTestStyle.msTransform !== undefined)
    vs.SUPPORT_3D_TRANSFORM =
     'MSCSSMatrix' in window && 'm11' in new MSCSSMatrix ();

  vs.CSS_VENDOR = (function () {
    var vendors = ['MozT', 'msT', 'OT', 'webkitT', 't'],
      transform,
      l = vendors.length;

    while (--l) {
      transform = vendors[l] + 'ransform';
      if ( transform in vsTestStyle ) return vendors[l].substr(0, vendors[l].length-1);
    }

    return null;
  })();
}

vs.SUPPORT_CSS_TRANSFORM = (vs.CSS_VENDOR !== null) ? true : false;

/**
 * Represents a 4×4 homogeneous matrix that enables Document Object Model (DOM)
 * scripting access to Cascading Style Sheets (CSS) 2-D and 3-D Transforms
 * functionality.
 * @public
 * @memberOf vs
 */
vs.CSSMatrix = ('WebKitCSSMatrix' in window)?window.WebKitCSSMatrix:
  ('MSCSSMatrix' in window)?window.MSCSSMatrix:FirminCSSMatrix;

/**
 *  vs.CSSMatrix#isAffine() -> Boolean
 *
 *  Determines whether the matrix is affine.
 **/
if (!vs.CSSMatrix.prototype.isAffine) {
  vs.CSSMatrix.prototype.isAffine = function () {
    return !(this.m13 || this.m14 || this.m23 || this.m24 || this.m31 ||
      this.m32 ||this.m33 !== 1 && this.m34 || this.m43 || this.m44 !== 1);
  }
}

var precision = 1000;

/**
 *  vs.CSSMatrix#vs.getMatrixStr() -> String
 *  return affine transformation matrix
 * @public
 * @function
 *
 *  Returns a string representation of the 3d matrix.
 **/
vs.CSSMatrix.prototype.getMatrixStr = function () {
  var points = [
    ~~(this.a * precision) / precision,
    ~~(this.b * precision) / precision,
    ~~(this.c * precision) / precision,
    ~~(this.d * precision) / precision,
    ~~(this.e * precision) / precision,
    ~~(this.f * precision) / precision
  ];
  return "matrix(" + points.join(", ") + ")";
}

/**
 *  vs.CSSMatrix#vs.getMatrix3dStr() -> String
 * @public
 * @function
 *
 *  Returns a string representation of the 3d matrix.
 **/
vs.CSSMatrix.prototype.getMatrix3dStr = function () {
  var points = [
    ~~(this.m11 * precision) / precision,
    ~~(this.m12 * precision) / precision,
    ~~(this.m13 * precision) / precision,
    ~~(this.m14 * precision) / precision,
    ~~(this.m21 * precision) / precision,
    ~~(this.m22 * precision) / precision,
    ~~(this.m23 * precision) / precision,
    ~~(this.m24 * precision) / precision,
    ~~(this.m31 * precision) / precision,
    ~~(this.m32 * precision) / precision,
    ~~(this.m33 * precision) / precision,
    ~~(this.m34 * precision) / precision,
    ~~(this.m41 * precision) / precision,
    ~~(this.m42 * precision) / precision,
    ~~(this.m43 * precision) / precision,
    ~~(this.m44 * precision) / precision
  ];
  return "matrix3d(" + points.join(", ") + ")";
}
/**
 * Tells the browser that you wish to perform an animation and requests
 * that the browser schedule a repaint of the window for the next animation
 * frame. The method takes as an argument a callback to be invoked before
 * the repaint.
 *
 * @public
 * @function
 * @memberOf vs
 *
 * @param {Function} callback A parameter specifying a function to call
 *        when it's time to update your animation for the next repaint.
 */
var requestAnimationFrame =
  window.requestAnimationFrame ||
  window.webkitRequestAnimationFrame ||
  window.mozRequestAnimationFrame ||
  window.oRequestAnimationFrame ||
  window.msRequestAnimationFrame ||
  function (callback) { window.setTimeout (callback, 1000 / 60); };

vs.requestAnimationFrame = requestAnimationFrame.bind (window);

var cancelRequestAnimationFrame = window.cancelRequestAnimationFrame ||
  window.webkitCancelAnimationFrame ||
  window.mozCancelAnimationFrame ||
  window.oCancelAnimationFrame ||
  window.msCancelAnimationFrame ||
  clearTimeout;

vs.cancelRequestAnimationFrame = cancelRequestAnimationFrame.bind (window);

var setImmediate =
  window.setImmediate ||
  function (func, args) { return this.setTimeout (func, 0, args); };

vs.setImmediate = setImmediate.bind (window);
  
var clearImmediate =
  window.clearImmediate || window.clearTimeout;
  
vs.clearImmediate = clearImmediate.bind (window);

/********************************************************************

*********************************************************************/

/**
 * extend with __defineSetter__/__defineGetter__ compatible API
 *
 * @private
 */
function _extend_api1 (destination, source)
{
  for (var property in source)
  {
    getter = source.__lookupGetter__ (property);
    setter = source.__lookupSetter__ (property);

    if (getter)
    {
      destination.__defineGetter__ (property, getter)
    }
    if (setter)
    {
      destination.__defineSetter__ (property, setter)
    }
    if (!getter && !setter)
    {
      destination [property] = source [property];
    }
  }
  return destination;
}

/**
 * extend with Object.defineProperty compatible API
 *
 * @private
 */
function _extend_api2 (destination, source)
{
  for (var property in source)
  {
    var desc = Object.getOwnPropertyDescriptor (source, property);

    if (desc && (desc.get || desc.set))
    {
      util.defineProperty (destination, property, desc);
    }
    else
    {
      destination [property] = source [property];
    }
  }
  return destination;
}

/**
 * Copies all properties from the source to the destination object.
 *
 * @memberOf vs.util
 *
 * @param {Object} destination The object to receive the new properties.
 * @param {Object} source The object whose properties will be duplicated.
 **/
vs.util.extend = (Object.defineProperty)?_extend_api2:_extend_api1;

/**
 * Extends a the prototype of a object
 *
 * @memberOf vs.util
 *
 * @param {Object} destination The Class to receive the new properties.
 * @param {Object} source The Class whose properties will be duplicated.
 **/
var extendClass = function (obj, extension)
{
  if (!obj || !extension) { return; }
  if (!obj.prototype || !extension.prototype) { return; }

  try
  {
    if (Object.__proto__)
    {
      obj.prototype.__proto__ = extension.prototype;
    }
    else
    {
      var proto = obj.prototype;
      obj.prototype = new extension ();

      util.extend (obj.prototype, proto);
    }

    if (!obj.__properties__) obj.__properties__ = [];
    if (extension.__properties__)
    {
      obj.__properties__ = obj.__properties__.concat (extension.__properties__);
    }

    return obj;
  }
  catch (e)
  {
    console.error (e.message ());
  }
}

/**
 * Free a ViniSketch object
 *
 * @memberOf vs.util
 *
 * @param {Object} obj the object to free
 */
function free (obj)
{
  if (!obj) { return; }
  if (obj._free) { obj._free (); }
  if (obj.destructor) { obj.destructor (); }
  delete (obj);
  obj = null;
}

/**
 * Defines a new property directly on an object, or modifies an existing
 * property on an object.<br/><br/>
 *
 * Property descriptors present in objects come in two main flavors: data
 * descriptors and accessor descriptors. A data descriptor is a property that
 * has a value, which may or may not be writable. An accessor descriptor is a
 * property described by a getter-setter pair of functions. A descriptor must be
 * one of these two flavors; it cannot be both. All descriptors regardless of
 * flavor include the configurable and enumerable fields.<br/><br/>
 *
 * A property descriptor is an object with the following fields:
 * <ul>
 * <ol> <b>value</b> The value associated with the property. (data descriptors
 * only). <br/><i>Defaults to undefined.</i></ol>
 * <ol> <b>writable</b> True if and only if the value associated with the
 * property may be changed. (data descriptors only).<br/>
 * <i>Defaults to false.</ol>
 * <ol> <b>get</b> A function which serves as a getter for the property, or
 * undefined if there is no getter. (accessor descriptors only).<br/>
 * <i>Defaults to undefined.</i></ol>
 * <ol> <b>set</b> A function which serves as a setter for the property, or
 * undefined if there is no setter. (accessor descriptors only).<br/>
 * <i>Defaults to undefined.</i></ol>
 * <ol> <b>configurable</b> True if and only if the type of this property
 * descriptor may be changed and if the property may be deleted from the
 * corresponding object.<br/><i>Defaults to true.</i></ol>
 * <ol> <b>enumerable</b> True if and only if this property shows up during
 * enumeration of the properties on the corresponding object. <br/>
 * Defaults to true.</i></ol></ul>
 *
 * @memberOf vs.util
 *
 * @param {Object} obj The object on which to define the property.
 * @param {String} prop_name The name of the property to be defined or modified.
 * @param {Object} desc The descriptor for the property being defined or
 * modified
 */


/**
 * defineProperty with __defineSetter__/__defineGetter__ API
 *
 * @private
 */
function _defineProperty_api1 (obj, prop_name, desc)
{
  function hasProperty (obj, prop)
  {
    return Object.prototype.hasOwnProperty.call (obj, prop);
  }

  if (hasProperty (desc, "set"))
  {
    var s = desc.set;
    if (isFunction (s)) obj.__defineSetter__(prop_name, s);
  }

  if (hasProperty (desc, "get"))
  {
    var s = desc.get;
    if (isFunction (s)) obj.__defineGetter__(prop_name, s);
  }
}

/**
 * defineProperty with Object.defineProperty API
 *
 * @private
 */
function _defineProperty_api2 (obj, prop_name, desc)
{
  function hasProperty (obj, prop)
  {
    return Object.prototype.hasOwnProperty.call (obj, prop);
  }

  if (typeof desc != "object" || desc === null)
  {
    throw new TypeError ("bad desc");
  }

  if (typeof prop_name != "string" || prop_name === null)
  {
    throw new TypeError ("bad property name");
  }

  var d = {};

  if (hasProperty (desc, "enumerable")) d.enumerable = !!desc.enumerable;
  else d.enumerable = true;
  if (hasProperty (desc, "configurable")) d.configurable = !!desc.configurable;
  else d.configurable = true;
  if (hasProperty (desc, "value")) d.value = desc.value;
  if (hasProperty (desc, "writable")) d.writable = !!desc.writable;
  if (hasProperty (desc, "get"))
  {
    var g = desc.get;
    if (isFunction (g)) d.get = g;
  }
  if (hasProperty (desc, "set"))
  {
    var s = desc.set;
    if (isFunction (s)) d.set = s;
  }

  if (("get" in d || "set" in d) && ("value" in d || "writable" in d))
    throw new TypeError("identity-confused descriptor");

  Object.defineProperty (obj, prop_name, d);
}

/**
 * Defines a new property directly on the object's prototype, or modifies an
 * existing property on an object's prototype.<br/><br/>
 *
 * Property descriptors present in objects come in two main flavors: data
 * descriptors and accessor descriptors. A data descriptor is a property that
 * has a value, which may or may not be writable. An accessor descriptor is a
 * property described by a getter-setter pair of functions. A descriptor must be
 * one of these two flavors; it cannot be both. All descriptors regardless of
 * flavor include the configurable and enumerable fields.<br/><br/>
 *
 * A property descriptor is an object with the following fields:
 * <ul>
 * <ol> <b>value</b> The value associated with the property. (data descriptors
 * only). <br/><i>Defaults to undefined.</i></ol>
 * <ol> <b>writable</b> True if and only if the value associated with the
 * property may be changed. (data descriptors only).<br/>
 * <i>Defaults to false.</ol>
 * <ol> <b>get</b> A function which serves as a getter for the property, or
 * undefined if there is no getter. (accessor descriptors only).<br/>
 * <i>Defaults to undefined.</i></ol>
 * <ol> <b>set</b> A function which serves as a setter for the property, or
 * undefined if there is no setter. (accessor descriptors only).<br/>
 * <i>Defaults to undefined.</i></ol>
 * <ol> <b>configurable</b> True if and only if the type of this property
 * descriptor may be changed and if the property may be deleted from the
 * corresponding object.<br/><i>Defaults to true.</i></ol>
 * <ol> <b>enumerable</b> True if and only if this property shows up during
 * enumeration of the properties on the corresponding object. <br/>
 * Defaults to true.</i></ol></ul>
 *
 * @memberOf vs.util
 *
 * @param {Object} the_class The object's prototype on which to define the
 * property.
 * @param {String} prop_name The name of the property to be defined or modified.
 * @param {Object} desc The descriptor for the property being defined or
 * modified
 */
function defineClassProperty (the_class, prop_name, desc)
{
  if (!desc) { return; }
  if (!the_class.__properties__) the_class.__properties__ = [];
  if (!the_class.prototype) {
    throw ("defineClassProperty on a Class without prototype");
  }
  util.defineProperty (the_class.prototype, prop_name, desc);
  if (desc.enumerable != false) the_class.__properties__.push (prop_name);
}

/**
 * Defines new or modifies existing properties directly on an 'class'.<br/><br/>
 *
 * @see vs.util.defineClassProperty
 *
 * @memberOf vs.util
 *
 * @param {Object} the_class The 'class' on which to define the property.
 * @param {Object} properties An object whose own enumerable properties
 *   constitute descriptors for the properties to be defined or modified.
 */
function defineClassProperties (the_class, properties)
{
  if (!the_class.prototype) {
    throw ("defineClassProperties on a Class without prototype");
  }

  var keys = Object.keys (properties), i = 0, l = keys.length, prop_name, desc;
  for (; i < l; i++)
  {
    prop_name = keys [i]
    desc = properties [prop_name];
    defineClassProperty (the_class, prop_name, desc);
  }
}

/********************************************************************
                    Object management
*********************************************************************/

/**
 * @private
 * @const
 */
var NULL_TYPE = 'Null';

/**
 * @private
 * @const
 */
var UNDEFINED_TYPE = 'Undefined';

/**
 * @private
 * @const
 */
var BOOLEAN_TYPE = 'Boolean';

/**
 * @private
 * @const
 */
var NUMBER_TYPE = 'Number';

/**
 * @private
 * @const
 */
var STRING_TYPE = 'String';

/**
 * @private
 * @const
 */
var OBJECT_TYPE = 'Object';

/**
 * @private
 * @const
 */
var BOOLEAN_CLASS = '[object Boolean]';

/**
 * @private
 * @const
 */
var NUMBER_CLASS = '[object Number]';

/**
 * @private
 * @const
 */
var STRING_CLASS = '[object String]';

/**
 * @private
 * @const
 */
var ARRAY_CLASS = '[object Array]';

/**
 * @private
 * @const
 */
var OBJECT_CLASS = '[object Object]';

/**
 * @private
 */
function clone (object)
{
  var destination;

  switch (object)
  {
    case null: return null;
    case undefined: return undefined;
  }
  
  if (object.clone) return object.clone ();

  switch (_toString.call (object))
  {
    case OBJECT_CLASS:
    case OBJECT_TYPE:
      destination = {};
      for (var property in object)
      {
        destination[property] = clone (object [property]);
      }
      return destination;

    case ARRAY_CLASS: // should not occur because of Array.clone
      destination = [];
      for (var i = 0; i < object.length; i++)
      {
        destination [i] = clone (object [i]);
      }
      return destination;

    case BOOLEAN_TYPE:
    case NUMBER_TYPE:
    case STRING_TYPE:
    case BOOLEAN_CLASS:
    case NUMBER_CLASS:
    case STRING_CLASS:
    default:
      return object;
  }
};

/**
 *  Returns a JSON string.
 *
 *  @memberOf vs.util
 *
 * @param {Object} value The object to be serialized.
 **/
function toJSON (value)
{
  return JSON.stringify (value);
};

/********************************************************************
                    Testing methods
*********************************************************************/

/**
 * @private
 **/
var _toString = Object.prototype.toString;

/**
 *  Returns `true` if `object` is a DOM node of type 1; `false` otherwise.
 *
 *  @example
 *
 *  vs.util.isElement(new Element('div'));
 *  //-> true
 *
 *  vs.util.isElement(document.createElement('div'));
 *  //-> true
 *
 *  vs.util.isElement(document.createTextNode('foo'));
 *  //-> false
 *
 *  @memberOf vs.util
 *
 * @param {Object} object The object to test.
 **/
function isElement (object)
{
  return !!(object && object.nodeType === 1);
};

/**
 *  Returns `true` if `object` is an [[Array]]; `false` otherwise.
 *
 *  @example
 *
 *  vs.util.isArray([]);
 *  //-> true
 *
 *  vs.util.isArray({ });
 *  //-> false
 *
 *  @memberOf vs.util
 *
 * @param {Object} object The object to test.
 **/
var isArray = Array.isArray ||
  function (object) { return _toString.call (object) === ARRAY_CLASS;};

/**
 *  Returns `true` if `object` is an Function; `false` otherwise.
 *
 *  @memberOf vs.util
 *
 * @param {Object} object The object to test.
 **/
function isFunction (object)
{
  return typeof object === "function";
};

/**
 *  Returns `true` if `object` is an String; `false` otherwise.
 *
 *  @example
 *
 *  vs.util.isString ("qwe");
 *  //-> true
 *
 *  vs.util.isString (123);
 *  //-> false
 *
 *  @memberOf vs.util
 *
 * @param {Object} object The object to test.
 **/
function isString (object)
{
  return _toString.call (object) === STRING_CLASS;
};

/**
 *  Returns `true` if `object` is an Number; `false` otherwise.
 *
 *  @example
 *
 *  vs.util.isNumber (123);
 *  //-> true
 *
 *  vs.util.isNumber (1.23);
 *  //-> true
 *
 *  vs.util.isNumber ("123");
 *  //-> false
 *
 *  @memberOf vs.util
 *
 * @param {Object} object The object to test.
 **/
function isNumber (object)
{
  return (typeof object === 'number' && isFinite(object)) ||
      object instanceof Number;
};

/**
 *  Returns `true` if `object` is an "pure" Object; `false` otherwise.
 *
 *  @example
 *
 *  vs.util.isObject (123);
 *  //-> false
 *
 *  vs.util.isObject ([]);
 *  //-> false
 *
 *  vs.util.isObject ({});
 *  //-> true
 *
 *  vs.util.isObject (document);
 *  //-> false // YEP !
 *
 *  vs.util.isObject (vs.util);
 *  //-> true
 *
 *  vs.util.isObject (new Date);
 *  //-> false // YEP !
 *
 *  @memberOf vs.util
 *
 * @param {Object} object The object to test.
 **/
function isObject (object) {
  try {
    return (Object.getPrototypeOf (object) === Object.prototype);
  } catch (e) {
    return false;
  }
};

/**
 *  Returns `true` if `object` is of type `undefined`; `false` otherwise.
 *
 *  @example
 *
 *  vs.util.isUndefined ();
 *  //-> true
 *
 *  vs.util.isUndefined (undefined);
 *  //-> true
 *
 *  vs.util.isUndefined (null);
 *  //-> false
 *
 *  vs.util.isUndefined (0);
 *  //-> false
 *
 *  @memberOf vs.util
 *
 * @param {Object} object The object to test.
 **/
function isUndefined (object)
{
  return typeof object === "undefined";
};

/********************************************************************
                    Element Class testing
*********************************************************************/

/**
 *  Checks whether element has the given CSS className.
 *
 *  <p>
 *  @example
 *  elem.hasClassName ('selected');
 *  // -> true | false
 *
 *  @memberOf vs.util
 *
 * @param {String} className the className to check
 * @return {Boolean} true if the element has the given className
*/
function hasClassName (element, className)
{
  if (!element) { return; }
  var elementClassName = element.className;
  return (elementClassName && elementClassName.length > 0 &&
    (elementClassName === className ||
    new RegExp("(^|\\s)" + className + "(\\s|$)").test(elementClassName)));
}

/**
 *  Adds a CSS classname to Element.
 *
 *  @example
 *  elem.addClassName ('selected');
 *
 *  @memberOf vs.util
 *
 * @param {String} className the className to add
*/
function addClassName ()
{
  var element = arguments [0], className, i = 1;
  if (!element) { return; }
  for (; i < arguments.length; i++)
  {
    className = arguments [i];
    if (!hasClassName(element, className))
    {
      element.className = (element.className ? element.className + ' ' : '') + className;
    }
  }
  return element;
}

/**
 *  Removes element’s CSS className
 *
 *  <p>
 *  @example
 *  elem.removeClassName ('selected');
 *
 *  @memberOf vs.util
 *
 * @param {String} className the className to remove
*/
function removeClassName ()
{
  var element = arguments [0], className, i = 1;
  if (!element || !element.className) { return; }
  for (; i < arguments.length; i++)
  {
    className = arguments [i];
    element.className = strip (element.className.replace (
      new RegExp("(^|\\s+)" + className + "(\\s+|$)"), ' '));
  }
  return element;
}

/**
 *  Toggles element’s CSS className
 *
 *  <p>
 *  @example
 *  elem.toggleClassName ('selected');
 *
 *  @memberOf vs.util
 *
 * @param {String} className the className
*/
function toggleClassName (element, className)
{
  if (!element) { return; }
  return hasClassName(element, className) ?
    removeClassName(element, className): addClassName(element, className);
}

/********************************************************************
                    String manipulation
*********************************************************************/

/**
 * HTML-encodes a string and returns the encoded string.
 *
 *  @memberOf vs.util
 *
 * @param {String} str String The string
 */
function htmlEncode (str)
{
  if (!isString (str)) return '';

  return str.replace (/&/g, "&amp;").
    replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

/**
 *  Strips all leading and trailing whitespace from a string.
 *
 *  @memberOf vs.util
 *
 * @param {String} str String The string
 */
function strip (str)
{
  if (!isString (str)) return '';

  return str.replace(/^\s+/, '').replace(/\s+$/, '');
}

/**
 *  Converts a string separated by dashes into a camelCase equivalent
 *
 *  @memberOf vs.util
 *
 * @param {String} str String The string
 * @return {String} the result
 */
function camelize (str)
{
  if (!isString (str)) return '';

  var parts = str.split ('-'), len = parts.length;
  if (len === 1) { return parts [0]; }

  var camelized = str.charAt (0) === '-'
    ? parts [0].charAt (0).toUpperCase () + parts [0].substring (1)
    : parts [0];

  for (var i = 1; i < len; i++)
    camelized += parts[i].charAt (0).toUpperCase() + parts[i].substring (1);

  return camelized;
}

/**
 *  Converts a string separated by dashes into a camelCase equivalent
 *
 *  @memberOf vs.util
 *
 * @param {String} str String The string
 * @return {String} the result
 */
function capitalize (str)
{
  if (!isString (str)) return '';

  return str.charAt(0).toUpperCase() + str.substring(1).toLowerCase();
}

/**
 *  Converts a camelized string into a series of words separated by an
 *  underscore (_).
 *
 *  @memberOf vs.util
 *
 * @param {String} str String The string
 * @return {String} the result
 */
function underscore (str)
{
  if (!isString (str)) return '';

  return str.replace (/::/g, '/')
            .replace (/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
            .replace (/([a-z\d])([A-Z])/g, '$1_$2')
            .replace (/-/g, '_')
            .toLowerCase ();
}

/**
 *  Parse a json string. <p/>
 *  This function use the JSON.parse function but it manage also
 *  Date parsing wich is not managed by the JSON.parse
 *
 *  @memberOf vs.util
 *  @ignore
 *
 * @param {String} str String The string
 * @return {Object} the result
 */
function parseJSON (json)
{
  if (!json) return null;
  var temp = JSON.parse (json);

  if (!__date_reg_exp.test (json)) return temp;

  function manageDate (obj)
  {
    if (isString (obj))
    {
      var result = __date_reg_exp.exec (obj);
      if (result && result [1]) // JSON Date -> Date generation
      {
        obj = new Date (parseInt (result [1]));
      }
    }
    else if (isArray (obj))
    {
      for (var i = 0; i < obj.length; i++) { obj [i] = manageDate (obj [i]); }
    }
    else if (obj instanceof Date) { return obj; }
    else if (obj instanceof Object)
    {
      for (var key in obj) { obj [key] = manageDate (obj [key]); }
    }
    return obj;
  }
  return manageDate (temp);
};

/********************************************************************
                    Element management
*********************************************************************/

/**
 *  Returns the height of `element`.<br/>
 *
 *  This method returns correct values on elements whose display is set to
 *  `none` either in an inline style rule or in an CSS stylesheet.
 *
 *  @memberOf vs.util
 *
 * @param {Element} elem The element
 *	@returns {Number} the height
 **/
function getElementHeight (elem)
{
  if (!isElement (elem)) return;

  return getElementDimensions (elem).height;
};

/**
 *  Returns the width of `element`.<br/>
 *
 *  This method returns correct values on elements whose display is set to
 *  `none` either in an inline style rule or in an CSS stylesheet.
 *
 *  @memberOf vs.util
 *
 * @param {Element} elem The element
 *	@returns {Number} the width
 **/
function getElementWidth (elem)
{
  if (!isElement (elem)) return;

  return getElementDimensions (elem).width;
};

/**
 *  Finds the computed width and height of `element` and returns them as
 *  key/value pairs of an object.<br/>
 *  <p/>
 *  For backwards-compatibility, these dimensions represent the dimensions
 *  of the element's "border box" (including CSS padding and border).<br/> This
 *  is equivalent to the built-in `offsetWidth` and `offsetHeight`
 *  browser properties.
 *
 *  @memberOf vs.util
 *
 * @param {Element} elem The element
 *	@returns {Object} the key/value width & height
 **/
function getElementDimensions (elem)
{
  if (!isElement (elem)) return {};

  var display = getElementStyle (elem, 'display'),
    els = elem.style, originalVisibility = els.visibility,
    originalPosition = els.position, originalDisplay = els.display,
    originalWidth = 0, originalHeight = 0;

  if (display !== 'none' && display !== null) // Safari bug
  {
    return {width: elem.offsetWidth, height: elem.offsetHeight};
  }
  // All *Width and *Height properties give 0 on elements with display none,
  // so enable the element temporarily

  els.visibility = 'hidden';
  els.position = 'absolute';
  els.display = 'block';

  originalWidth = elem.clientWidth;
  originalHeight = elem.clientHeight;
  els.display = originalDisplay;
  els.position = originalPosition;
  els.visibility = originalVisibility;

  return {width: originalWidth, height: originalHeight};
};

/**
 *  Returns the given CSS property value of `element`.<br/> The property can be
 *  specified in either its CSS form (`font-size`) or its camelized form
 *  (`fontSize`).<br/>
 *
 *  This method looks up the CSS property of an element whether it was
 *  applied inline or in a stylesheet. It works around browser inconsistencies
 *  regarding `float`, `opacity`, which returns a value between `0`
 *  (fully transparent) and `1` (fully opaque), position properties
 *  (`left`, `top`, `right` and `bottom`) and when getting the dimensions
 *  (`width` or `height`) of hidden elements.
 *
 *  @example
 *
 *  getElementStyle (elem, 'fontSize');
 *  // -> '12px'
 *
 *  @memberOf vs.util
 *
 * @param {Element} elem The element
 * @param {String} style The style to find
 *	@returns {Object} the key/value width & height
 **/
function getElementStyle (elem, style)
{
  if (!isElement (elem)) return;

  style = style === 'float' ? 'cssFloat' : camelize (style);
  var value = elem.style[style], css;
  if (!value || value === 'auto')
  {
    css = document.defaultView.getComputedStyle (elem, null);
    value = css ? css[style] : null;
  }
  if (style === 'opacity') { return value ? parseFloat (value) : 1.0; }
  return value === 'auto' ? null : value;
};

/**
 *  Modifies `element`'s CSS style properties. Styles are passed as a hash of
 *  property-value pairs in which the properties are specified in their
 *  camelized form.
 *
 * @example
 * setElementStyle ({color: 'red', display: 'block'});
 * // add/set color and display properties
 * setElementStyle ({color: undefined});
 * // remove color property
 *
 *  @memberOf vs.util
 *
 * @param {Element} elem The element
 * @param {Object} style The style to modify
 */
function setElementStyle (elem, styles)
{
  if (!isElement (elem)) return;

  var elementStyle = elem.style, property;

  for (property in styles)
  {
    if (property === 'opacity')
    {
      setElementOpacity (elem, styles[property]);
    }
    else
    {
      if (!styles [property])
      {
        elementStyle.removeProperty (property);
      }
      elementStyle[(property === 'float' || property === 'cssFloat') ?
        (isUndefined(elementStyle.styleFloat) ? 'cssFloat' : 'styleFloat') :
          property] = styles[property];
    }
  }
};

/**
 *  Sets the visual opacity of an element while working around inconsistencies
 *  in various browsers. The `opacity` argument should be a floating point
 *  number, where the value of `0` is fully transparent and `1` is fully opaque.
 *
 *  @example
 *  // set to 50% transparency
 *  setElementOpacity (element, 0.5);
 *
 *  // these are equivalent, but allow for setting more than
 *  // one CSS property at once:
 *  setElementStyle (element, { opacity: 0.5 });
 *  setElementStyle (element, "opacity: 0.5");
 *
 *  @memberOf vs.util
 *
 * @param {Element} elem The element
 * @param {Number} value The opacity
 **/
function setElementOpacity (elem, value)
{
  if (!isElement (elem)) return;
  var elementStyle = elem.style;

  if (isUndefined (value)) elementStyle.removeProperty ('opacity');

  elementStyle.opacity = (value === 1 || value === '') ? '' :
    (value < 0.00001) ? 0 : value;
};

/**
 *  Returns the opacity of the element.
 *
 *  @memberOf vs.util
 *
 * @param {Element} elem The element
 * @return {Number} value The opacity
 **/
function getElementOpacity (elem)
{
  if (!isElement (elem)) return;

  return getElementStyle (elem, 'opacity');
};

/**
 * Compute the elements position in terms of the window viewport
 * Returns a vs.Point {x, y}
 *
 *  @memberOf vs.util
 *
 * @return {vs.Point} the x,y absolute position of a element
 **/
function getElementAbsolutePosition (element, force)
{
  if (!element)
  { return null; }
  if (!force && element.getBoundingClientRect)
  {
    var rec = element.getBoundingClientRect ();
    if (rec) { return new vs.Point (rec.left, rec.top); }
  }
  var
    x = 0, y = 0;
    parent = element,
    borderXOffset = 0,
    borderYOffset = 0;
    
  while (parent)
  {
    borderXOffset = 0;
    borderYOffset = 0;
    if (parent != element)
    {
      borderXOffset = parseInt (
        parent.currentStyle?
        parent.currentStyle ["borderLeftWidth"]:0, 0);
      borderYOffset = parseInt (
        parent.currentStyle?
        parent.currentStyle ["borderTopWidth"]:0, 0);
      borderXOffset = isNaN (borderXOffset) ? 0 : borderXOffset;
      borderYOffset = isNaN (borderYOffset) ? 0 : borderYOffset;
    }

    if (parent instanceof HTMLBodyElement) {
      x += parent.offsetLeft - document.documentElement.scrollLeft + borderXOffset;
      y += parent.offsetTop - document.documentElement.scrollTop + borderYOffset;
      parent = null;
    }
    else {
      x += parent.offsetLeft - parent.scrollLeft + borderXOffset;
      y += parent.offsetTop - parent.scrollTop + borderYOffset;
      parent = parent.offsetParent;
    }
  }
  return new vs.Point (x, y);
}

/**
 * @private
 */
function _getBoundingClientRect_api1 (e)
{
  var rec = getElementAbsolutePosition (e);
  return {
    width: e.offsetWidth,
    height: e.offsetWidth,
    left: rec.x,
    top: rec.y
  }
};

/**
 * @private
 */
function _getBoundingClientRect_api2 (e)
{
  return (e && e.getBoundingClientRect)?e.getBoundingClientRect ():null;
};

/**
 *  Set the absolute element position.
 *
 *  @memberOf vs.util
 *
 * @param {Element} elem The element
 * @param {Number} x The element left position
 * @param {Number} y The element top position
 **/
function setElementPos (elem, x, y)
{
  if (!elem) { return; }
  var elementStyle = elem.style;

  elementStyle.left = x + 'px';
  elementStyle.top = y + 'px';
}

/**
 * Set the element size
 *
 *  @memberOf vs.util
 *
 * @param {Element} elem The element
 * @param {Number} w The element width
 * @param {Number} w The element height
 **/
function setElementSize (elem, w, h)
{
  if (!elem) { return; }
  var elementStyle = elem.style;

  elementStyle.width = w + 'px';
  elementStyle.height = h + 'px';
}

/**
 *  Set the element HTML visibility
 *
 *  @memberOf vs.util
 *
 * @param {Element} elem The element
 * @param {boolean} v True if the element should be visible or false
 **/
function setElementVisibility (elem, v)
{
  if (!elem) { return; }
  var elementStyle = elem.style;

  if (elementStyle || util.isString (elem.innerHTML))
  {
    if (v)
    {
      elementStyle.visibility = 'visible';
    }
    else
    {
      elementStyle.visibility = 'hidden';
    }
  }
//  else if (elem instanceof CharacterData)
//  {}
  else // SVG
  {
    if (v)
    {
      elem.setAttribute ('visibility', 'visible');
    }
    else
    {
      elem.setAttribute ('visibility', 'hidden');
    }
  }
}

/**
 *  Return true if the element is visible, false otherwise
 *
 *  @memberOf vs.util
 *
 * @param {Element} elem The element
 * @return {boolean}
 **/
function isElementVisible (elem)
{
  if (!elem) { return false; }
  var elementStyle = elem.style;

  if (elementStyle || util.isString (elem.innerHTML))
  {
    if (elementStyle.visibility === 'hidden') { return false; }
    else { return true; }
  }
  else if (elem instanceof CharacterData)
  {
    return true;
  }
  else // SVG
  {
    if (elem.getAttribute ('visibility') === 'hidden') { return false; }
    else { return true; }
  }
}

/**
 *  Remove all element children
 *
 *  @memberOf vs.util
 *
 * @param {Element} elem The element
 **/
function removeAllElementChild (elem)
{
  if (!elem || !elem.childNodes) { return; }

  var l = elem.childNodes.length;
  while (l--)
  {
    elem.removeChild (elem.firstChild);
  }
};

/**
 *  Safe set inner HTML of a element
 *
 *  @memberOf vs.util
 *
 * @param {Element} elem The element
 * @param {String} txt The text
 **/
function safeInnerHTML (elem, html_text)
{
  if (!elem || !isString (html_text)) { return; }

  // MS Window 8 management
  if (window.MSApp && window.MSApp.execUnsafeLocalFunction)
    window.MSApp.execUnsafeLocalFunction (function() {
      elem.innerHTML = html_text;
    });
  else
  {
    // deactivated because to restrictive
    // if (window.toStaticHTML) html_text = window.toStaticHTML (html_text);
    elem.innerHTML = html_text;
  }
};

/**
 *  Set inner Text content of a element
 *
 *  @memberOf vs.util
 *
 * @param {Element} elem The element
 * @param {String} txt The text
 **/
function setElementInnerText (elem, text)
{
  if (!elem) { return; }

  removeAllElementChild (elem); //... deroule

  if (!util.isString (text))
  {
    if (text === undefined) { text = ""; }
    else if (text === null) { text = ""; }
    else if (util.isNumber (text)) { text = "" + text; }
    else if (text.toString) { text = text.toString (); }
    else { text = ""; }
  }
  var lines = text.split ('\n'), i = 0;
  if (!lines.length) { return; }
  elem.appendChild (document.createTextNode (lines [i]));
  i++;
  for (; i < lines.length; i++)
  {
    elem.appendChild (document.createElement ('br'));
    elem.appendChild (document.createTextNode (lines [i]));
  }
};

/**
 *@private
 */
function setElementWebkitTransform (elem, transform)
{
  if (elem && elem.style) elem.style.webkitTransform = transform;
  else console.warn ("setElementTransform, elem null or without style");
}

/**
 *@private
 */
function getElementWebkitTransform (elem)
{
  if (elem) return elem.style.webkitTransform;
}

/**
 *@private
 */
function setElementMSTransform (elem, transform)
{
  if (elem && elem.style) elem.style.msTransform = transform;
  else console.warn ("setElementTransform, elem null or without style");
}

/**
 *@private
 */
function getElementMSTransform (elem)
{
  if (elem) return elem.style.msTransform;
}

/**
 *@private
 */
function setElementMozTransform (elem, transform)
{
  if (elem && elem.style) elem.style.MozTransform = transform;
  else console.warn ("setElementTransform, elem null or without style");
}

/**
 *@private
 */
function getElementMozTransform (elem)
{
  if (elem) return elem.style.MozTransform;
}

/**
 *@private
 */
function _setElementTransform (elem, transform)
{
  if (elem && elem.style) elem.style.transform = transform;
  else console.warn ("setElementTransform, elem null or without style");
}

/**
 *@private
 */
function _getElementTransform (elem)
{
  if (elem) return elem.style.transform;
}

/**
 *  Set the CSS transformation to a element
 *
 *  @memberOf vs.util
 *
 * @param {Element} elem The element
 * @param {String} transform css transformations
 **/
var setElementTransform;

/**
 *  get the CSS transformation to a element
 *
 *  @memberOf vs.util
 *
 * @param {Element} elem The element
 * @return {Transform} transform css transformations
 **/
var getElementTransform;

if (vsTestStyle && vsTestStyle.transform !== undefined)
{
  setElementTransform = _setElementTransform;
  getElementTransform = _getElementTransform;
}
else if (vsTestStyle && vsTestStyle.webkitTransform !== undefined)
{
  setElementTransform = setElementWebkitTransform;
  getElementTransform = getElementWebkitTransform;
}
else if (vsTestStyle && vsTestStyle.msTransform !== undefined)
{
  setElementTransform = setElementMSTransform;
  getElementTransform = getElementMSTransform;
}
else if (vsTestStyle && vsTestStyle.MozTransform !== undefined)
{
  setElementTransform = setElementMozTransform;
  getElementTransform = getElementMozTransform;
}

/**
 *  get the Matrix transformation to a element
 *
 *  @memberOf vs.util
 *
 * @param {Element} elem The element
 * @return {vs.CSSMatrix} matrix3d css transformation
 **/
function getElementMatrixTransform (elem) {
  if (!elem) return;

  var
    css = document.defaultView.getComputedStyle (elem, null),
    transformMatrix;

  if (css.transform) transformMatrix = css.transform;
  else if (css.webkitTransform) transformMatrix = css.webkitTransform;
  else if (css.msTransform) transformMatrix = css.msTransform;
  else if (css.MozTransform) transformMatrix = css.MozTransform;
  
  if (transformMatrix) return new vs.CSSMatrix (transformMatrix);
}

/**
 *  Set the CSS transformation to a element
 *
 *  @memberOf vs.util
 *
 * @param {Element} elem The element
 * @param {String} origin. The value is a CSS string. Ex: '50% 0%',
 *                 or '10px 10px'
 **/
function setElementTransformOrigin (elem, value)
{
  if (elem && elem.style)
  {
    elem.style ['-' + vs.CSS_VENDOR.toLowerCase () + '-transform-origin'] = value;
  }
  else console.warn ("setElementTransformOrigin, elem null or without style");
}

/********************************************************************
                    Array extension
*********************************************************************/

/**
 * Removes the elements in the specified interval of this Array.<br/>
 * Shifts any subsequent elements to the left (subtracts one from their indices).<br/>
 * This method extends the JavaScript Array prototype.
 * By John Resig (MIT Licensed)
 *
 * @param {int} from Index of the first element to be removed
 * @param {int} to Index of the last element to be removed
 */
Array.prototype._remove = function (from, to)
{
  var rest = this.slice ((to || from) + 1 || this.length);
  this.length = from < 0 ? this.length + from : from;
  return this.push.apply (this, rest);
};


/**
 * @private
 */
var _findItem = function (obj, from)
{
  var len = this.length;

  var from = from?from:0;
  from = (from < 0)? 0: from;

  while (from < len)
  {
    if (this [from] === obj) { return from; }
    from++;
  }
  return -1;
};

/**
 *  Find an element into this Array.
 *
 * @param {Object} obj Element to locate in the array
 * @param {number} fromIndex The index at which to begin the search.
 *    Defaults to 0, i.e. the whole array will be searched.
 *    If the index is greater than or equal to the length of the
 *    array, -1 is returned
 * @return {int} the Index of the element. Return -1 if unfound.
 */
Array.prototype.findItem = Array.prototype.indexOf?
Array.prototype.indexOf:_findItem;

/**
 * Removes the elements in the specified interval of this Array.<br/>
 * Shifts any subsequent elements to the left (subtracts one from their indices).<br/>
 * This method extends the JavaScript Array prototype.
 *
 * @param {int} from Index of the first element to be removed
 * @param {int} to Index of the last element to be removed
 * @return {Array} the modified array
 */
Array.prototype.remove = function (from, to)
{
  if ((typeof(from) === "object") || util.isString (from))
  {
    var i = 0;
    while (i < this.length)
    {
      if (this[i] === from) { this._remove (i); }
      else { i++; }
    }
  }
  else { this._remove (from, to); }
  return this;
};

/**
 * Removes all elements of this Array.<br/>
 *
 * @return {Array} the modified array
 */
Array.prototype.removeAll = function ()
{
  while (this.length > 0) { this._remove (0); }
  return this;
};

/**
 * Return a copy of the array
 *
 * @return {Array} the modified array
 */
Array.prototype.clone = function ()
{
  var destination = [];
  for (var i = 0; i < this.length; i++)
  {
    destination [i] = clone (this [i]);
  }
  return destination;
};

/********************************************************************
                         export
*********************************************************************/

/**
 * Imports a JavaScript or css file into a document
 *
 * @memberOf vs.util
 *
 * @param {String} path The file path to import
 * @param {Document} doc The document into import the file
 * @param {Function} clb A function which will be called when the file is loaded
 * @param {String} type The file type ['js', 'css']
 *
 * @return {Script|Link} Returns a script or link element add to the document
 */
function importFile (path, doc, clb, type, first)
{
  if (!doc) { doc = document; }

  var js_effets, css_style;

  if (type === 'js' || path.search ('\\.js') >= 0)
  {
    js_effets = doc.createElement ("script");
    js_effets.setAttribute ("type", "text/javascript");
    js_effets.setAttribute ("src", path);
    if (clb)
    {
      js_effets.onload = function ()
      {
        clb.call (this, path);
      };
    }
    if (!doc.head) { doc.head = doc.querySelector ('head'); }
    
    if (first && doc.head.firstElementChild) {
      doc.head.insertBefore (js_effets, doc.head.firstElementChild);
    }
    else
      doc.head.appendChild (js_effets);

    return js_effets;
  }
  else if (type === 'css' || path.search('\\.css') >= 0)
  {
    css_style = doc.createElement ("link");
    css_style.setAttribute ("rel", "stylesheet");
    css_style.setAttribute ("type", "text/css");
    css_style.setAttribute ("href", path);
    css_style.setAttribute ("media", "screen");
    if (util.isFunction (clb))
    {
      var count = 0;

      /**
       * @private
       */
      (function()
      {
        if (!css_style.sheet)
        {
          if (count++ < 100)
          {
            cssTimeout = setTimeout (arguments.callee, 100);
          }
          else
          {
            console.error ('CSS load of ' + path + ' failed!');
          }
          return;
        };
        clb.call (document, path);
      })();
    }
    if (!doc.head) { doc.head = doc.querySelector ('head'); }
    
    if (first && doc.head.firstElementChild) {
      doc.head.insertBefore (css_style, doc.head.firstElementChild);
    }
    else
      doc.head.appendChild (css_style);

    return css_style;
  }
}

/********************************************************************
                         Style mamangent
*********************************************************************/

/**
 *  Modifies CSS styleSheets.
 *  <p>
 *  Modifies CSS style styleSheets. It can be preempted
 *  by css style inline modification (see vs.ui.View.setStyle).
 *  @see vs.ui.View#setStyles if you want to modify inline CSS.
 *
 *  @example
 *  vs.util.addCssRules ('.classname1', ['color: red', 'margin: 0px']);
 *
 * @memberOf vs.util
 * @function
 *
 * @param {String} selector CSS Selector
 * @param {Array} rules the array of rules
 */
function addCssRules (selector, rules)
{
  if (!isArray (rules)) { return; }

  var i = rules.length;
  while (i--)
  {
    addCssRule (selector, rules [i]);
  }
};

var __app_style_sheet__ = null;
/**
 *  Modifies CSS styleSheets.
 *  <p>
 *  Modifies CSS style styleSheets. It can be preempted
 *  by css style inline modification (see vs.ui.View.setStyle).
 *  @see vs.ui.View#setStyle if you want to modify inline CSS.
 *
 *  @example
 *  vs.util.addCssRule ('.classname1', 'color: red');
 *
 * @memberOf vs.util
 * @function
 *
 * @param {String} selector CSS Selector
 * @param {String} rule the rule using the following format:
 *   "prop_name: value"
 */
function addCssRule (selector, rule)
{
  if (!__app_style_sheet__)
  {
    var style = document.createElement ('style');
    /* For Safari */
    style.appendChild (document.createTextNode (''));
    head = document.getElementsByTagName ('head')[0];
    head.appendChild (style);

    __app_style_sheet__ =
      document.styleSheets[document.styleSheets.length - 1];
  }

  var l = 0;
  if (__app_style_sheet__.cssRules)
  {
    l = __app_style_sheet__.cssRules.length;
  } else if (__app_style_sheet__.rules)
  {
    l = __app_style_sheet__.rules.length;
  }

  if (__app_style_sheet__.insertRule)
  {
    __app_style_sheet__.insertRule (selector + ' {' + rule + '}', l);
  } else if (__app_style_sheet__.addRule)
  {
    __app_style_sheet__.addRule (selector, rule, l);
  }
};


/**
 * @private
 */
var SET_STYLE_OPTIMIZATION = true;

/**
 *  Sets the active stylesheet for the HTML document according to the specified
 *  title.
 *
 *  @memberOf vs.util
 *
 * @param {String} title
 */
var setActiveStyleSheet = function (title)
{
  var i = 0, stylesheets = document.getElementsByTagName ("link"),
    stylesheet, info, id, app, size;

  var apps = vs.Application_applications;

  if (SET_STYLE_OPTIMIZATION)
  {
    if (apps) for (id in apps)
    {
      app = apps [id];
      if (app.view) app.view.style.display = "none";
    }
  }

  for (i = 0; i < stylesheets.length; i++)
  {
    stylesheet = stylesheets [i];
    // If the stylesheet doesn't contain the title attribute, assume it's
    // a persistent stylesheet and should not be disabled
    if (!stylesheet.getAttribute ("title")) { continue; }
    // All other stylesheets than the one specified by "title" should be
    // disabled
    if (stylesheet.getAttribute ("title") !== title)
    {
      stylesheet.setAttribute ("disabled", true);
    } else
    {
      stylesheet.removeAttribute ("disabled");
    }
  }

  if (SET_STYLE_OPTIMIZATION)
  {
    if (apps) for (id in apps)
    {
      app = apps [id];
      if (app.view) app.view.style.display = "block";
    }
  }
}

/**
 *  Preload GUI HTML template for the given component.
 *  <p>
 *  When the developer uses createAndAddComponent method, the system will
 *  load the HTML GUI template associated to the component to create.
 *  This process can take times.<br>
 *  In order to minimize the latency, this class method allows to preload all
 *  data related to a component.<br>
 *  This method should ne call when the application start.
 *
 *  @example
 *  vs.util.preloadTemplate ('GUICompOne');
 *  vs.util.preloadTemplate ('GUICompTwo');
 *  ...
 *  myObject.createAndAddComponent ('GUICompOne', conf, 'children');
 *
 *  @memberOf vs.util
 *
 * @param {String} comp_name The GUI component name
 */
function preloadTemplate (comp_name)
{
  var path = comp_name + '.xhtml', xmlRequest;

  if (vs.ui && vs.ui.View && vs.ui.View.__comp_templates [path]) { return; }

  xmlRequest = new XMLHttpRequest ();
  xmlRequest.open ("GET", path, false);
  xmlRequest.send (null);

  if (xmlRequest.readyState === 4)
  {
    if (xmlRequest.status === 200 || xmlRequest.status === 0)
    {
      data = xmlRequest.responseText;
      if (vs.ui && vs.ui.View) vs.ui.View.__comp_templates [path] = data;
    }
    else
    {
      console.error
        ("Template file for component '" + comp_name + "' unfound");
      return;
    }
  }
  else
  {
    console.error
      ("Pb when load the component '" + comp_name + "' template");
    return;
  }
  xmlRequest = null;
}

/********************************************************************
                         export
*********************************************************************/

util.extend (util, {
  vsTestElem:              vsTestElem,
  vsTestStyle:             vsTestStyle,

  // Class functions
  extendClass:             extendClass,
  defineProperty:
        (Object.defineProperty)?_defineProperty_api2:_defineProperty_api1,
  defineClassProperty:     defineClassProperty,
  defineClassProperties:   defineClassProperties,
  clone:                   clone,
  free:                    free,

  // JSON functions
  toJSON:                  toJSON,

  // testing functions
  isElement:               isElement,
  isArray:                 isArray,
  isFunction:              isFunction,
  isString:                isString,
  isNumber:                isNumber,
  isObject:                isObject,
  isUndefined:             isUndefined,

  // element class
  hasClassName:    hasClassName,
  addClassName:    addClassName,
  removeClassName: removeClassName,
  toggleClassName: toggleClassName,

  // string
  htmlEncode:      htmlEncode,
  strip:           strip,
  camelize:        camelize,
  capitalize:      capitalize,
  underscore:      underscore,
  parseJSON:       parseJSON,

  // element style
  addCssRule:                 addCssRule,
  addCssRules:                addCssRules,
  getElementHeight:           getElementHeight,
  getElementWidth:            getElementWidth,
  getElementDimensions:       getElementDimensions,
  getElementStyle:            getElementStyle,
  setElementStyle:            setElementStyle,
  setElementOpacity:          setElementOpacity,
  getElementOpacity:          getElementOpacity,
  getElementAbsolutePosition: getElementAbsolutePosition,
  setElementPos:              setElementPos,
  setElementSize:             setElementSize,
  setElementVisibility:       setElementVisibility,
  isElementVisible:           isElementVisible,
  removeAllElementChild:      removeAllElementChild,
  safeInnerHTML:              safeInnerHTML,
  setElementInnerText:        setElementInnerText,
  setElementTransform:        setElementTransform,
  getElementTransform:        getElementTransform,
  getElementMatrixTransform:  getElementMatrixTransform,
  setElementTransformOrigin:  setElementTransformOrigin,
  getBoundingClientRect:
    (vsTestElem && vsTestElem.getBoundingClientRect)?
    _getBoundingClientRect_api2:_getBoundingClientRect_api1,

  // other
  importFile:           importFile,
  setActiveStyleSheet:  setActiveStyleSheet,
  preloadTemplate:      preloadTemplate,
  __date_reg_exp:       __date_reg_exp,
  _findItem:            _findItem, // export only for testing purpose
  _defineProperty_api1: _defineProperty_api1, // export only for testing purpose
  _defineProperty_api2: _defineProperty_api2, // export only for testing purpose
  _extend_api1:         _extend_api1, // export only for testing purpose
  _extend_api2:         _extend_api2 // export only for testing purpose
});
}).call(this);
(function(){ 
 var vs = this.vs, util = vs.util;

var
  CSSMatrix = (vs && vs.CSSMatrix),
  HTMLElement = (window && window.HTMLElement);

/*****************************************************************
 *                Transformation methods
 ****************************************************************/
 
/**
 *  Move the view in x, y.
 * 
 * @param x {int} translation over the x axis
 * @param y {int} translation over the y axis
 */
function translate (x, y)
{
  if (this._vs_node_tx === x && this._vs_node_ty === y) { return; }
  
  this._vs_node_tx = x;
  this._vs_node_ty = y;
  
  applyTransformation (this);
};

/**
 *  Rotate the view about the horizontal and vertical axes.
 *  <p/>The angle units is radians.
 * 
 * @param r {float} rotion angle
 */
function rotate (r)
{
  if (this._vs_node_r === r) { return; }
  
  this._vs_node_r = r;
  
  applyTransformation (this);
};

/**
 *  Scale the view
 *  <p/>The scale is limited by a max and min scale value.
 * 
 * @param s {float} scale value
 */
function scale (s)
{    
  if (this._vs_node_s === s) { return; }

  this._vs_node_s = s;
  
  applyTransformation (this);
};

/**
 *  Define a new transformation matrix, using the transformation origin 
 *  set as parameter.
 *
 * @param {vs.Point} origin is a object reference a x and y position
 */
function setNewTransformOrigin (origin)
{
  if (!origin) { return; }
//    if (!util.isNumber (origin.x) || !util.isNumber (origin.y)) { return; }
  if (!this._vs_node_origin) this._vs_node_origin = [0, 0];

  // Save current transform into a matrix
  var matrix = new CSSMatrix ();
  matrix = matrix.translate
    (this._vs_node_origin [0], this._vs_node_origin [1], 0);
  matrix = matrix.translate (this._vs_node_tx, this._vs_node_ty, 0);
  matrix = matrix.rotate (0, 0, this._vs_node_r);
  matrix = matrix.scale (this._vs_node_s, this._vs_node_s, 1);
  matrix = matrix.translate
    (-this._vs_node_origin [0], -this._vs_node_origin [1], 0);

  if (!this._vs_transform) this._vs_transform = matrix;
  {
    this._vs_transform = matrix.multiply (this._vs_transform);
    delete (matrix);
  }
  
  // Init a new transform space
  this._vs_node_tx = 0;
  this._vs_node_ty = 0;
  this._vs_node_s = 1;
  this._vs_node_r = 0;
  
  this._vs_node_origin = [origin.x, origin.y];
};


/**
 *  Remove all previous transformations set for this view
 */
function clearTransformStack ()
{
  if (this._vs_transform) delete (this._vs_transform);
  this._vs_transform = undefined;
};

/**
 *  Return the current transform matrix apply to this graphic Object.
 *
 * @return {CSSMatrix} the current transform matrix
 */
function getCTM ()
{
  var matrix = new CSSMatrix (), transform, matrix_tmp;
  if (!this._vs_node_origin) this._vs_node_origin = [0, 0];
  
  // apply current transformation
  matrix = matrix.translate (this._vs_node_origin [0], this._vs_node_origin [1], 0);
  matrix = matrix.translate (this._vs_node_tx, this._vs_node_ty, 0);
  matrix = matrix.rotate (0, 0, this._vs_node_r);
  matrix = matrix.scale (this._vs_node_s, this._vs_node_s, 1);
  matrix = matrix.translate (-this._vs_node_origin [0], -this._vs_node_origin [1], 0);    

  
  // apply previous transformations and return the matrix
  if (this._vs_transform) return matrix.multiply (this._vs_transform);
  else return matrix;
};

/**
 *  Returns the current transform combination matrix generate by the
 *  hierarchical parents of this graphic Object.
 *  Its returns the multiplication of the parent's CTM and parent of parent's
 *  CTM etc.
 *  If the component has no parent it returns the identity matrix.
 * 
 * @return {CSSMatrix} the current transform matrix
 */
function getParentCTM ()
{
  
  function multiplyParentTCM (parent)
  {
    // no parent return identity matrix
    if (!parent) return new CSSMatrix ();
    // apply parent transformation matrix recurcively 
    return multiplyParentTCM (parent.parentNode).multiply (parent.vsGetCTM ());
  }
  
  return multiplyParentTCM (this.parentNode);
};

/**
 */
function applyTransformation (node)
{
  var matrix = node.vsGetCTM ();
  
  util.setElementTransform (node, matrix.toString ());
  delete (matrix);
};

util.extend (HTMLElement.prototype, {
  _vs_node_tx:                  0,
  _vs_node_ty:                  0,
  _vs_node_s:              1,
  _vs_node_r:             0,
  vsTranslate:                   translate,
  vsRotate:                      rotate,
  vsScale:                       scale,
  vsSetNewTransformOrigin:       setNewTransformOrigin,
  vsClearTransformStack:         clearTransformStack,
  vsGetCTM:                      getCTM,
  vsGetParentCTM:                getParentCTM
});
}).call(this);
(function(){ 
 var vs = this.vs = this.vs || {}, util = vs.util = vs.util || {};

/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/* touch event messages */
var EVENT_SUPPORT_TOUCH = false;
var EVENT_SUPPORT_GESTURE = false;
var hasPointer = window.navigator.pointerEnabled;
var hasMSPointer = window.navigator.msPointerEnabled;

if (typeof document != "undefined" && 'createTouch' in document)
  EVENT_SUPPORT_TOUCH = true;

else if (hasPointer || hasMSPointer) { EVENT_SUPPORT_TOUCH = true; }

else if (typeof document != "undefined" &&
    window.navigator && window.navigator.userAgent)
{
  if (window.navigator.userAgent.indexOf ('Android') !== -1 ||
      window.navigator.userAgent.indexOf ('BlackBerry') !== -1)
  { EVENT_SUPPORT_TOUCH = true; }
}


var POINTER_START, POINTER_MOVE, POINTER_END, POINTER_CANCEL;

if (EVENT_SUPPORT_TOUCH)
{
  POINTER_START =
    hasPointer ?  'pointerdown' :
    hasMSPointer ? 'MSPointerDown' : 'touchstart';

  POINTER_MOVE =
    hasPointer ?  'pointermove' :
    hasMSPointer ? 'MSPointerMove' : 'touchmove';

  POINTER_END =
    hasPointer ?  'pointerup' :
    hasMSPointer ? 'MSPointerUp' : 'touchend';

  POINTER_CANCEL =
    hasPointer ?  'pointercancel' :
    hasMSPointer ? 'MSPointerCancel' : 'touchcancel';
}
else
{
  POINTER_START = 'mousedown';
  POINTER_MOVE = 'mousemove';
  POINTER_END = 'mouseup';
  POINTER_CANCEL = null;
}

// TODO(smus): Come up with a better solution for this. This is bad because
// it might conflict with a touch ID. However, giving negative IDs is also
// bad because of code that makes assumptions about touch identifiers being
// positive integers.
var MOUSE_ID = 31337;

function Pointer (event, type, identifier, clientX, clientY, event_bis)
{
  this.configureWithEvent (event, clientX, clientY, event_bis)
  this.type = type;
  this.identifier = identifier;
}

Pointer.prototype.configureWithEvent =
  function (evt, clientX, clientY, event_bis)
{
  this.pageX = evt.pageX;
  this.pageY = evt.pageY;
  if (typeof clientX !== "undefiend") this.clientX = clientX;
  if (typeof clientY !== "undefiend") this.clientY = clientY;
  
  if (evt.target) this.target = evt.target;
  else if (event_bis) this.target = event_bis.target;
  
  if (evt.currentTarget) this.currentTarget = evt.currentTarget;
  else if (event_bis) this.currentTarget = event_bis.currentTarget;
}

var PointerTypes = {
  TOUCH: 2,
  PEN: 3,
  MOUSE: 4
};

/**
 * Returns an array of all pointers currently on the screen.
 */

var pointerEvents = [];

function buildTouchList (evt, target_id)
{
  var pointers = [];
  evt.nbPointers = evt.touches.length;
  for (var i = 0; i < evt.nbPointers; i++)
  {
    var touch = evt.touches[i];
    var pointer = new Pointer (
      touch, PointerTypes.TOUCH, touch.identifier,
      touch.clientX, touch.clientY,
      evt
    );
    pointers.push (pointer);
  }
  evt.pointerList = pointers;
  pointers = [];
  for (var i = 0; i < evt.targetTouches.length; i++)
  {
    var touch = evt.targetTouches[i];
    if (target_id && pointerEvents [touch.identifier] != target_id) continue;
    var pointer = new Pointer (
      touch, PointerTypes.TOUCH, touch.identifier,
      touch.clientX, touch.clientY,
      evt
    );
    pointers.push (pointer);
  }
  evt.targetPointerList = pointers;
  pointers = [];
  for (var i = 0; i < evt.changedTouches.length; i++)
  {
    var touch = evt.changedTouches[i];
    var pointer = new Pointer (
      touch, PointerTypes.TOUCH, touch.identifier,
      evt.clientX, evt.clientY,
      evt
    );
    pointers.push (pointer);
  }
  evt.changedPointerList = pointers;
}

function buildMouseList (evt, remove)
{
  var pointers = [];
  pointers.push (new Pointer (
    evt, PointerTypes.MOUSE, MOUSE_ID,
    evt.layerX, evt.layerY
  ));
  if (!remove)
  {
    evt.nbPointers = 1;
    evt.pointerList = pointers;
    evt.targetPointerList = pointers;
    evt.changedPointerList = [];
  }
  else
  {
    evt.nbPointers = 0;
    evt.pointerList = [];
    evt.targetPointerList = pointers;
    evt.changedPointerList = pointers;
  }
}

var all_pointers = [];
var removed_pointers = [];

function buildMSPointerList (evt, remove, target_id)
{
  // Note: "this" is the element.
  var
    pointers = [],
    targetPointers = [],
    removePointers = [];
    
  var id = evt.pointerId, pointer = all_pointers [id];

  if (remove)
  {
    if (pointer)
    {
      removed_pointers [id] = pointer;
      all_pointers [id] = undefined;
    }
    else
    {
      pointer = removed_pointers [id];
      if (!pointer)
      {
        pointer = new Pointer
          (evt, evt.pointerType, id, evt.layerX, evt.layerY);
        removed_pointers [id] = pointer;
      }
    }
    
    removed_pointers.forEach (function (pointer) {
      if (!pointer) return;

      removePointers.push (pointer);
    });

    removed_pointers = [];
  }
  else
  {
    if (pointer) {
      pointer.configureWithEvent (evt);
    }
    else
    {
      pointer = new Pointer (evt, evt.pointerType, id, evt.layerX, evt.layerY);
      all_pointers [id] = pointer;
    }
  }

  all_pointers.forEach (function (pointer) {
    if (!pointer) return;
    
    pointers.push (pointer);
    if (target_id && pointerEvents [pointer.identifier] != target_id) return;
    targetPointers.push (pointer);
  });

  evt.nbPointers = pointers.length;
  evt.pointerList = pointers;
  evt.targetPointerList = targetPointers;
  evt.changedPointerList = removePointers;
}

/*************** Mouse event handlers *****************/

function mouseDownHandler (event, listener)
{
  buildMouseList (event);
  listener (event);
}

function mouseMoveHandler(event, listener)
{
  buildMouseList (event);
  listener (event);
}

function mouseUpHandler (event, listener)
{
  buildMouseList (event, true);
  listener (event);
}

/*************** Touch event handlers *****************/

function touchStartHandler (event, listener, target_id)
{
  var pointer, l = event.targetTouches.length;
  for (var i = 0; i < l; i++)
  {
    pointer = event.targetTouches [i];
    pointerEvents [pointer.identifier] = target_id;
  }
  buildTouchList (event);
  listener (event);
}

function touchMoveHandler (event, listener, target_id)
{
  buildTouchList (event, target_id);
  listener (event);
}

function touchEndHandler (event, listener)
{
  var pointer, l = event.changedTouches.length, i = 0;
  for (; i < l; i++)
  {
    pointer = event.changedTouches [i];
    pointerEvents [pointer.identifier] = undefined;
  }
  buildTouchList (event);
  listener (event);
}

function touchCancelHandler (event, listener)
{
  buildTouchList (event);
  listener (event, listener);
}

/*************** MSIE Pointer event handlers *****************/

// remove the pointer from the list of availables pointer
var nbPointerListener = 0;
var msRemovePointer = function (evt) {
  var id = evt.pointerId, pointer = all_pointers [id];

  if (pointer)
  {
    removed_pointers [pointer.identifier] = pointer;
    all_pointers [pointer.identifier] = undefined;
  }
  nbPointerListener --;

  if (nbPointerListener === 0)
  {
    document.removeEventListener (
      hasPointer ? 'pointerup' : 'MSPointerUp',
      msRemovePointer
    );
    document.removeEventListener (
      hasPointer ? 'pointercancel' : 'MSPointerCancel',
      msRemovePointer
    );
  }
}

function msPointerDownHandler (event, listener, target_id)
{
  pointerEvents [event.pointerId] = target_id;
  buildMSPointerList (event, false, target_id);
  listener (event);

  if (nbPointerListener === 0)
  {
    document.addEventListener (
      hasPointer ? 'pointerup' : 'MSPointerUp',
      msRemovePointer
    );
    document.addEventListener (
      hasPointer ? 'pointercancel' : 'MSPointerCancel',
      msRemovePointer
    );
  }
  nbPointerListener ++;
}

function msPointerMoveHandler (event, listener, target_id)
{
  buildMSPointerList (event, false, target_id);
  listener (event);
}

function msPointerUpHandler (event, listener)
{
  buildMSPointerList (event, true);
  listener (event);
}

function msPointerCancelHandler (event, listener)
{
  buildMSPointerList (event, true);
  listener (event);
}

/*************************************************************/

var
  pointerStartHandler, pointerMoveHandler,
  pointerEndHandler, pointerCancelHandler;

if (EVENT_SUPPORT_TOUCH)
{
  if (hasMSPointer)
  {
    pointerStartHandler = msPointerDownHandler;
    pointerMoveHandler = msPointerMoveHandler;
    pointerEndHandler = msPointerUpHandler;
    pointerCancelHandler = msPointerCancelHandler;
  }
  else
  {
    pointerStartHandler = touchStartHandler;
    pointerMoveHandler = touchMoveHandler;
    pointerEndHandler = touchEndHandler;
    pointerCancelHandler = touchCancelHandler;
  }
}
else
{
  pointerStartHandler = mouseDownHandler;
  pointerMoveHandler = mouseMoveHandler;
  pointerEndHandler = mouseUpHandler;
  pointerCancelHandler = mouseUpHandler;
}

function getBindingIndex (target, type, listener)
{
  if (!type || !listener || !listener.__event_listeners) return -1;
  for (var i = 0; i < listener.__event_listeners.length; i++)
  {
    var binding = listener.__event_listeners [i];
    if (binding.target === target &&
        binding.type === type &&
        binding.listener === listener)
      return i;
  }
  return -1;
}

function createUniqueId ()
{
  return "" + new Date().getTime() + "" + Math.floor (Math.random() * 1000000);
}

function managePointerListenerAdd (node, type, func, binding)
{
  var target_id = (binding.listener)?binding.listener.id:undefined;
  if (!target_id) {
    target_id = createUniqueId ();
    if (binding.listener) binding.listener.id = target_id;
  }
  switch (type)
  {
    case POINTER_START:
      binding.handler = function (e) {
        pointerStartHandler (e, func, target_id);
      };
      return true;
    break;

    case POINTER_MOVE:
    
      binding.handler = function (e) {
        pointerMoveHandler (e, func, target_id);
      };
      return true;
    break;

    case POINTER_END:
      binding.handler = function (e) {
        pointerEndHandler (e, func);
      };
      return true;
    break;

    case POINTER_CANCEL:
      binding.handler = function (e) {
        pointerCancelHandler (e, func);
      };
      return true;
    break;
  }
  return false;
}

function managePointerListenerRemove (node, type, binding)
{
  switch (type)
  {
    case POINTER_START:
    case POINTER_MOVE:
    case POINTER_END:
    case POINTER_CANCEL:
      return true;
    break;
  }
  return false;
}

/**
 * Option 2: Replace addEventListener with a custom version.
 */
function addPointerListener (node, type, listener, useCapture)
{
  if (!type) return;
  
  if (!listener) {
    console.error ("addPointerListener no listener");
    return;
  }
  var func = listener;
  if (!util.isFunction (listener))
  {
    func = listener.handleEvent;
    if (util.isFunction (func)) func = func.bind (listener);
  }

  if (getBindingIndex (node, type, listener) !== -1)
  {
    console.error ("addPointerListener binding already existing");
    return;
  }

  if (!listener.__event_listeners) listener.__event_listeners = [];

  var binding = {
    target: node,
    type: type,
    listener: listener
  };
  listener.__event_listeners.push (binding);

  if (!managePointerListenerAdd (node, type, func, binding))
  {
    if (!manageGestureListenerAdd (node, type, func, binding))
    {
      binding.handler = func;
    }
  }

  node.addEventListener (type, binding.handler, useCapture);
}

function removePointerListener (node, type, listener, useCapture)
{
  if (!type) return;
  
  if (!listener) {
    console.error ("removePointerListener no listener");
    return;
  }

  var index = getBindingIndex (node, type, listener);
  if (index === -1)
  {
    console.error ("removePointerListener no binding");
    return;
  }
  var binding = listener.__event_listeners [index];
  listener.__event_listeners.remove (index);

  if (!managePointerListenerRemove (node, type, binding))
  {
    if (!manageGestureListenerRemove (node, type, binding))
    {}
  }

  node.removeEventListener (type, binding.handler, useCapture);
  delete (binding);
}

function createCustomEvent (eventName, target, payload)
{
  var event = document.createEvent ('Event');
  event.initEvent (eventName, true, true);
  for (var k in payload) {
    event[k] = payload[k];
  }
  target.dispatchEvent (event);
};

/********************************************************************
                      Export
*********************************************************************/
vs.createCustomEvent = createCustomEvent;
vs.removePointerListener = removePointerListener;
vs.addPointerListener = addPointerListener;
vs.PointerTypes = PointerTypes;

/** 
 * Start pointer event (mousedown, touchstart, )
 * @name vs.POINTER_START
 * @type {String}
 * @const
 */ 
vs.POINTER_START = POINTER_START;

/** 
 * Move pointer event (mousemove, touchmove, )
 * @name vs.POINTER_MOVE 
 * @type {String}
 * @const
 */ 
vs.POINTER_MOVE = POINTER_MOVE;

/** 
 * End pointer event (mouseup, touchend, )
 * @name vs.POINTER_END 
 * @type {String}
 * @const
 */ 
vs.POINTER_END = POINTER_END;

/** 
 * Cancel pointer event (mouseup, touchcancel, )
 * @name vs.POINTER_CANCEL 
 * @type {String}
 * @const
 */ 
vs.POINTER_CANCEL = POINTER_CANCEL;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

var GESTURE_START, GESTURE_CHANGE, GESTURE_END;

var support = {};

var events = [
  'gesturestart',
  'gesturechange',
  'gestureend'
];

var el = document.createElement ('div');

for (var i = 0; i < events.length; i++)
{
  var eventName = events[i];
  eventName = 'on' + eventName;
  var isSupported = (eventName in util.vsTestElem);
  if (!isSupported)
  {
    util.vsTestElem.setAttribute(eventName, 'return;');
    isSupported = typeof util.vsTestElem[eventName] == 'function';
  }
  support [events[i]] = isSupported;
}

support.gestures =
  support.gesturestart && 
  support.gesturechange && 
  support.gestureend;

if ('MSGestureEvent' in window) support.msGestures = true;

// for now force non gesture native events
support.gestures = false;
support.msGestures = false;

/*************************************************************/

/**
 * calculate the distance between two Pointers
 * @param   Pointer  pos1 { x: int, y: int }
 * @param   Pointer  pos2 { x: int, y: int }
 */
function getDistance (pointer1, pointer2)
{
  if (!pointer1 || !pointer2) return 0;
  
  var x = pointer2.pageX - pointer1.pageX, y = pointer2.pageY - pointer1.pageY;
  return Math.sqrt ((x * x) + (y * y));
};

/**
 * calculate the angle between two points
 * @param   Pointer  pointer1 { x: int, y: int }
 * @param   Pointer  pointer2 { x: int, y: int }
 */
function getAngle (pointer1, pointer2 )
{
  if (!pointer1 || !pointer2) return 0;

  return Math.atan2 (pointer2.pageY - pointer1.pageY, pointer2.pageX - pointer1.pageX) * 180 / Math.PI;
};

var __init_distance = 0, __init_angle = 0, __init_centroid, __init_pos;

function getCentroid (pointers)
{
  var nb_pointer = pointers.length, index = 0, x = 0, y = 0;
  if (nb_pointer === 0) return {X: 0, y: 0};
 
  for (;index < nb_pointer; index++)
  {
    var pointer = pointers [index];
    
    x += pointer.pageX;
    y += pointer.pageY;
  }
  
  return {x: x / nb_pointer - __init_pos.x, y: y / nb_pointer - __init_pos.y};
};

function getTranslate (pos1, pos2)
{
  return [pos1.x - pos2.x, pos1.y - pos2.y];
}

var buildPaylaod = function (event, end)
{
  var centroid = (end)?undefined:getCentroid (event.targetPointerList);

  return {
    scale: (end)?undefined:
      getDistance (event.targetPointerList [0], event.targetPointerList [1]) /
        __init_distance,
    rotation: (end)?undefined:
      getAngle (event.targetPointerList [0], event.targetPointerList [1]) - 
        __init_angle,
    translation: (end)?undefined: getTranslate (centroid, __init_centroid),
    nbPointers : event.nbPointers,
    pointerList : event.pointerList,
    targetPointerList: event.targetPointerList,
    centroid : centroid,
    changedPointerList: event.changedPointerList
  };
};

var _gesture_follow = false;
var gestureStartListener = function (event, listener)
{
  if (event.targetPointerList.length < 2) return;
  event.preventDefault ();

  if (!_gesture_follow)
  {
    __init_distance =
      getDistance (event.targetPointerList [0], event.targetPointerList [1]);
    __init_angle =
      getAngle (event.targetPointerList [0], event.targetPointerList [1]);
    
    var comp = event.targetPointerList[0].target._comp_;
    __init_pos = util.getElementAbsolutePosition (event.targetPointerList[0].target, true);
//    init_pos = init_pos.matrixTransform (comp.getParentCTM ());
    
    __init_centroid = getCentroid (event.targetPointerList);
       
    document.addEventListener (vs.POINTER_MOVE, gestureChangeListener);
    document.addEventListener (vs.POINTER_END, gestureEndListener);
    document.addEventListener (vs.POINTER_CANCEL, gestureEndListener);
    createCustomEvent (GESTURE_START, event.target, buildPaylaod (event));
    _gesture_follow = true;
  }
  else
  {
    createCustomEvent (GESTURE_CHANGE, event.target, buildPaylaod (event));
  }
};

var gestureChangeListener = function (event)
{
  event.preventDefault ();

  pointerMoveHandler (event, function (event)
  {
    // bug with Android stock browser which does not generate POINTER_END event
    // when a finger is removed and an other finger is still touching the screen.
    // Then during the POINTER_MOVE event, test if a gesture is still possible,
    // otherwise remove bindings.
    if (event.targetPointerList.length < 2) {
      document.removeEventListener (vs.POINTER_MOVE, gestureChangeListener);
      document.removeEventListener (vs.POINTER_END, gestureEndListener);
      document.removeEventListener (vs.POINTER_CANCEL, gestureEndListener);
      _gesture_follow = false;
      createCustomEvent (GESTURE_END, event.target, buildPaylaod (event, true));    
    }
    else {
      createCustomEvent (GESTURE_CHANGE, event.target, buildPaylaod (event));
    }
  });
};

var gestureEndListener = function (event)
{
  event.preventDefault ();

  pointerEndHandler (event, function (event)
  {
    if (event.targetPointerList.length < 2)
    {
      document.removeEventListener (vs.POINTER_MOVE, gestureChangeListener);
      document.removeEventListener (vs.POINTER_END, gestureEndListener);
      document.removeEventListener (vs.POINTER_CANCEL, gestureEndListener);
      _gesture_follow = false;
      createCustomEvent (GESTURE_END, event.target, buildPaylaod (event, true));
    }
    else
    {
      createCustomEvent (GESTURE_CHANGE, event.target, buildPaylaod (event));
    }
  });
};

function buildGestureList (evt)
{
  evt.centroid = {x: evt.pageX, y: evt.pageY};
  evt.translation = getTranslate (evt.centroid, __init_centroid);
  evt.pointerList = [
    new Pointer (evt, PointerTypes.TOUCH, MOUSE_ID)
  ];
  evt.targetPointerList = evt.pointerList;
  evt.nbPointers = 1;
}

var gestureIOSStartListener = function (event, listener)
{
  __init_centroid = {x: event.pageX, y: event.pageY};
  buildGestureList (event);
  listener (event);
};

var gestureIOSChangeListener = function (event, listener)
{
  buildGestureList (event);
  listener (event);
};

var gestureIOSEndListener = function (event, listener)
{
  buildGestureList (event);
  listener (event);
};

if (support.msGestures)
{
  GESTURE_START = 'MSGestureStart';
  GESTURE_CHANGE = 'MSGestureChange';
  GESTURE_END = 'MSGestureEnd';
}
else if (support.gestures)
{
  GESTURE_START = 'gesturestart';
  GESTURE_CHANGE = 'gesturechange';
  GESTURE_END = 'gestureend';
}
else
{
  GESTURE_START = '_gesture_start';
  GESTURE_CHANGE = '_gesture_change';
  GESTURE_END = '_gesture_end';
}

function touchToGestureListenerAdd (node, type, func, binding)
{
  var target_id = (binding.listener)?binding.listener.id:undefined;
  switch (type)
  {
    case GESTURE_START:
      binding.gesture_handler =
        function (e) {pointerStartHandler (e, gestureStartListener, target_id)};
      node.addEventListener (vs.POINTER_START, binding.gesture_handler);
      binding.handler = func;

      return true;
    break;

    case GESTURE_CHANGE:
    case GESTURE_END:
      binding.handler = func;
      return true;
    break;
  }

  return false;
}

function gestureEventListenerAdd (node, type, func, binding)
{
  var target_id = (binding.listener)?binding.listener.id:undefined;
  switch (type)
  {
    case GESTURE_START:
      binding.handler = function (e) {gestureIOSStartListener (e, func, target_id);};
      return true;
    break;

    case GESTURE_CHANGE:
      binding.handler = function (e) {gestureIOSChangeListener (e, func, target_id);};
      return true;
    break;

    case GESTURE_END:
      binding.handler = function (e) {gestureIOSEndListener (e, func, target_id);};
      return true;
    break;
  }

  return false;
}

var manageGestureListenerAdd =
  (support.gestures || support.msGestures)?gestureEventListenerAdd:touchToGestureListenerAdd;

function touchToGestureListenerRemove (node, type, binding)
{
  var target_id = (binding.listener)?binding.listener.id:undefined;
  switch (type)
  {
    case GESTURE_START:
      node.removeEventListener (vs.POINTER_START, binding.gesture_handler, target_id);

      return true;
    break;

    case GESTURE_CHANGE:
    case GESTURE_END:
      return true;
    break;
  }

  return false;
}

function gestureListenerRemove (node, type, binding)
{
  switch (type)
  {
    case GESTURE_START:
    case GESTURE_CHANGE:
    case GESTURE_END:
      return true;
    break;
  }

  return false;
}

var manageGestureListenerRemove =
  (support.gestures || support.msGestures)?gestureListenerRemove:touchToGestureListenerRemove;
  
/** 
 * Start gesture event
 * @name vs.GESTURE_START
 * @type {String}
 * @const
 */ 
vs.GESTURE_START = GESTURE_START;

/** 
 * Move gesture event
 * @name vs.GESTURE_CHANGE 
 * @type {String}
 * @const
 */ 
vs.GESTURE_CHANGE = GESTURE_CHANGE;

/** 
 * End gesture event
 * @name vs.GESTURE_END 
 * @type {String}
 * @const
 */ 
vs.GESTURE_END = GESTURE_END;

}).call(this);
/** @license
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

(function (window, undefined) {

var document = window.document;

/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/********************************************************************
                   
*********************************************************************/

var vs = window.vs,
  util = vs.util,
  core = vs.core;
  
/**
 * @private
 */
var _id_index_ = 0;

/**
 * Returns a local unique Id <p>
 * The algorithm is based on an index initialized when the page is loaded.
 *
 * @memberOf vs.core
 *
 * @return {String}
 */
function createId ()
{
  return "vs_id_" + _id_index_++;
}

/**
 * Returns an unique Id <p>
 * The algorithm uses a time stamp and a random number to generate the id.
 *
 * @memberOf vs.core
 *
 * @return {String}
 */
function createUniqueId ()
{
  return "vs_id_" + new Date().getTime() + "" + Math.floor (Math.random() * 1000000);
}

/********************************************************************
                      Export
*********************************************************************/
/**
 * @private
 */
core.createId = createId;
core.createUniqueId = createUniqueId;/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
 
 Use code from Canto.js Copyright 2010 Steven Levithan <stevenlevithan.com>
*/

/**
 *  @class
 *  vs.Point is an (x, y) coordinate pair. 
 *  When you use an vs.Point object in matrix operations, the object is 
 *  treated as a vector of the following form <x, y, 1>
 *
 * @author David Thevenin
 *
 *  @constructor
 *  Main constructor
 *
 * @name vs.Point
 *
 * @param {Number} the x-coordinate value.
 * @param {Number} the y-coordinate value.
*/
function Point (x, y)
{
  if (util.isNumber (x)) this.x = x;
  if (util.isNumber (y)) this.y = y;
}

Point.prototype = {

  /*****************************************************************
   *
   ****************************************************************/
   
   x: 0,
   y: 0,
  
  /*****************************************************************
   *              
   ****************************************************************/
   
  /**
   * Applies the given 2×3 matrix transformation on this Point object and 
   * returns a new, transformed Point object.
   *
   * @name vs.Point#matrixTransform
   * @function
   * @public
   * @param {vs.CSSMatrix} matrix he matrix
   * @returns {vs.Point} the matrix
   */
  matrixTransform : function (matrix)
  {
    var matrix_tmp = new vs.CSSMatrix ();

    matrix_tmp = matrix_tmp.translate (this.x, this.y, this.z || 0);
    matrix = matrix.multiply (matrix_tmp);

    var result = new Point (matrix.m41, matrix.m42);

    delete (matrix_tmp);
    delete (matrix);

    return result;
  }
};

/********************************************************************
                      Export
*********************************************************************/
/** @private */
vs.Point = Point;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and
  contributors. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/********************************************************************

*********************************************************************/
/**
 *  @class Object
 *  vs.core.Object is the root class of most class hierarchies. Through
 *  vs.core.Object, objects inherit a basic interface for configuration
 *  and clone mechanism. It provides an unique identifier for objects.
 *
 *  @author David Thevenin
 *
 *  @constructor
 *  Main constructor
 *
 * @name vs.core.Object
 *
 * @param {Object} config the configuration structure
*/
function VSObject (config)
{
  this.constructor = core.Object;
  if (util.isString (config)) { this._id = config; }
  else if (config && config.id) { this._id = config.id; }
  else this._id = createId ();
  
  this.__df__ = [];

  if (config)
  {
    this.__config__ = config;//util.clone (config);
  }
}

VSObject.prototype =
{
  /**
   * @protected
   * @String
   */
   _id: '',

  /**
   * @protected
   * @boolean
   */
   __i__: false,
   __input_property__did__change__: false, 

  /**
   * @protected
   * @object
   */
   __config__: null,
   __df__: null,

  /**
   *  Object default init. <p>
   *
   * @name vs.core.Object#init
   * @function
   *
   *  @example
   *  myObject = new vs.core.Object (vs.core.createId ());
   *  myObject.init ();
   *  @return {Object} this
   */
  init : function (fromClone)
  {
    if (this.__i__) { return this; }

    if (!this._id)
    {
      this._id = createId ();
    }
    
    if (VSObject._obs [this._id]) {
      console.warn ("Impossible to create an object with an already used id.");
      var old_id = this._id;
      this._id = createUniqueId ();
      console.warn
        ("The id \"" + old_id + "\" is replaced by \"" + this._id + "\".");
    }

    // save the current object
    VSObject._obs [this._id] = this;

    if (!fromClone) this.initComponent ();
    this.__i__ = true;

    // Call initialization code generated by ViniSketch Designer
    if (!fromClone && this.vsdInit) this.vsdInit ();

    if (this.__config__)
    {
      this.configure (this.__config__);
      this.__config__ = null;
//      delete (this.__config__);
    }

    // Call optional end initialization method
    if (this.componentDidInitialize) this.componentDidInitialize ();

    // legacy code for application using the initSkin mechanism
    // @deprecated
    if (this.initSkin)
    {
      console.warn ("Your application shouldn't use initSkin anymore.\n\
        You should rename by componentDidInitialize.");

      // create a fake initSkin (for super call)
      VSObject.prototype.initSkin = function () {};

      // call the initSkin
      this.initSkin ();

      // remove the fake initSkin
      VSObject.prototype.initSkin = undefined;
    }

    return this;
  },

  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {},

  /**
   * @protected
   * @function
   */
  componentDidInitialize : function ()
  {},

  /**
   * @deprecated
   * @private
   */
  createId : function ()
  {
    console.warn
      ("this.createId is deprecated, Use the static method vs.core.createId instead");
    return createId ();
  },

  /**
   *  Object configuation method. <p>
   *  Call this method to adjust some properties of the internal components
   *  using one call. <br/>
   *  It takes as parameters, an associated array <propertyName, value>.
   *  <br/><br/>
   *  Ex:
   *  @example
   *  var myObject = new vs.core.Object ({id: 'myobject'});
   *  myObject.init ();
   *
   *  myObject.configure ({prop1: "1", prop2: 'hello', ..});
   *  <=>
   *  myObject.prop1 = "1";
   *  myObject.prop2 = "hello";
   *  ...
   *
   * @name vs.core.Object#configure
   * @function
   *
   * @param {Object} config the associated array used for configuring the
   *        object.
   */
  configure : function (config)
  {
    if (typeof (config) !== 'object') { return; }
    var props, key, i, should_propagate = false, desc;

    if (this.__df__) 
      this.__df__.forEach (function (df) {
        df.pausePropagation ();
      });

    // Manage model
    if (config instanceof Model)
    {
      desc = this.getPropertyDescriptor ('model');
      if (desc && desc.set)
      {
        // model property assignation
        this.model = config;
        should_propagate = true;
      }
      else
      {
        // one by one property copy
        props = config.getModelProperties ();
        for (i = 0; i < props.length; i++)
        {
          key = props [i];
          if (key === 'id') { continue; }
          this [key] = config [key];
          should_propagate = true;
        }
      }
    }
    else
    {
      if (config) for (key in config)
      {
        if (key === 'id' || key === 'node' ||
            key === 'node_ref' || key === 'view')
        { continue; }
        this [key] = config [key];
        should_propagate = true;
      }
    }

    if (this.__df__ && this.__df__.length) {
      this.__df__.forEach (function (df) {
        df.restartPropagation ();
        if (should_propagate) {
          df.propagate (this);
        }
      });
    }
    else if (should_propagate && this.propertiesDidChange) {
      this.propertiesDidChange ();
    }
  },
  
  /**
   *  This method is called by the dataflow algorithm when input properties have
   *  been changed.
   *  You should reimplement this method if you want make specific calculation
   *  on properties changed, and/or modifying output properties.
   *  If you have modifying an output property (and want to continue the
   *  dataflow propagation) you have to return 'false' or nothing.
   *  Otherwise return 'true' to and the propagation will terminate.
   *
   * @name vs.core.Object#propertiesDidChange
   * @function
   * @return {boolean} true if you wants stop de propagation, false otherwise
   */
  propertiesDidChange: function () { return false; },

  /**
   *  Returns a copy of the objet's properties for JSON stringification.<p/>
   *  This can be used for persistence or serialization.
   *
   * @name vs.core.Object#toJSON
   * @function
   * @return {Object} the object value for stringify
   */
  toJSON : function ()
  {
    return this._toJSON ();
  },

  /**
   *  Set objet's properties from JSON stringification.<p/>
   *  This can be used when retrieve data from serialization.
   *
   * @name vs.core.Object#parseJSON
   * @function
   * @param {String} json The JSON String
   */
  parseJSON : function (json)
  {
    try {
      this.parseData ((json && util.parseJSON (json)) || {});
    }
    catch (e)
    {
      if (e.stack) console.log (e.stack)
      console.error ("vs.core.Object.parseJSON failed. " + e.toString ());
    }
  },

  /**
   * @protected
   */
  parseData : function (obj)
  {
    var key, value, result;
    for (key in obj)
    {
      value = obj [key];
//         if (util.isString (value))
//         {
//           result = util.__date_reg_exp.exec (value);
//           if (result && result [1]) // JSON Date -> Date generation
//           {
//             this ['_' + key] = new Date (parseInt (result [1]));
//           }
//           else this ['_' + key] = value; // String
//         }
      this ['_' + util.underscore (key)] = value;
    }
  },

  /**
   *  Returns a copy of the objet's properties for JSON stringification.<p/>
   *  This can be used for persistence or serialization.
   * @private
   * @name vs.core.Object#_toJSON
   * @function
   */
  _toJSON : function (json)
  {
    var prop_name, value, data = {}, result,
      _properties_ = this.getModelProperties (), n = 0;

    if (!_properties_) return data;

    for (var i = 0; i < _properties_.length; i++)
    {
      prop_name = _properties_ [i];
      value = this ['_' + util.underscore (prop_name)];
      if (typeof value == "undefined") continue;
      else if (value instanceof Date)
      { result = '"\/Date(' + value.getTime () + ')\/"'; }
      else if (value && value.toJSON) { result = value.toJSON (); }
      else result = value;
      data [prop_name] = result;
    }

    return data;
  },

  /**
   * @protected
   * @function
   */
  destructor : function ()
  {
    // remove the current object
    delete (VSObject._obs [this._id]);
    
    this.__i__ = false;
  },

  /**
   * @public
   * @function
   */
  isDeleted : function ()
  {
    return !this.__i__;
  },

  /**
   * Manually force properties change propagation.
   * <br/>
   * If no property name is specified, the system will assume all component's
   * properties have been modified.
   *
   * @name vs.core.Object#propertyChange
   * @function
   *
   * @param {String} property the name of the modified property.[optional]
   */
  propertyChange : function (property)
  {
    this.__input_property__did__change__ = true, self = this;
    if (this.__df__) 
      this.__df__.forEach (function (df) {
        df.propagate (self);
      });
  },


  /**
   * Manually force out properties change propagation.
   * <br/>
   * If no property name is specified, the system will assume all component's
   * properties have been modified.
   *
   * @name vs.core.Object#outPropertyChange
   * @function
   *
   * @param {String} property the name of the modified property.[optional]
   */
  outPropertyChange : function (property)
  {
    this.__input_property__did__change__ = true, self = this;
    if (this.__df__) 
      this.__df__.forEach (function (df) {
        df.propagate (self, false, true);
      });
  },
  
  /**
   * Manually force properties change propagation.
   * <br/>
   * @deprecated
   * @name vs.core.Object#propagateChange
   * @see vs.core.Object#propertyChange
   * @param {String} property the name of the modified property.[optional]
   * @param {Object} data.[optional]
   */
  propagateChange : function (property)
  {
    this.propertyChange (property);
  },

  /**
   * Connect two components within the datalfow.
   * This method return a Connector that will allow you to declare your
   * dataflow with a simple chaining API.
   *
   * @example
   * /// First example: the slide will rotate the view1 and view2
   * var slider = new vs.ui.Slider ({}).init ();
   * var view1 = new vs.ui.View ({}).init ();
   * var view2 = new vs.ui.View ({}).init ();
   * 
   * slider
   *   .connect ("value") // out property
   *   .to (view1, "rotation"); // in property
   *   .to (view2, "rotation"); // in property
   *
   * /// Seconde example: the slide will rotate the view1 and view2
   * var slider = new vs.ui.Slider ({range: [1, 10]}).init ();
   * var list = new vs.core.Array({data: ["item1", ..., "item10"]}).init ();
   * var label = new vs.ui.TextLabel ({}).init ();
   * 
   * slider
   *   .connect ("value") // out property
   *   .to (list, "index") // in property
   *     .connect ("value") // in property
   *     .to (label, "text"); // in property
   *
   *
   * @name vs.core.Object#connect 
   * @function
   * @public
   * @param {String} property_name the Component out property name to connect
   *                 from
   * @return {Connector} returns the connector object that allow the chainning
   */
  connect : function (property_name) {
    return new Connector (this, property_name);
  },

  /**
   * The method allows to link a model to an other object (a view for
   * instance).<br />
   * This is a simple way to create a MVC architecture; each model
   * modification will be propagated to the view.<br/><br/>
   * Linking is quite different than dataflow.<br/>
   * You can use linking to connect 2 objects with the same properties name.
   * <br/>
   * With dataflow its possible to connect a set of object, and define precisely
   * witch properties are connected together.<br/>
   * <br/>
   * Please notice that dataflow propagation is more optimized than linking
   * propagation.
   *
   * @example
   *  var myModel = new MyModel ().init ();
   *  var myView = new MyView ().init ();
   *
   *  myView.link (myModel);
   *
   *  myModel.prop = "value"; // the myView.prop will be automatically updated.
   *  ...
   *  myModel.stopPropagation ();
   *  myModel.prop = "value";
   *  myModel.propBis = "valueBis";
   *  myModel.change (); // the view is updated
   *
   * @name vs.core.Object#link
   * @function
   * @param {vs.core.Model} model The model to link with
   */
  link : function (model)
  {
    // model update management
    if (model instanceof vs.core.Model)
    {
      if (this.__model) this.__model.unlinkTo (this);
      this.__model = model;
      this.__model.linkTo (this);

      // first configuration
      this.configure (this.__model)
    }
    else throw "vs.core.Object.link; parameter is not a vs.core.Model";
  },

  /**
   * Unlink the model which was linked with this object
   * @see vs.core.Object#link
   *
   * @name vs.core.Object#unlink
   * @function
   */
  unlink : function ()
  {
    // model update management
    if (this.__model)
    {
      if (this.__model)
      {
        this.__model.unlinkTo (this);
        var props = this.__model.getModelProperties (); l = props.length,
          config = {};
        while (l--) { config [props[l]] = null; }
        this.configure (config);
      }
      this.__model = undefined;
    }
  },

  /**
   *  Clone the Object <p>
   *
   * @name vs.core.Object#clone
   * @function
   *
   * @param {Object} config the configuration structure for the new object
   * @return {vs.core.Object} the cloned object
   */
  clone : function (config, cloned_map)
  {
    var obj, key, value, desc, desc_clone, getter, setter;

    if (!cloned_map) { cloned_map = {}; }

    // have already cloned;
    if (cloned_map [this._id]) { return cloned_map [this._id]; }

    if (!config) { config = {}; }
    if (!config.id) { config.id = createId (); }

    if (util.isFunction (this.constructor))
    {
      obj = new this.constructor (config);
    }
    else
    {
      console.warn ("impossible to clone this object.");
      return null
    }

    cloned_map [this._id] = obj;

    function _propertyDecl_api1 (prop_name, src, trg)
    {
      var getter = src.__lookupGetter__ (prop_name),
        setter = src.__lookupSetter__ (prop_name),
        getter_clone = trg.__lookupGetter__ (prop_name),
        setter_clone = trg.__lookupSetter__ (prop_name);

      // manage getter
      if (getter && !getter_clone)
      {
        trg.__defineGetter__ (prop_name, getter);
      }
      // manage setter
      if (setter && !setter_clone)
      {
        trg.__defineSetter__ (prop_name, setter);
      }
      // generic member copy
      if (!setter && !getter)
      {
        var value = src [prop_name];
        if (util.isArray (value)) { trg [prop_name] = value.slice (); }
        else { trg [prop_name] = src [prop_name]; }
      }
      else {
        if (!trg.__properties__) trg.__properties__ = [];
        trg.__properties__.push (prop_name);
      }
    }

    function _propertyDecl_api2 (prop_name, src, trg)
    {
      var desc = src.getOwnPropertyDescriptor (prop_name),
        desc_clone = trg.getOwnPropertyDescriptor (prop_name);

      // manage getter and setter
      if (desc && (desc.get || desc.set))
      {
        // the property description doesn't exist. Create it.
        if (!desc_clone) {
          util.defineProperty (trg, prop_name, desc);
          if (!trg.__properties__) trg.__properties__ = [];
          trg.__properties__.push (prop_name);
        }
      }
      // generic member copy
      else
      {
        var value = src [prop_name];
        if (util.isArray (value)) { trg [prop_name] = value.slice (); }
        else { trg [prop_name] = src [prop_name]; }
      }
    }

    var propertyDecl =
      (Object.defineProperty)?_propertyDecl_api2:_propertyDecl_api1;

    // property and function declaration copy
    for (key in this)
    {
      // do not manage id or private member
      if (key === 'parent' || key === '_id' || key === 'constructor' ||
          key.indexOf ('__') === 0) continue;  
      if (!this.getPropertyDescriptor (key)) continue;

      // function copy
      if (util.isFunction (this [key]) && !util.isFunction (obj [key]))
      { obj [key] = this [key]; }
      
      // property descriptor copy
      else if (!obj.isProperty (key) && this.isProperty (key))
      { propertyDecl (key, this, obj); }
    }

    obj.__i__ = false;
    obj.init ();

    // call object specific clone implementation
    this._clone (obj, cloned_map);

    // property values copy
    this._clone_properties_value (obj, cloned_map);

    // manage linking clone
    if (this.__model)
    {
      if (cloned_map && cloned_map [this.__model._id])
      { obj.link (cloned_map [this.__model._id]); }
      else { obj.link (this.__model); }
    }

    return obj;
  },
  
   /**
   * @name vs.core.Object#_clone_properties_value
   * @function
   * @protected
   *
   * @param {vs.core.Object} obj The cloned object
   * @param {Object} map Map of cloned objects
   */
  _clone_properties_value : function (obj, cloned_map)
  {
    var key;
    
    for (key in this)
    {
      if (key == 'id') continue;

      // property value copy
      if (this.isProperty (key)) { propertyCloneValue (key, this, obj); }
    }
  },

  /**
   * @name vs.core.Object#_clone
   * @function
   * @private
   *
   * @param {vs.core.Object} obj The cloned object
   * @param {Object} map Map of cloned objects
   */
  _clone : function (obj, cloned_map)
  {},

  /*************************************************************
                  Properties introscpection
  *************************************************************/

  /**
   *  Returns the list of object's properties name <p>
   *
   * @name vs.core.Object#getModelProperties
   * @function
   * @return {Array} Array of name of properties
   */
  getModelProperties : function ()
  {
    var result = [];
    if (this.__properties__) result = result.concat (this.__properties__);
    if (this.constructor.__properties__)
      result = result.concat (this.constructor.__properties__)

    return result;
  },

  /**
   *  Returns true if this component has a property with this name
   *
   * @name vs.core.Object#isProperty
   * @function
   * @return {boolean} true or false
   */
  isProperty : function (name)
  {
    if (this.__properties__ && this.__properties__.indexOf (name) !== -1) return true;
    if (this.constructor.__properties__.indexOf (name) !== -1) return true;

    return false;
  },
  
  /**
   * Defines a new property directly on an object
   * @name vs.core.Object#defineProperty
   *
   * @param {String} prop_name The name of the property to be defined
   * @param {Object} descriptor The descriptor for the property being defined
   */
  defineProperty : function (prop_name, descriptor)
  {
    util.defineProperty (this, prop_name, descriptor);
    if (!this.__properties__) this.__properties__ = [];
    if (this.__properties__.indexOf (prop_name) === -1)
    { this.__properties__.push (prop_name); }
  },

  /**
   * Returns a property descriptor for an own property (that is, one directly
   * present on an object, not present by dint of being along an object's
   * prototype chain) of a given object.
   * @name vs.core.Object#getOwnPropertyDescriptor
   *
   * @param {String} prop The name of the property whose description is to
   *   be retrieved
   * @return {Object} The property descriptor or null
   */
  getOwnPropertyDescriptor : function (prop)
  {
    return Object.getOwnPropertyDescriptor (this, prop);
  },

  /**
   * Returns a property descriptor for a property (along the object's
   * prototype chain) of a given object.
   * @name vs.core.Object#getPropertyDescriptor
   *
   * @param {String} prop The name of the property whose description is to
   *   be retrieved
   * @return {Object} The property descriptor or null
   */
  getPropertyDescriptor : function (prop)
  {
    var desc = Object.getOwnPropertyDescriptor (this, prop);
    if (desc) return desc;

    /** @private */
    function _getOwnPropertyDescriptor (obj, prop)
    {
      if (!obj) return null;
      var proto = Object.getPrototypeOf (obj);
      if (!proto) return null;
      var desc = Object.getOwnPropertyDescriptor (proto, prop);
      if (desc) return desc;
      return _getOwnPropertyDescriptor (proto, prop);
    }

    return _getOwnPropertyDescriptor (this, prop);
  },

  /**
   * @private
   */
  _super : function ()
  {
    var superFunc = this._super.caller._super_func_;
    if (superFunc) superFunc.apply (this, arguments);
  },
};

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperty (VSObject, "id", {
  /**
   * Getter for vs.core.Object id
   * @name vs.core.Object#id
   *
   * @type {String}
   */
  get : function () { return this._id; }
});

/**
 * @private
 */
function _cloneValue (value)
{
  if (value && util.isFunction (value.clone)) return value.clone ();
  else return util.clone (value);
}

/**
 * @private
 */
function _propertyCloneValue_api1 (prop_name, src, trg)
{
  var getter = src.__lookupGetter__ (prop_name),
    setter = src.__lookupSetter__ (prop_name),
    setter_clone = trg.__lookupSetter__ (prop_name),
    _prop_name = '_' + util.underscore (prop_name);

  // Property value copy
  if (setter || getter)
  {
    if (setter_clone) { trg [prop_name] = _cloneValue (src [_prop_name]); }
    else { trg [_prop_name] = _cloneValue (src [_prop_name]); }
  }
}

/**
 * @private
 */
function _propertyCloneValue_api2 (prop_name, src, trg)
{
  var desc = src.getPropertyDescriptor (prop_name),
    desc_clone = trg.getPropertyDescriptor (prop_name),
    _prop_name = '_' + util.underscore (prop_name);
  
  // Property value copy
  if (desc && desc_clone && (desc.get || desc.set))
  {
    if (desc_clone.set) { trg [prop_name] = _cloneValue (src [_prop_name]); }
    else { trg [_prop_name] = _cloneValue (src [_prop_name]); }
  }
}

/**
 * @private
 */
var propertyCloneValue =
  (Object.defineProperty)?_propertyCloneValue_api2:_propertyCloneValue_api1;

/********************************************************************
                      Static members
*********************************************************************/
/** @private */
VSObject._obs = {};
VSObject.__propertyCloneValue = propertyCloneValue;

/********************************************************************
                      Export
*********************************************************************/
/** @private */
core.Object = VSObject;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/********************************************************************

*********************************************************************/

var _constructor_ = Object.prototype.constructor;

/**
 * @example
 *  var Class1 = vs.core.createClass ({
 *    properties: {name: vs.core.Object.PROPERTY_IN_OUT},{});
 *
 *  var t = new Class1 ({name: 'Hello'});
 *  t.init ();
 *  console.log (t.name); // > 'Hello'
 *  
 *  var MyView = vs.core.createClass (
 *    parent: vs.ui.View,
 *
 *    constructor : function ()
 *    {
 *      console.log ('MyView constructor');
 *    }  
 *  });
 *  var d = new Dest ({size: [20, 20]}); // > 'MyView constructor'
 *  d.init ();
 *
 * @memberOf vs.core
 * @name createClass
 * @function
 *
 * @public
 */
function createClass (config)
{
  var klass = null, __spec = {}, 
    parent = vs.core.Object, properties = {};

  // Create the class
  klass = function ()
  {
    this.parent = klass.__spec.parent;
    // Call class constructor if it exists
    if (klass.__spec && klass.__spec._constructor)
    {
      klass.__spec._constructor.apply (this, arguments);
    }
    // Otherwise the parent constructor
    else if (klass.__spec && klass.__spec.parent)
    {
      this.parent.apply (this, arguments);
    }

    this.constructor = klass;
  };
  if (config && config.parent)
  {
    parent = config.parent;
    delete (config.parent);
  }
  if (config && config.properties)
  {
    properties = config.properties;
    delete (config.properties);
  }
  
  __spec.parent = parent;
  if (config && config.constructor && config.constructor !== _constructor_)
  {
    __spec._constructor = config.constructor;
    __spec._constructor._super_func_ = parent;
  }
  klass.__spec = __spec;
  
  // set class prototype  
  if (config)
  {
    klass.prototype = config;
    config.constructor = klass;
  }
  if (parent.prototype) util.extendClass (klass, parent);
  
  // declare super methods
  if (config) for (key in config)
  {
    if (!config.hasOwnProperty (key)) continue;
    var func = config [key];
    var superFunc = parent.prototype [key];
    if (!util.isFunction (func) || !util.isFunction (superFunc)) continue;
    
    // new implementation
    func._super_func_ = superFunc;
  }

  // set class properties
  _setProperties (klass, properties);
  
  return klass;
}

/** 
 * @name vs.core.Object.PROPERTY_IN
 * @const
 * @type {number}
 */
vs.core.Object.PROPERTY_IN = 1;

/** 
 * @name vs.core.Object.PROPERTY_OUT
 * @const
 * @type {number}
 */
vs.core.Object.PROPERTY_OUT = 2;

/** 
 * @name vs.core.Object.PROPERTY_IN_OUT
 * @const
 * @type {number}
 */
vs.core.Object.PROPERTY_IN_OUT = 3;

/** 
 * Regular expression used for parsing property export path.
 * @private
 * @const
 * @type {RegExp}
 */
var property_reg = /(\w+[.\w+]*)#(\w+)/;

/**
 * @private
 */
function _setProperties (klass, properties)
{
  var descriptions = {}, export_value, desc, _prop_name;
  for (var prop_name in properties)
  {
    var value = properties [prop_name];
    
    // 1) simple description with In, OUT, IN_OUT export
    if (util.isNumber (value))
    {
      export_value = value; desc = {};
      _prop_name = '_' + util.underscore (prop_name);
      if (export_value & vs.core.Object.PROPERTY_IN)
      {
        desc.set = (function (prop_name, _prop_name)
        {
          return function (v)
          {
            this[_prop_name] = v;
            this.propertyChange (prop_name);
          };
        }(prop_name, _prop_name));
      }
      if (export_value & vs.core.Object.PROPERTY_OUT)
      {
        desc.get = (function (_prop_name)
        {
          return function ()
          {
            return this[_prop_name];
          };
        }(_prop_name));
      }
    }
    
    // 2) export path
    else if (util.isString (value))
    {
      var result = property_reg.exec (value);
      if (!result || result.length != 3)
      {
        throw "Unvalid property path: " + value;
      }
      desc = {};
      desc.set = (function (_path, _prop_name)
      {
        return function (v)
        {
          var base = this, namespaces = _path.split ('.');
          while (base && namespaces.length) {
            base = base [namespaces.shift ()];
          }
          if (base) base [_prop_name] = v;
          this.propertyChange (_prop_name);
        };
      }(result[1], result[2]));

      desc.get = (function (_path, _prop_name)
      {
        return function ()
        {
          var base = this, namespaces = _path.split ('.');
          while (base && namespaces.length) {
            base = base [namespaces.shift ()];
          }
          if (base) return base [_prop_name];
        };
      }(result[1], result[2]));
    }
    
    // 3) Full description
    else if (typeof value == "object")
    {
      desc = value;
    }
    descriptions [prop_name] = desc;
  }
  util.defineClassProperties (klass, descriptions);
}

/********************************************************************
                      Export
*********************************************************************/
/** @private */
core.createClass = createClass;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and
  contributors. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/


/*
 *----------------------------------------------------------------------
 *
 * _DoOneEvent --
 *
 *  Process a single event of some sort.  If there's no work to
 *  do, wait for an event to occur, then process it.
 *
 *
 *----------------------------------------------------------------------
 */

/**
 *  Structure used for managing events
 *  @private
 */
function Handler (_obj, _func) {
  this.obj = _obj;
  if (util.isFunction (_func)) {
    this.func_ptr = _func;
  }
  else if (util.isString (_func)) {
    this.func_name = _func;
  }
}

/**
 * @private
 */
Handler.prototype.destructor = function () {
  delete (this.obj);
  delete (this.func_ptr);
  delete (this.func_name);
};

/**
 *  Structure used for managing task
 *  @private
 */
function TaskHandler (func, args) {
  this.func_ptr = func;
  this.args = args;
}

/**
 * @private
 */
TaskHandler.prototype.run = function () {
  this.func_ptr.apply (undefined);
};

/**
 * @private
 */
TaskHandler.prototype.destructor = function () {
  delete (this.args);
  delete (this.func_ptr);
};

/**
 * @private
 */
var
  // Events queue. This array contains event structure for future propagation.
  // This array is part of the algorithm that secure event propagation, in
  // particular that avoids a event pass a previous one.
  _async_events_queue = [],
  
  // Event reference on the current synchronous event.
  _sync_event = null,
  
  // Actions queue. This array contains all actions (function for the moment)
  // that have to be execute.
  // This queue is used only in case we use our own implementation of 
  // setImmediate.
  _actions_queue  = [],
  // Boolean indicating if we are propagating a event or not.
  // To secure event propagation, in particular to avoid a event pass a previous
  // event, we manage a events queue and block new propagation if a event is
  // in propagation.
  _is_async_events_propagating = false,
  _is_sync_events_propagating = false,
  
  // Boolean indicating if we are running an action or not.
  // This boolean is used only in case we use our own implementation of 
  // setImmediate.
  _is_action_runing = false,
  _is_waiting = false;

/**
 * Put an asynchronous event into the event queue and request the mainloop
 *
 * @private
 */
function queueProcAsyncEvent (event, handler_list) {
  if (!event || !handler_list) return;

  var burst = {
    handler_list : handler_list,
    event : event
  }

  // push the event to dispatch into the queue
  _async_events_queue.push (burst);

  // request for the mainloop
  serviceLoop ();
}

/**
 * Setup a synchronous event and request the mainloop
 *
 * @private
 */
function queueProcSyncEvent (event, handler_list) {
  if (!event || !handler_list) return;

  var burst = {
    handler_list : handler_list,
    event : event
  }

  // push the event to dispatch into the queue
  _sync_event = burst;

  // request for the mainloop
  serviceLoop ();
}

/**
 * doOneEvent will dispatch One event to all observers.
 *
 * @private
 * @param {Object} burst a event burst structure
 * @param {Boolean} isSynchron if its true the callbacks are executed
 *             synchronously, otherwise they are executed within a setImmediate
 */
function doOneEvent (burst, isSynchron) {
  var
    handler_list = burst.handler_list,
    n = handler_list.length,
    i = n, l = n,
    event = burst.event;

  if (isSynchron) _is_sync_events_propagating = true;
  else _is_async_events_propagating = true;
  
  // Test is all observers have been called
  function end_propagation () {
    l--;
    if (l <= 0) {
      if (isSynchron) _is_sync_events_propagating = false;
			else _is_async_events_propagating = false;
		}
  }

  /**
   * doOneHandler will dispatch One event to an observer.
   *
   * @private
   * @param {Handler} handler
   */
  function doOneHandler (handler) {
    if (handler) try {
      if (util.isFunction (handler.func_ptr)) {
        // call function
        handler.func_ptr.call (handler.obj, event);
      }
      else if (util.isString (handler.func_name) &&
               util.isFunction (handler.obj[handler.func_name]))
      {
        // specific notify method
        handler.obj[handler.func_name] (event);
      }
      else if (util.isFunction (handler.obj.notify)) {
        // default notify method
        handler.obj.notify (event);
      }
    }
    catch (e) {
      if (e.stack) console.error (e.stack);
      else console.error (e);
    }
    end_propagation ();
  };

  if (!i) end_propagation (); // should not occur
  
  // For each observers, schedule the handler call (callback execution)
  for (i = 0; i < n; i++) {
    if (isSynchron) doOneHandler (handler_list [i])
  
    else (function (handler) {
        vs.setImmediate (function () { doOneHandler(handler) });
      }) (handler_list [i])
  }
}

/**
 * doOneAsyncEvent will dispatch One event to all observers.
 *
 * @private
 */
function doOneAsyncEvent () {
  if (_is_async_events_propagating || _is_sync_events_propagating) return;
  
  // dequeue the next event burst and do it
  doOneEvent (_async_events_queue.shift ());
}

/**
 * doOneSyncEvent will dispatch the synchronous event to all observers.
 *
 * @private
 */
function doOneSyncEvent () {
  doOneEvent (_sync_event, true);
  _sync_event = null;
}

/**
 * doAction, execute one action. This method is called with our setImmediate
 * implementation.
 *
 * @private
 */
function doAction () {

  if (!_actions_queue.length) return;
  
  var action = _actions_queue.shift ();

  if (action) try {
    _is_action_runing = true;
    action.run ();
  }
  catch (e) {
    if (e.stack) console.error (e.stack);
    else console.error (e);
  }

  vs.util.free (action);
  _is_action_runing = false;

  if (_actions_queue.length) { _delay_do_action (); }
}

/**
 * doAction, execute one action. This method is called with our setImmediate
 * implementation.
 *
 * @private
 */
function installPostMessageImplementation () {

  var MESSAGE_PREFIX = "vs.core.scheduler" + Math.random ();

  function onGlobalMessage (event) {
    if (event.data === MESSAGE_PREFIX) {
      doAction ();
    }
  }
  
  if (window.addEventListener) {
    window.addEventListener ("message", onGlobalMessage, false);
  }

  return function () {
    window.postMessage (MESSAGE_PREFIX, "*");
  };
}

var _delay_do_action = (window.postMessage)?installPostMessageImplementation():
  function () {setTimeout (doAction, 0)};

/**
 * Install our awn setImmediate implementation, if needs
 *
 * @private
 */
var setImmediate = window.setImmediate || function (func) {

  // push the action to execute into the queue
  _actions_queue.push (new TaskHandler (func));

  // doAction
  if (!_is_action_runing) _delay_do_action ();
};

/**
 * This method is used to break-up long running operations and run a callback
 * function immediately after the browser has completed other operations such
 * as events and display updates.
 *
 * @example
 * vs.setImmediate (function () {...});
 *
 * @see vs.scheduleAction
 * @name vs.setImmediate 
 * @param {Function} func The action to run
 */
vs.setImmediate = setImmediate.bind (window);

/**
 * Mainloop core
 *
 * @private
 */
function serviceLoop () {

  if (_sync_event) doOneSyncEvent ();

  if ((_async_events_queue.length === 0 && _actions_queue.length === 0) ||
      _is_waiting) return;

  function loop () {
    _is_waiting = false;
    serviceLoop ();
  }

  if (_is_async_events_propagating || _is_sync_events_propagating) {
    // do the loop
    vs.setImmediate (loop);
    return;
  }

  // dispatch an event to observers
  if (!_is_action_runing && _actions_queue.length) _delay_do_action ();
  if (_async_events_queue.length) doOneAsyncEvent ();
}

/** 
 * Schedule your action on next frame.
 *
 * @example
 * vs.scheduleAction (function () {...}, vs.ON_NEXT_FRAME);
 *
 * @see vs.scheduleAction
 *
 * @name vs.ON_NEXT_FRAME 
 * @type {String}
 * @const
 * @public
 */ 
var ON_NEXT_FRAME = '__on_next_frame__';

/** 
 * Schedule an action to be executed asynchronously.
 * <br />
 * There is three basic scheduling; the action can be executed:
 * <ul>
 *   <li>as soon as possible.
 *   <li>on the next frame
 *   <li>after a delay
 * </ul>
 *
 * 1- As soon as possible<br />
 * The action will be executed as soon as possible in a manner that is
 * typically more efficient and consumes less power than the usual
 * setTimeout(..., 0) pattern.<br />
 * It based on setImmediate if it is available; otherwise it will use postMessage
 * if it is possible and at least setTimeout(..., 0) pattern if previous APIs are
 * not available.
 *<br /><br />
 *
 * 2- On next frame<br />
 * The action will be executed on next frame.<br />It is equivalent to use
 * window.requestAnimationFrame.
 *<br /><br />
 *
 * 2- After a delay<br />
 * The action will be executed after a given delay in millisecond.<br />
 * It is equivalent to use window.setTimeout(..., delay).
 *
 * @example
 * // run asap
 * vs.scheduleAction (function () {...});
 * // run on next frame
 * vs.scheduleAction (function () {...}, vs.ON_NEXT_FRAME);
 * // run after 1s
 * vs.scheduleAction (function () {...}, 1000);
 *
 * @name vs.scheduleAction 
 * @type {String}
 * @function
 * @public
 *
 * @param {Function} func The action to run
 * @param {(Number|String)} delay when run the action [optional]
 */ 
function scheduleAction (func, delay) {
  if (!util.isFunction (func)) return;
  if (delay && util.isNumber (delay)) {
    setTimeout (func, delay);
  }
  else if (delay === ON_NEXT_FRAME) {
    vs.requestAnimationFrame (func);
  }
  else vs.setImmediate (func);
}

/********************************************************************
                      Export
*********************************************************************/
/** @private */
util.extend (vs, {
  scheduleAction: scheduleAction,
  ON_NEXT_FRAME: ON_NEXT_FRAME
});
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @name vs.core.FORCE_EVENT_PROPAGATION_DELAY
 */
core.FORCE_EVENT_PROPAGATION_DELAY = false;

var EVENT_SUPPORT_GESTURE = false;
var hasMSPointer = window.navigator.msPointerEnabled;

/** 
 * Start pointer event (mousedown, touchstart, )
 * @name vs.core.POINTER_START
 * @type {String}
 * @const
 */ 
core.POINTER_START = vs.POINTER_START;

/** 
 * Move pointer event (mousemove, touchmove, )
 * @name vs.core.POINTER_MOVE 
 * @type {String}
 * @const
 */ 
core.POINTER_MOVE = vs.POINTER_MOVE;

/** 
 * End pointer event (mouseup, touchend, )
 * @name vs.core.POINTER_END 
 * @type {String}
 * @const
 */ 
core.POINTER_END = vs.POINTER_END;

/** 
 * Cancel pointer event (mouseup, touchcancel, )
 * @name vs.core.POINTER_CANCEL 
 * @type {String}
 * @const
 */ 
core.POINTER_CANCEL = vs.POINTER_CANCEL;

/** 
 * Start gesture event
 * @name vs.core.GESTURE_START
 * @type {String}
 * @const
 */ 
core.GESTURE_START = vs.GESTURE_START;

/** 
 * Change gesture event
 * @name vs.core.GESTURE_MOVE 
 * @type {String}
 * @const
 */ 
core.GESTURE_CHANGE = vs.GESTURE_CHANGE;

/** 
 * End gesture event
 * @name vs.core.GESTURE_END 
 * @type {String}
 * @const
 */ 
core.GESTURE_END = vs.GESTURE_END;

/**
 *  @class
 *  An vs.core.Event object, or simply an event, contains information about an 
 *  input action such as a button click or a key down. The Event object contains
 *  pertinent information about each event, such as where the cursor was located
 *  or which character was typed.<br>
 *  When an event is catch by an application component, the callback
 *  receives as parameters an instance (or sub instance) of this class.
 *  <p>
 *  It specifies the source of the event (which object has generated the event),
 *  the type of the event and an event data.
 *
 *  @author David Thevenin
 *
 *  @constructor
 *  Main constructor
 *
 *  @memberOf vs.core
 *
 * @param {vs.core.EventSource} src the source of the event [mandatory]
 * @param {string} type the event type [mandatory]
 * @param {Object} data complemetary event data [optional]
*/
var Event = function (src, type, data)
{
  this.src = src;
  this.srcTarget = src;
  this.type = type;
  this.data = data;
}

Event.prototype =
{
  /**
   * The component which produce the event
   * @type {vs.core.EventSource|HTMLElement}
   * @name vs.core.Event#src
   */
  src: null,
  
  /**
   * [Deprecated] The component which produce the event. <br>
   * In case of DOM event, the Event is mapped to the DOM event. Then
   * the developer has access to srcTarget (and many other data).
   * @type {vs.core.EventSource|HTMLElement}
   * @name vs.core.Event#srcTarget
   * @deprecated
   */
  srcTarget : null,
  
  /**
   * The event spec. For instance 'click' for a mouse click event.
   * @type {String}
   * @name vs.core.Event#type
   */
  type: "",
  
  /**
   * The optional data associate to the event.
   * @type {Object|null}
   * @name vs.core.Event#data
   */
  data: null,
  
  /**
   * @protected
   * @function
   */
  destructor : function ()
  {
    delete (this.src);
    delete (this.srcTarget);
    delete (this.type);
    delete (this.data);
  }
};

/********************************************************************
                      Export
*********************************************************************/
/** @private */
core.Event = Event;

/** touch event messages */
core.EVENT_SUPPORT_GESTURE = EVENT_SUPPORT_GESTURE;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and
  contributors. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  @class
 *  vs.core.EventSource is an  class that forms the basis of event and command
 *  processing. All class that handles events must inherit form EventSource.
 *
 *  @extends vs.core.Object
 *  @author David Thevenin
 *
 *  @constructor
 *  Main constructor
 *
 * @name vs.core.EventSource
 *
 * @param {Object} config the configuration structure [mandatory]
 */
function EventSource (config)
{
  this.parent = VSObject;
  this.parent (config);
  this.constructor = core.EventSource;

  this.__bindings__ = {};
  this.__node_binds__ = {};
}

/** @name vs.core.EventSource# */
EventSource.prototype =
{
  /**
   * @protected
   * @function
   */
  __bindings__ : null,

  /**
   * @protected
   * @function
   */
  __node_binds__: null,

  /***************************************************************

  ***************************************************************/

  /**
   * @protected
   * @function
   */
  destructor : function ()
  {
    var spec, handler_list, i, handler, binds;

    function deleteBindings (handler_list)
    {
      if (!handler_list) return;

      var bind, l = handler_list.length;
      while (l--)
      {
        bind = handler_list [l];
        util.free (bind);
      }
    };

    for (var spec in this.__bindings__)
    {
      deleteBindings (this.__bindings__ [spec]);
      delete (this.__bindings__ [spec]);
    }

    delete (this.__bindings__);

    for (spec in this.__node_binds__)
    {
      binds = this.__node_binds__ [spec];
      if (typeof (binds) === "undefined")
      {
        console.warn
          ("vs.core.Object.destructor, no bind <" + spec + " exists.");
        continue;
      }
      for (i = 0; i < binds.length; i++)
      {
        data = binds [i];
        data.n.removeEventListener (event, data.h);
      }
    }
    delete (this.__node_binds__);

    VSObject.prototype.destructor.call (this);
  },

  /**
   * @name vs.core.EventSource#_clone
   * @function
   * @private
   *
   * @param {vs.core.Object} obj The cloned object
   * @param {Object} map Map of cloned objects
   */
  _clone : function (obj, cloned_map)
  {
    VSObject.prototype._clone.call (this, obj, cloned_map);

    obj.__bindings__ = {};
    obj.__node_binds__ = {};
  },

  /**
   *  The event bind method to listen events
   *  <p>
   *  When you want listen an event generated by this object, you can
   *  bind your object (the observer) to this object using 'bind' method.
   *  <p>
   *
   * @name vs.core.EventSource#bind
   * @function
   *
   * @param {string} spec the event specification [mandatory]
   * @param {vs.core.Object} obj the object interested to catch the event [mandatory]
   * @param {string} func the name of a callback. If its not defined
   *        notify method will be called [optional]
   */
  bind : function (spec, obj, func)
  {
    if (!spec || !obj) { return; }

    /** @private */
    var handler = new Handler (obj, func),
      handler_list = this.__bindings__ [spec];
    if (!handler_list)
    {
      handler_list = [];
      this.__bindings__ [spec] = handler_list;
    }
    handler_list.push (handler);

    return handler;
  },

  /**
   *  The event unbind method
   *  <p>
   *  Should be call when you want stop event listening on this object
   *
   * @name vs.core.EventSource#unbind
   * @function
   *
   * @param {string} spec the event specification [mandatory]
   * @param {vs.core.Object} obj the object you want unbind [mandatory]
   * @param {string} func the name of a callback. If its not defined
   *        all binding with <spec, obj> will be removed
   */
  unbind : function (spec, obj, func)
  {
    function unbind (handler_list)
    {
      if (!handler_list) return;

      var handler, i = 0;
      while (i < handler_list.length)
      {
        handler = handler_list [i];
        if (handler.obj === obj)
        {
          if (util.isString (func) || util.isFunction (func) )
          {
            if (handler.func_name === func || handler.func_ptr === func)
            {
              handler_list.remove (i);
              util.free (handler);
            }
            else { i++; }
          }
          else
          {
            handler_list.remove (i);
            util.free (handler);
          }
        }
        else { i++; }
      }
    };

    unbind (this.__bindings__ [spec]);
  },

  /**
   *  Propagate an event
   *  <p>
   *  All Object listening this EventSource will receive this new handled
   *  event.
   *
   * @name vs.core.EventSource#propagate
   * @function
   *
   * @param {String} spec the event specification [mandatory]
   * @param {Object} data an optional data event [optional]
   * @param {vs.core.Object} srcTarget a event source, By default this object
   *        is the event source [mandatory]
   */
  propagate : function (type, data, srcTarget)
  {
    var handler_list = this.__bindings__ [type], event;
    if (!handler_list || handler_list.length === 0)
    {
      if (this.__parent)
      {
        if (!srcTarget) { srcTarget = this; }
        this.__parent.propagate (type, data, srcTarget);
      }
      return;
    }

    event = new Event (this, type, data);
    if (srcTarget) { event.srcTarget = srcTarget; }

    queueProcAsyncEvent (event, handler_list);
  },

  /**
   * if this object receive an event it repropagates it if nobody has
   * overcharged the notify method.
   *
   * @name vs.core.EventSource#notify
   * @function
   *
   * @protected
   */
  notify : function (event)
  {
    this.propagate (event.type, event.data);
  },

  /**
   *  The event bind method to listen events form DOM
   *  <p>
   *  When you want you object listen an event generated by the DOM, you can
   *  bind your object (the observer) to the node using 'nodeBind' method.
   *
   * @name vs.core.EventSource#nodeBind
   * @function
   *
   * @param {Node} node the node to observe [mandatory]
   * @param {string} spec the event specification [mandatory]
   * @param {string|Function} func the name of a callback or the callback
   *      itself. If its not defined notify method will be called [optional]
   */
  nodeBind : function (node, event, func_s, modifiers)
  {
    if (!node) { return; }
    if (!util.isString (event)) { return; }

    var self = this, func = null, handler = null, binds, key;

    if (typeof (func_s) === "undefined") { func_s = 'notify'; }
    else if (util.isString (func_s))
    {
      if (!util.isFunction (this [func_s]))
      {
        console.warn
          ("vs.core.Object.nodeBind, unknown function named: " + func_s);
        return;
      }
    }
    else if (!util.isFunction (func_s))
    {
      console.error ("vs.core.Object.nodeBind, invalid func parameter");
      return;
    }
    else
    {
      func = func_s;
      func_s = func.name;
    }

    if (!modifiers || modifiers === KEYBOARD.ANY_MASK)
    {
      /**
       * @private
       */
      handler = function (event)
      {
        // event.preventDefault ();
        // event.stopPropagation (); // Seems this line of code bug with BB OS

        try
        {
          event.src = event.currentTarget;
          event.data = event;

          if (!func) { func = self [func_s]; }
          func.call (self, event);
        }
        catch (e)
        {
          if (e.stack) console.log (e.stack)
          console.error (e);
        }
      };
    }
    else
    {
      handler = function (event)
      {
        // event.preventDefault ();
        // event.stopPropagation ();

        try
        {
          if (!modifiers &&
            (event.altKey || event.ctrlKey || event.shiftKey || event.metaKey))
          { return; }
          else if (modifiers === KEYBOARD.ALT && !event.altKey)
          { return; }
          else if (modifiers === KEYBOARD.CTRL && !event.ctrlKey)
          { return; }
          else if (modifiers === KEYBOARD.SHIFT && !event.shiftKey)
          { return; }
          else if (modifiers === KEYBOARD.META && !event.metaKey)
          { return; }
          event.src = event.currentTarget;
          event.data = event;

          if (!func) { func = self [func_s]; }
          func.call (self, event);
        }
        catch (e)
        {
          if (e.stack) console.log (e.stack)
          console.error (e);
        }
      };
    }

    // save data for nodeUnbind
    key = event + func_s;
    if (!this.__node_binds__)
    {
      console.error ('nodeBind impossible');
      return;
    }
    binds = this.__node_binds__ [key];
    if (typeof (binds) === "undefined")
    {
      binds = [];
      this.__node_binds__ [key] = binds;
    }
    binds.push ({n: node, h: handler});

    // set the listener
    vs.addPointerListener (node, event, handler, false);
  },

  /**
   *  Unbind a DOM event listening
   *  <p>
   *
   * @name vs.core.EventSource#nodeUnbind
   * @function
   *
   * @param {Node} node the node which is observed [mandatory]
   * @param {string} spec the event specification [mandatory]
   * @param {string} func the name of a callback. If its not defined
   *        notify method will be called [optional]
   */
  nodeUnbind : function (node, event, func_s)
  {
    if (!node) { return; }
    if (!util.isString (event)) { return; }

    var func = null, i, key, binds, data;
    if (typeof (func_s) === "undefined") { func_s = 'notify'; }
    else if (util.isString (func_s))
    {
      if (!util.isFunction (this [func_s]))
      {
        console.warn ("vs.core.Object.nodeUnbind, unknown function named: " + func_s);
        return;
      }
    }
    else if (!util.isFunction (func_s))
    {
      console.error ("vs.core.Object.nodeBind, invalid func parameter");
      return;
    }
    else
    {
      func = func_s;
      func_s = func.name;
    }

    key = event + func_s;
    binds = this.__node_binds__ [key];
    if (typeof (binds) === "undefined")
    {
      console.warn
        ("vs.core.Object.nodeUnbind, no bind <" + event + ',' + func_s + "> exists.");
      return;
    }
    for (i = 0; i < binds.length;)
    {
      data = binds [i];
      if (data.n === node)
      {
        vs.removePointerListener (node, event, data.h, false);
        binds.remove (i);
      }
      else
      {
        i++;
      }
    }

    // TODO WARNING pas bon, si plusieurs objets l'observe !!!
    node._object_ = undefined;
  },
//
//   /**
//    *  Should be documented
//    *
//    * @name vs.core.EventSource#allDocumentBind
//    * @function
//    *
//    */
//   allDocumentBind : function (event, func)
//   {
//     this._allDocumentBind (document, event, func);
//   },
//
//   /**
//    * @private
//    * @function
//    */
//   _allDocumentBind : function (doc, event, func)
//   {
//     if (!doc) { return; }
//
//     // current document event management
//     this.nodeBind (doc, event, func);
//
//     // children document event management
//     var frame, iframes, i;
//     if (doc.frames)
//     {
//       for (i = 0; i < doc.frames.length; i++)
//       {
//         frame = doc.frames [i];
//         this._allDocumentBind (frame.contentDocument, event, func);
//       }
//     }
//     iframes = doc.getElementsByTagName ('iframe');
//     if (iframes)
//     {
//       for (i = 0; i < iframes.length; i++)
//       {
//         frame = iframes.item (i);
//         this._allDocumentBind (frame.contentDocument, event, func);
//       }
//     }
//   },
//
//   /**
//    *  Should be documented
//    *
//    * @name vs.core.EventSource#allDocumentUnbind
//    * @function
//    *
//    */
//   allDocumentUnbind : function (event, func)
//   {
//     this._allDocumentUnbind (document, event, func);
//   },
//
//   /**
//    * @private
//    * @function
//    */
//   _allDocumentUnbind : function (doc, event, func)
//   {
//     if (!doc) { return; }
//
//     // current document event management
//     this.nodeUnbind (doc, event, func);
//
//     // children document event management
//     var frame, iframes, i;
//     if (doc.frames)
//     {
//       for (i = 0; i < doc.frames.length; i++)
//       {
//         frame = doc.frames [i];
//         this._allDocumentUnbind (frame.contentDocument, event, func);
//       }
//     }
//     iframes = doc.getElementsByTagName ('iframe');
//     if (iframes)
//     {
//       for (i = 0; i < iframes.length; i++)
//       {
//         frame = iframes.item (i);
//         this._allDocumentUnbind (frame.contentDocument, event, func);
//       }
//     }
//   }
};
util.extendClass (EventSource, VSObject);

/********************************************************************
                      Export
*********************************************************************/
/** @private */
core.EventSource = EventSource;

/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and
  contributors. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * The vs.core.Model class
 *
 * @extends vs.core.EventSource
 * @class
 * vs.core.Model is a class that defines the basic Model mechanisms to implement
 * a MVC like architecture. If you need to implement a MVC component, you
 * should extend this class.<br/><br/> >>>> THIS CODE IS STILL UNDER BETA AND
 * THE API MAY CHANGE IN THE FUTURE <<< <p>
 * WikiPedia gives this following definition of a model:<br>
 * "The model manages the behavior and data of the application, responds to
 * requests for information about its state (usually from the view), and
 * responds to instructions to change state (usually from the controller)"
 * <p>
 * The Model class exposes 2 kinds of mechanisms you will need:
 * <ul>
 *  <li> Change event binding
 *  <li> Properties change propagation
 * </ul>
 *
 * <p/>
 *
 * <p/>
 * The fallowing example show a TodoModel class with three properties
 * @example
 *  var TodoModel = vs.core.createClass ({
 *
 *   // parent class
 *   parent: vs.core.Model,
 *
 *   // Properties definition
 *   properties : {
 *     content: vs.core.Object.PROPERTY_IN_OUT,
 *     done: vs.core.Object.PROPERTY_IN_OUT,
 *     date: vs.core.Object.PROPERTY_OUT
 *   },
 *
 *   // Initialization
 *   initComponent : function ()
 *   {
 *     this._date = new Date ();
 *     this._done = false;
 *     this._content = "";
 *   }
 * });
 *
 * var myModel = new TodoModel ({content:"Something to do"});
 * myModel.init ();
 *
 * @see vs.core.DataStorage
 * @author David Thevenin
 *
 *  @constructor
 *  Main constructor
 *
 * @name vs.core.Model
 *
 * @param {Object} config the configuration structure
 */
function Model (config)
{
  this.parent = EventSource;
  this.parent (config);
  this.constructor = vs.core.Model;

  this.__links__ = [];
}

Model.prototype = {

  /*****************************************************************
   *
   ****************************************************************/

  /**
   * @protected
   * @type {Array}
   */
   __links__: null,

  /**
   * @protected
   * @type {Boolean}
   */
   __should_propagate_changes__: true,

  /**
   * @protected
   * @type {vs.core.DataStorage}
   */
   _sync_service_: null,

  /*****************************************************************
   *
   ****************************************************************/

  /**
   * The event bind method to listen model changes
   * <p/>
   * When you want listen modificaan event generated by this object, you can
   * bind your object (the observer) to this object using 'bindChange' method.
   * <p/>
   *
   * @name vs.core.Model#bindChange
   * @function
   * @example
   *  // Listen every change of the model
   *  myModel.bindChange ('', this, this.onChange);
   *  // Listen all the 'add' change of the model
   *  myModel.bindChange ('add', this, this.onChange);
   *
   * @param {string} action the event specification [optional]
   * @param {vs.core.Object} obj the object interested to catch the event [mandatory]
   * @param {string} func the name of a callback. If its not defined
   *        notify method will be called [optional]
   */
  bindChange : function (spec, obj, func)
  {
    if (!obj) { return; }

    this.bind ((spec)? 'change:' + spec : 'change', obj, func);
  },

  /**
   *  The event unbind change method
   *  <p>
   *  Should be call when you want stop event listening on this object
   *
   * @name vs.core.Model#unbindChange
   * @function
   *
   * @param {string} spec the event specification [optional]
   * @param {vs.core.Object} obj the object you want unbind [mandatory]
   * @param {string} func the name of a callback. If its not defined
   *        all binding with <spec, obj> will be removed
   */
  unbindChange : function (spec, obj, func)
  {
    this.unbind ((spec)? 'change:' + spec : 'change', obj, func);
  },

  /**
   * Configure the model to do not propagate event change.<br/>
   * In order to aggregate rapid changes to a model, you will deactivate
   * change event propagate.
   * After all change are finish you can manual call model.change () to
   * trigger the event.
   * <p>
   * Calling model.change () will reactivate event propagation.
   *
   * @name vs.core.Model#stopPropagation
   * @function
   */
  stopPropagation : function ()
  {
    this.__should_propagate_changes__ = false;
  },

  /**
   *  When you override a Model, you should call this.hasToPropagateChange ()
   *  before calling this.change ().
   *  <p>
   *  Calling model.change () will reactivate event propagation.
   *
   * @name vs.core.Model#hasToPropagateChange
   * @function
   * @protected
   */
  hasToPropagateChange : function ()
  {
    return this.__should_propagate_changes__;
  },

  /**
   * Manually trigger the "change" event.
   * If you have deactivated propagation using myModel.stopPropagation ()
   * in order to aggregate changes to a model, you will want to call
   * myModel.change () when you're all finished.
   * <p>
   * Calling myModel.change () reactivate automatic change propagation
   *
   * @name vs.core.Model#change
   * @function
   *
   * @param {String} action the event specification [optional]
   */
  change : function (spec, data, doNotManageLinks)
  {
    var list_bind, event, handler;

    this.__should_propagate_changes__ = true;

    spec = (spec)? 'change:' + spec : 'change';
    event = new Event (this, spec, data);

    try
    {
      // 1) manage links propagation
      if (!doNotManageLinks)
      {
        var l = this.__links__.length, obj;
        while (l--) { this.__links__ [l].configure (this); }
      }

      //propagate retrictive bindings
      if (spec !== 'change')
        queueProcSyncEvent (event, this.__bindings__ [spec]);

      //propagate general change
      queueProcSyncEvent (event, this.__bindings__ ['change']);
    }
    catch (e)
    {
      if (e.stack) console.error (e.stack);
      console.error (e);
    }
  },

  /**
   * Removes all elements of this Model.<br/>
   * This is an abstract method, and should be implemented with your own
   * object.
   * @name vs.core.Model#clear
   * @param {Boolean} should_free free content items
   * @function
   */
  clear : function (should_free)
  {
    var
      _properties_ = this.getModelProperties (),
      _prop_name,
      self = this;
    
    _properties_.forEach (function (prop_name) {
      _prop_name = '_' + util.underscore (prop_name);
      
      // free the property
      if (should_free) vs.util.free (self [_prop_name]);
      
      // set the property to null
      self [_prop_name] = undefined;
      
      // remove property if its dynamic
      // deactivate
//       if (self.__properties__ && 
//           self.__properties__.indexOf (prop_name) !== -1) {
//         delete (self [prop_name]);
//       }
    });
  },

  /**
   *  Propagate an event
   *  <p>
   *  All Object listening this EventSource will receive this new handled
   *  event.
   *
   * @name vs.core.EventSource#propagate
   * @function
   *
   * @param {String} spec the event specification [mandatory]
   * @param {Object} data an optional data event [optional]
   * @param {vs.core.Object} srcTarget a event source, By default this object
   *        is the event source [mandatory]
   */
  propagate : function (type, data, srcTarget)
  {
    this.__should_propagate_changes__ = true;

    EventSource.prototype.propagate.call (this, type, data, srcTarget);
  },

  /**
   * @protected
   *
   * @name vs.core.Model#linkTo
   * @function
   *
   * @param {vs.core.Object} linkTo object
   */
  linkTo : function (obj)
  {
    if (obj instanceof vs.core.Object)
    {
      if (this.__links__.indexOf (obj) === -1)
      { this.__links__.push (obj); }
    }
  },

  /**
   * @protected
   *
   * @name vs.core.Model#unlinkTo
   * @function
   *
   * @param {vs.core.Object} linkTo object
   */
  unlinkTo : function (obj)
  {
    if (obj instanceof vs.core.Object)
    {
      this.__links__.remove (obj);
    }
  },

  /**
   * Manually force dataflow properties change propagation.
   * <br/>
   * If no property name is specified, the system will assume all component's
   * input properties have been modified.
   *
   * @name vs.core.Model#propertyChange
   * @function
   *
   * @param {String} property the name of the modified property.[optional]
   */
  propertyChange : function (property)
  {
    if (vs._default_df_) { vs._default_df_.propagate (this, property); }

    if (this.__should_propagate_changes__)
    {
      var l = this.__links__.length, obj;
      if (property) while (l--)
      { this.__links__ [l] [property] = this [property]; }
      else while (l--) { this.__links__ [l].configure (this); }

      this.change (null, null, true);
    }
  },

  /**
   * @protected
   */
  parseData : function (obj)
  {
    var prop_name;
    
    this.stopPropagation ();
    for (prop_name in obj)
    {
      this._parse_property (prop_name, obj [prop_name]);
    }
    this.change ();
  },

  /**
   * @protected
   */
  _parse_property : function (prop_name, value)
  {
    var
      _properties_ = this.getModelProperties (),
      desc, _prop_name = '_' + util.underscore (prop_name), model;

    if ((value && value.data) || util.isArray (value))
    {
      model = new VSArray ({id: value.id}).init ();
      model.parseData (value);
    }
    else model = value;
    
    if (_properties_.indexOf (prop_name) === -1)
    {
      // add propperty
      desc = {};
      _prop_name = '_' + util.underscore (prop_name);
      desc.set = (function (prop_name, _prop_name)
      {
        return function (v)
        {
          this[_prop_name] = v;
          this.propertyChange (prop_name);
        };
      }(prop_name, _prop_name));
      
      desc.get = (function (_prop_name)
      {
        return function ()
        {
          return this[_prop_name];
        };
      }(_prop_name));
      
      this.defineProperty (prop_name, desc);
    }


//         if (util.isString (value))
//         {
//           result = util.__date_reg_exp.exec (value);
//           if (result && result [1]) // JSON Date -> Date generation
//           {
//             this ['_' + key] = new Date (parseInt (result [1]));
//           }
//           else this ['_' + key] = value; // String
//         }
    
    this [_prop_name] = model;
  }
};
util.extendClass (Model, EventSource);

/********************************************************************
                      Export
*********************************************************************/
/** @private */
core.Model = Model;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.core.KEYBOARD Object
 * <p>
 * <p>
 *  List of predefined event spec:<br>
 *  <ul>
 *  <li> vs.core.KEYBOARD.KEY_UP
 *  <li> vs.core.KEYBOARD.ESC
 *  <li> vs.core.KEYBOARD.ENTER
 *  <li> vs.core.KEYBOARD.SPACE
 *  <li> vs.core.KEYBOARD.BACKSPACE
 *  <li> vs.core.KEYBOARD.SHIFT
 *  <li> vs.core.KEYBOARD.CTRL
 *  <li> vs.core.KEYBOARD.ALT
 *  <li> vs.core.KEYBOARD.NUMLOCK
 *  <li> vs.core.KEYBOARD.LEFT_ARROW 
 *  <li> vs.core.KEYBOARD.UP_ARROW 
 *  <li> vs.core.KEYBOARD.RIGHT_ARROW
 *  <li> vs.core.KEYBOARD.DOWN_ARROW 
 *  <li> vs.core.KEYBOARD.A
 *  <li> vs.core.KEYBOARD.S
 *  <li> vs.core.KEYBOARD.Z
 *  <li> vs.core.KEYBOARD.META
 *  <li> vs.core.KEYBOARD.ANY_MASK
 *  <li> vs.core.KEYBOARD.UNDO
 *  <li> vs.core.KEYBOARD.REDO
 *  <li> vs.core.KEYBOARD.SAVE
 * </ul>
 *
 *  @type vs.core.EventSource
 *
 * @name vs.core.KEYBOARD
 *  @const
 */
var KEYBOARD = new EventSource ('__KEYBOARD__');

/**
 * @private
 */
KEYBOARD._handler_set_down = false;

/**
 * @private
 */
KEYBOARD._handler_set_up = false;

/**
 *  The event bind method to listen events
 *  <p>
 *  When you want listen an event generated by this object, you can
 *  bind your object (the observer) to this object using 'bind' method.
 *  <p>
 *  Warning:<br>
 *  If you know the process of your callback can take time or can be blocking
 *  you should set delay to 'true' otherwise you application will be stuck.
 *  But be careful this options add an overlay in the event propagation.
 *  For debug purpose or more secure coding you can force delay to true, for
 *  all bind using global variable vs.core.FORCE_EVENT_PROPAGATION_DELAY.<br/>
 *  You just have set as true (vs.core.FORCE_EVENT_PROPAGATION_DELAY = true)
 *  at beginning of your program.
 *
 * @name vs.core.KEYBOARD.bind
 * 
 * @param {string} spec the event specification [mandatory]
 * @param {vs.core.Object} obj the object interested to catch the event [mandatory]
 * @param {string} func the name of a callback. If its not defined
 *        notify method will be called [optional]
 * @param {boolean} delay if true the callback 'func' will be call within 
 *        an other "simili thread". 
 */
function KEYBOARD_bind (keyCode, obj, func, prevent)
{
  var handler = EventSource.prototype.bind.call (this, keyCode, obj, func),
    self = this;
  if (prevent) { handler.prevent = true; }
  if (keyCode > KEYBOARD.KEY_UP)
  {
    if (!this._handler_set_up)
    {
      document.documentElement.addEventListener
        ("keyup", function (event)
      {
        self.managePrevent (event.keyCode, event);
        self.propagate (event.keyCode + KEYBOARD.KEY_UP, event);
      }, false);
      this._handler_set_up = true;
    }
  }
  else
  {
    if (!this._handler_set_down)
    {
      document.documentElement.addEventListener
        ("keydown", function (event)
      {
        if ((event.ctrlKey || event.metaKey) &&
            !event.shiftKey && event.keyCode === KEYBOARD.Z)
        {
          self.propagate (KEYBOARD.UNDO);
          event.preventDefault ();
        }
        else if ((event.ctrlKey || event.metaKey) &&
                  event.shiftKey && event.keyCode === KEYBOARD.Z)
        {
          self.propagate (KEYBOARD.REDO);
          event.preventDefault ();
        }
        else if ((event.ctrlKey || event.metaKey) && !event.shiftKey && event.keyCode === KEYBOARD.S)
        {
          self.propagate (KEYBOARD.SAVE);
          event.preventDefault ();
        }
        else if ((event.ctrlKey || event.metaKey) && !event.shiftKey && event.keyCode)
        {
          self.managePrevent (KEYBOARD.META + event.keyCode, event);
          self.propagate (KEYBOARD.META + event.keyCode);
          //event.preventDefault ();
        }
        else
        {
          self.managePrevent (event.keyCode, event);
          self.propagate (event.keyCode, event);
        }
      }, false);
      this._handler_set_down = true;
    }
  }
  
  return handler;
};

/**
 *  @private
 */
KEYBOARD.managePrevent = function (type, event)
{
  var list_bind = this.__bindings__ [type], i, handler;
  if (!list_bind) { return; }
  
  for (i = 0; i < list_bind.length; i++)
  {
    handler = list_bind [i];
    if (handler.prevent)
    {
      event.preventDefault ();
      return;
    }
  }
};

KEYBOARD.KEY_UP = 1000; 
KEYBOARD.ESC = 27;
KEYBOARD.ENTER = 13;
KEYBOARD.SPACE = 32;
KEYBOARD.BACKSPACE = 8;
KEYBOARD.SHIFT = 16;
KEYBOARD.CTRL = 17;
KEYBOARD.ALT = 18;
KEYBOARD.NUMLOCK = 144;

KEYBOARD.LEFT_ARROW = 37;
KEYBOARD.UP_ARROW = 38;
KEYBOARD.RIGHT_ARROW = 39;
KEYBOARD.DOWN_ARROW = 40;

KEYBOARD.L = 76;
KEYBOARD.S = 83;
KEYBOARD.Z = 90;


KEYBOARD.META = 2000;
KEYBOARD.ANY_MASK = 3000;

KEYBOARD.UNDO = 256;
KEYBOARD.REDO = 257;
KEYBOARD.SAVE = 258;

/**
 * @private
 */
core.KEYBOARD = KEYBOARD;
core.KEYBOARD.bind = KEYBOARD_bind;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
 OTHER DEALINGS IN THE SOFTWARE.
*/

/**
 *  The Fsm class
 *
 *  @extends vs.core.EventSource
 *  @class
 *  Fsm element defines a deterministic Finite-State-Machine
 *  (aka Finite-State Automaton). A fsn is an automaton such as:
 *  <ul>
 *    <li />there is only one initial state;
 *    <li />there is no transitions conditioned on null input;
 *    <li />there is only one transition for a given input and a given state.
 *  </ul>
 *
 *    A fsm is specified as flollowing :
 *  <ul>
 *    <li />the set Q, is the set of state;
 *    <li />the set I, is the input alphabet, i.e. a set of word that ca be
 *      generate a transition between two states;
 *    <li />the set O, is the ouput alphabet. It containts the set of word
 *      produced when a transition is crossed;
 *    <li />the set E, is the list of transition <QxIxQxO>;
 *    <li />an initial state.
 *  </ul>
 *
 *  When an automaton is rendered (after run), it begins in the initial state.
 *  It changes to new states depending on events that it receives and the
 *  transition function. Whenever the automaton is deactivated (for instance
 *  by being in a deactivated branch of a Rules), it does not react any more
 *  to events. It will resume to its last state and react again to events when
 *  reactivated.<br /><br />
 *
 *  The general manner to control fsm and make it cross a transition is to
 *  associate event to a input lexem. For that use the methods setInput ().
 *  But an automaton can also be manually control by notifying to it a input
 *  lexem. For that, use the method Fsm.fsmNotify (String).<br /><br />
 *
 *  Automatons can have outputs associated to their transitions (aka Mealy
 *  machine) or states (aka Moore machine, not yet implemented). At that time 
 *  the fsm emit event defined by an string (the output lexem) or call an
 *  action associated to the output lexem.
 *  The event can be received by setting a Binding on this fsm.
 *  Otherwise for specifying the action use the setOuput () method.<br />
 *  <br />
 *  Known limitations:
 *  <ul>
 *   <li />only one output lexem can be generated when crossing a transition.
 *  </ul>
 *
 *  Simple example to create a automata:
 *  @example
 *
 *   var my_fsm = new vs.core.Fsm (object);
 *   // States declaration 
 *   my_fsm.addState ("1");
 *   my_fsm.addState ("2");
 *   // Input lexems declaration
 *   my_fsm.addInput ("a");
 *   my_fsm.addInput ("b");
 *   // Ouptut lexems declaration
 *   my_fsm.addOutput ("c");
 *   my_fsm.addOutput ("d");
 *   // transitions declaration
 *   my_fsm.addTransition ("1", "2", "a", "c");
 *   my_fsm.addTransition ("2", "3", "b", "d");
 *   // initial state declaration
 *   my_fsm.setInitialState ("1");
 *   // activate the FSM
 *   my_fsm.activate ();
 * 
 *   // event associations
 *   // "a" will be generated after the button selection
 *   my_fsm.setInput ("a", aButton, 'select');
 *
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.core.Fsm.
 *
 * @name vs.core.Fsm
 *
 * @param {vs.core.Object} owner the Object using this Fsm [mandatory]
 */
var Fsm = function (owner)
{
  this.parent = core.EventSource;
  this.parent (createId ());
  this.constructor = Fsm;
  
  this.owner = owner;

  this._list_of_state = {};   ///< List of fsm state : Q
  this._list_input = new Array ();   ///< List of input lexem (alphabet) : I
  this._list_output = new Array ();  ///< List of output lexem (alphabet) : O

  this._initial_state = "";  ///< initial state name
  this._current_state = "";  ///< current state name

  this._inputs = {};
  this._output_action = {};
}

Fsm.prototype =
{
  /**
   * @protected
   * @function
   */
  destructor : function ()
  {
    delete (this._list_of_state);
    
    this.owner = undefined;
  
    delete (this._list_of_state);
    delete (this._list_input);
    delete (this._list_output);
    delete (this._inputs);
    delete (this._output_action);
    
    core.EventSource.prototype.destructor.call (this);
  },

  /*****************************************************************
  *     Generic function
  ****************************************************************/

  /**
   * @private
   * @function
   * 
   * @param {vs.core.Object} obj The cloned object
   * @param {Object} map Map of cloned objects
   */
  _clone : function (obj, cloned_map)
  {
    EventSource.prototype._clone.call (this, obj, cloned_map);

    obj.owner = obj.__config__.owner;
    obj._current_state = "";
    
    obj._inputs = {};
    obj._output_action = {};
    
    // XXX TODO WARNING il faut refaire in inputs en outputs.
  },
  
  /**
   *  Full facility constructor that takes specification of the fsm as
   *  parameter.
   *  transitions is an array of object {from, to, on, output}
   *
   * @name vs.core.Fsm#initWithData 
   * @function
   *
   * @param {Array} states is an array of state
   * @param {Array} inputs is an array of input
   * @param {Array} outputs is an array of output
   * @param {Array} transitions is an array of object {from, to, on, output}
   */
  initWithData : function (states, inputs, outputs, transitions)
  {
    if (!states || !inputs || !outputs || !transitions) { return; }
    
    for (var i = 0; i < states.length; i++)
    { this.addState (states [i]); }
    
    for (var i = 0; i < inputs.length; i++)
    { this.addInput (inputs [i]); }
    
    for (var i = 0; i < outputs.length; i++)
    { this.addOutput (outputs [i]); }
    
    for (var i = 0; i < transitions.length; i++)
    {
      this.addTransition (transitions [i].from, transitions [i].to,
        transitions [i].on, transitions [i].output);
    }
  },
  
  /**
   *  Full facility constructor that takes state x state matrix of the fsm as
   *  parameter:
   * <ul>
   *   <li />First columm : list of "from" sates \n
   *   <li />First row : list of "to" sates \n
   *   <li />other cell : tuple "i/o" of input and ouput event \n
   * </ul>
   *
   *  If no id is specified, will create a random one.
   *
   *  @example
   *  // fsm is : 1 -a-> 2 -b-> 3 -c-> 1 \n
   *
   *  matrix = [
   *       ["", "1", "2", "3"],
   *       ["1", "", "a/", ""],
   *       ["2", "", "", "b/"],
   *       ["3", "c/", "", ""]
   *  ];
   *
   *  // Specification for input/output of a transition must have the following
   *  // form : "i" | "i/" | "/o" | "i/o"
   *
   *  fsm = new Fsm (object);
   *  fsm.initWithMatrix (matrix);
   *
   * @name vs.core.Fsm#initWithMatrix 
   * @function
   * @param {Array} matrix
   */
  initWithMatrix : function (matrix)
  {
    // add state
    for (var i = 1; i < matrix[0].length; i++)
    { this.addState (matrix[0] [i]); }
    
    // add transition (add input / output)
    for (var i = 1; i < matrix.length; i++)
    {
      var from = matrix[i][0]

      for (var j = 1; j < matrix[0].length; j++)
      {
        var to = matrix[0][j];
        var i_o =  matrix [i][j];
        if (i_o)
        {
          var io_a = i_o.split ('/');
          if (io_a[0]) this.addInput (io_a[0]);
          if (io_a[1]) this.addOutput (io_a[1]);
          
          this.addTransition (from, to, io_a[0], io_a[1]);
        }
      }
    }
  },
  
  /*******************************************
              Managing inputs
  *******************************************/
  
  /**
   *  Add an imput to the fsm
   *  This input will be add to the list of input alphabet.
   *
   * @name vs.core.Fsm#addInput 
   * @function
   *
   * @param {string} input the new word that will be add to the alphabet
   */
  addInput : function (input)
  {
    if (!input || this.existInput (input)) { return; }
    
    this._list_input.push (input);
  },
  
  /**
   *  Return the input alphabet of the fsm
   *
   * @name vs.core.Fsm#getInputs 
   * @function
   *
   * @return {Array} the alphabet as a set of String
   */
  getInputs : function ()
  {
    return this._list_input.slice ();
  },

  /**
   *  Test if a word in inlcude in imput alphabet
   *
   * @name vs.core.Fsm#existInput 
   * @function
   *
   * @param {string} input the input
   * @return true is exists
   */
  existInput : function (input)
  {
    if (!input) { return; }
    
    return (this._list_input.findItem (input) > -1)
  },
    
  /*******************************************
              Managing outputs
  *******************************************/
  /**
   *  Add an ouput to the fsm
   *  This ouput will be add to the list of ouput alphabet.
   *
   * @name vs.core.Fsm#addOutput 
   * @function
   *
   * @param {string} output the new word that will be add to the alphabet
   */
  addOutput : function (output)
  {
    if (!output || this.existOutput (output)) { return; }
    
    this._list_output.push (output);
  },

  /**
   *  Return the ouput alphabet of the fsm
   *
   * @name vs.core.Fsm#getOutputs 
   * @function
   *
   * @return the alphanet as a set of String
   */
  getOutputs : function ()
  {
    return this._list_output.slice ();
  },

  /**
   *  Test if a word in include in ouput alphabet
   *
   * @name vs.core.Fsm#existOutput 
   * @function
   *
   * @param {string} output the output
   * @return true is exists
   */
  existOutput : function (output)
  {
    if (!output) { return; }
    
    return (this._list_output.findItem (output) > -1)
  },
  
  /*******************************************
              Managing States
  *******************************************/
  /**
   *  Add a State to the fsm
   *
   * @name vs.core.Fsm#addState 
   * @function
   *
   * @param {string} name the new state name
   */
  addState : function (name)
  {
    if (!name || this.existState (name)) { return false; }
    
    var state = {};
    state.transitionEvents = {};
    
    this._list_of_state [name] = state;
    return true;
  },

  /**
   *  Remove a State from the fsm
   *
   * @name vs.core.Fsm#removeState 
   * @function
   *
   * @param {string} name the new state name
   */
  removeState : function (name)
  {
    if (!name || !this.existState (name)) { return false; }
        
    delete (this._list_of_state [name]);
    return true;
  },

  /**
   *  Rename a State of the fsm
   *
   * @name vs.core.Fsm#renameState 
   * @function
   *
   * @param {string} old_name the old state name
   * @param {string} new_name the new state name
   */
  renameState : function (old_name, new_name)
  {
    if (!old_name || !this.existState (old_name)) { return false; }
    if (!new_name || this.existState (new_name)) { return false; }
    
    // change state name
    this._list_of_state [new_name] = this._list_of_state [old_name];
    delete (this._list_of_state [old_name]);
    
    // rename initial state if need
    if (this._initial_state === old_name)
    {
      this._initial_state = new_name;
    }
    
    // change all transition to state with the new name
    for (var state_id in this._list_of_state)
    {
      var state = this._list_of_state [state_id];
      if (state === null) { continue; }
      
      for (var input in state.transitionEvents)
      {
        var t = state.transitionEvents [input];
        
        if (t.to === old_name)
        {
          t.to = new_name;
        }
      }
    }
    
    return true;
  },

  /**
   *  Get list of fsm State
   *
   * @name vs.core.Fsm#getListState 
   * @function
   *
   * @return {Array} list of states
   */
  getListState : function ()
  {
    var result = [];
    
    for (var key in this._list_of_state)
    {
      result.push (key);
    }
    return result;
  },

  /**
   *  Test existance of a state
   *
   * @name vs.core.Fsm#existState 
   * @function
   *
   * @param {string} state the state
   * @return true if state exists
   */
  existState : function (state)
  {
    if (!state) { return false; }
    
    if (this._list_of_state [state]) { return true; }
    return false;
  },
    
  /**
   *  Add a new transition from the state "from" to the state "to".
   *  The state from have to be already specified, otherwise, it will
   *  generate a exception.
   *
   * @name vs.core.Fsm#addTransition 
   * @function
   *
   * @param {string} from State from
   * @param {string} to State to
   * @param {string} on input lexem which cause the crossing of transition
   * @param {string} ouput optional ouput lexem that will be produce by the 
   *    crossing
   */
  addTransition : function (from, to, on, output)
  {
    if (!from || !this.existState (from)) { return; }
    if (!to || !this.existState (to)) { return; }
    if (!on || !this.existInput (on)) { return; }

    var transition = {
      on: on,
      to: to,
      output: output
    };
    this._list_of_state [from].transitionEvents [on] = transition;
  },

  /**
   *  Remove a transition from the state "from".
   *
   * @name vs.core.Fsm#removeTransitionFrom 
   * @function
   *
   * @param {string} from State from
   * @param {string} on input lexem which cause the crossing of transition
   */
  removeTransitionFrom : function (from, on)
  {
    if (!from || !this.existState (from)) { return; }
    if (!on || !this.existInput (on)) { return; }

    var state = this._list_of_state [from]
    if (state.transitionEvents [on])
    {
      delete (state.transitionEvents [on]);
    }
  },

  /**
   *  Remove a transition to the state "to".
   *
   * @name vs.core.Fsm#removeTransitionTo 
   * @function
   *
   * @param {string} tp State tp
   * @param {string} on input lexem which cause the crossing of transition
   */
  removeTransitionTo : function (to, on)
  {
    if (!to || !this.existState (to)) { return; }
    if (!on || !this.existInput (on)) { return; }
    
    
    for (var from in this._list_of_state)
    {
      var state = this._list_of_state [from];
      var t = state.transitionEvents [on];
      if (!t || t.to !== to) { continue; }
      
      delete (state.transitionEvents [on]);
    }
  },

  /**
   *  Return the list of transitions to the state set
   *
   * @name vs.core.Fsm#getTransionsToState 
   * @function
   *
   * @param {string} to State to
   * @return {Array} list of transitions
   */
  getTransionsToState : function (to)
  {
    if (!this.existState (to)) { return; }
    
    var result = [];
    
    for (var state_id in this._list_of_state)
    {
      var state = this._list_of_state [state_id];
      if (state === null) { continue; }
      
      for (var input in state.transitionEvents)
      {
        var t = state.transitionEvents [input];
        
        if (t.to !== to) { continue; }
        
        var tt = util.clone (t);
        tt.from = state_id;
        result.push (tt);
      }
    }
    
    return result;
  },

  /**
   *  Return the list of transitions from the state set
   *
   * @name vs.core.Fsm#getTransionsFromState 
   * @function
   *
   * @param {string} from State from
   * @return {Array} list of transitions
   */
  getTransionsFromState : function (from)
  {
    if (!this.existState (from)) { return; }
    
    var result = [];
    
    var state = this._list_of_state [from];
    if (state === null) { return null; }
    
    for (var inputs in state.transitionEvents)
    {
      var t = state.transitionEvents [inputs];
      
      var tt = util.clone (t);
      tt.from = from;
      result.push (tt);
    }
    
    return result;
  },

  /**
   *  Switch two states of the fsm
   *
   *  if states have transitions from or to them,
   *  the function reconfigures the transitions.
   *
   * @name vs.core.Fsm#switchStates 
   * @function
   *
   * @param {string} state_id1 State 
   * @param {string} state_id2 State 
   */
  switchStates : function (state_id1, state_id2)
  {
    if (state_id1 === state_id2) { return; }
   
    if (!this.existState (state_id1) || !this.existState (state_id2))
    { return; }
  
    // 1) get all transitions coming from arriving to state 1 and 2
    // 1.1) get all transitions
    var t_to_state1 = this.getTransionsToState (state_id1);
    var t_from_state1 = this.getTransionsFromState (state_id1);
    var t_to_state2 = this.getTransionsToState (state_id2);
    var t_from_state2 = this.getTransionsFromState (state_id2);
    
    // 1.2) remove doublons in case state_id1 is connected to state_id2
    //   and vise versa.
    for (var i = 0; i < t_to_state1.length;)
    {
      var t = t_to_state1 [i];
      if (t.from === state_id2) { t_to_state1.remove (t); }
      else { i++; }
    }
    for (var i = 0; i < t_from_state1.length;)
    {
      var t = t_from_state1 [i];
      if (t.to === state_id2) { t_from_state1.remove (t); }
      else { i++; }
    }

    // 2) remove all these transitions in order to reconfigure the fsm
    for (var i = 0; i < t_to_state1.length; i ++)
    {
      var t = t_to_state1 [i];
      this.removeTransitionFrom (t.from, t.on);
    }
    for (var i = 0; i < t_from_state1.length; i ++)
    {
      var t = t_from_state1 [i];
      this.removeTransitionFrom (t.from, t.on);
    }
    for (var i = 0; i < t_to_state2.length; i ++)
    {
      var t = t_to_state2 [i];
      this.removeTransitionFrom (t.from, t.on);
    }
    for (var i = 0; i < t_from_state2.length; i ++)
    {
      var t = t_from_state2 [i];
      this.removeTransitionFrom (t.from, t.on);
    }
    
    // 3) reconfigure the fsm
    for (var i = 0; i < t_to_state1.length; i ++)
    {
      var t = t_to_state1 [i];
      
      var from = (t.from === state_id2)?state_id1:t.from;
      this.addTransition (from, state_id2, t.on, t.output);
    }
    for (var i = 0; i < t_from_state1.length; i ++)
    {
      var t = t_from_state1 [i];

      var to = (t.from === state_id2)?state_id1:t.to;
      this.addTransition (state_id2, to, t.on, t.output);
    }
    for (var i = 0; i < t_to_state2.length; i ++)
    {
      var t = t_to_state2 [i];

      var from = (t.from === state_id1)?state_id2:t.from;
      this.addTransition (from, state_id1, t.on, t.output);
    }
    for (var i = 0; i < t_from_state2.length; i ++)
    {
      var t = t_from_state2 [i];

      var to = (t.to === state_id1)?state_id2:t.to;
      this.addTransition (state_id1, to, t.on, t.output);
    }
    
    if (this._initial_state === state_id1)
    { this._initial_state = state_id2; }
    else if (this._initial_state === state_id2)
    { this._initial_state = state_id1; }
  },
  
/*******************************************
            Managing Call
*******************************************/
  /**
   *   Build a event binding to an input lexem.
   *  To control the fsm and make it passes trought a transition, the
   *  programmer is able to directly fsmNotify a entry lexem to the fsm (see the
   *  general fsm documentation), or associate event source and spec to an
   *  input lexem, like event binding. <br /><br />
   *
   *  This method takes as parameter a pointer on the event source and the
   *  specification of the event.
   *
   * @name vs.core.Fsm#setInput 
   * @function
   *
   * @param {string} on input lexem on which is associated the event
   * @param {vs.core.EventSource} src the object source of the event
   * @param {string} spec the name of the event
   */
  setInput : function (on, src, event_spec)
  {
    if (!on || !src || !event_spec) { return; }
    
    if (src.bind)
    {
      src.bind (event_spec, this);
    }
    else if (src.addEventListener)
    {
      this.nodeBind (src, event_spec);
    }
    else { return; }

    var a = this._inputs [src];
    if (!a)
    {
      a = [];
      this._inputs [src] = a;
    }
    a.push ([event_spec, on, src]);
  },


  /**
   *   Associate an action to the generation of an output lexem.
   *  To make able the fsm to control the application, the programmer can
   *  associate an action to the generation of an ouput lexem when the fsm
   *  cross a transition.<br /><br />
   *
   *  This method takes as parameter a pointer on an action object and a
   *  optional user data.
   *
   * @name vs.core.Fsm#setOutput 
   * @function
   *
   * @param {string}output output lexem on which is associated the action
   * @param {function|string} action the function's name a function of the
   *        fsm owner
   */
  setOutput : function (output, action)
  {
    if (!output || !action) { return; }
    
    this._output_action [output] = action;
  },
  
/*******************************************
          Event managing methodes
*******************************************/

  /**
   *  Activate the FSM which start by the initial state.
   *  <p>
   *  Return false if no initial state is specified.
   *
   * @name vs.core.Fsm#activate 
   * @function
   *
   * @return {boolean} is activated
   */
  activate : function ()
  {
    if (!this._initial_state || !this._list_of_state [this._initial_state])
    { return false; }
    
    this.goTo (this._initial_state);
    return true;
  },
  
  /**
   *  Private method use by the fsm to cross a transition.
   *  @note for the moment only one ouput lexem can be generation when
   *  crossing a transition
   *  @private
   *
   * @name vs.core.Fsm#goTo 
   * @function
   *
   * @param {String} id_sate the id of target state.
   * @param {String} output
   * @param {Object} event the event
   * @return {Boolean} is the transition was reached
   */
  goTo : function (state_id, output, event)
  {
    // manage output
    // TODO WARNING
    var state = undefined;
    
    if (!this.existState (state_id))
    { return false; }
    
    // hide old states view
    if (this._current_state)
    {
      state = this._list_of_state [this._current_state];
    }
    
    ///
    this._current_state = state_id;
    
    if (output && this._output_action [output])
    {
      var clb = this._output_action [output];
      if (util.isFunction (clb))
      {
        clb.call (this.owner, event);
      }
      else if (util.isString (clb))
      {
        this.owner [this._output_action [output]] (event);
      }
    }
    
    return true;
  },
  
  /**
   *  Clear the fsm.
   *  All state, event and binding are deleted
   *
   * @name vs.core.Fsm#clear
   * @function
   */
  clear : function ()
  {
    this._list_of_state = {};
    
    delete (this._list_input);
    delete (this._list_output);
    
    this._list_input = new Array ();
    this._list_output = new Array ();
    
    this._initial_state = "";
    
    // remove input event bindings
    for (var key in this._inputs)
    {
      var a = this._inputs [key];
      
      for (var i = 0; i < a.length; i++)
      {
        var src = a [i][2];
        var event_spec = a [i][0];
        if (src.bind)
        {
          src.unbind (event_spec, this)
        }
        else if (src.addEventListener)
        {
          this.nodeUnbind (src, event_spec);
        }
      }
    }
    
    this._current_state = "";
  },
  
  /**
   *  @private
   *
   * @name vs.core.Fsm#notify 
   *
   * @param {Object} event the event
   * @function
   */
  notify : function (event)
  {
    var a = this._inputs [event.src];
    if (!a) { return; }
    
    for (var i = 0; i < a.length; i++)
    {
      var spec = a [i][0], on = a [i][1];
      if (event.type !== spec) continue;
      
      if (!this._list_of_state [this._current_state]) { continue; }
      
      this.fsmNotify (on, event.data);
    }
  },
  
  /**
   *  Returns the state accessible on the given input from the current state.
   *  Returns undefined in no state is accessible.
   *
   * @name vs.core.Fsm#getAccessibleStateOn 
   * @function
   * @public
   *
   * @param {String} on input
   * @return {Object} the state  
   */
  getAccessibleStateOn: function (on) {
    if (!this._list_of_state [this._current_state]) { return; }
    
    var transition =
      this._list_of_state [this._current_state].transitionEvents [on];
      
    if (!transition) { return; }
    
    return this._list_of_state [transition.to];
  },
  
  /**
   *  @public
   *
   * @name vs.core.Fsm#fsmNotify 
   * @function
   *
   * @param {String} on input
   * @return {Object} data associate to the event 
   */
  fsmNotify : function (on, data, instant)
  {
    if (!this._list_of_state [this._current_state]) { return; }
    
    var transition =
      this._list_of_state [this._current_state].transitionEvents [on];
      
    if (!transition) { return false; }
    
    this.goTo (transition.to, transition.output, {on: on, data: data}, instant);
    return true;
  }
};
util.extendClass (Fsm, EventSource);

/*****************************************************************
 *     Properties declaration
 ****************************************************************/

util.defineClassProperty (Fsm, "initialState", {
  /**
   *   Define the initiale state
   *   Generate a exception if the state was not already defined
   *
   *   @name vs.core.Fsm#initialState 
   *   @param {string} state_id the state
   */
  set : function (state_id)
  {
    if (!state_id)
    {
      this._initial_state = undefined;
      return;
    }
    
    if (!this.existState (state_id)) { return; }

    // set initial state and go to it   
    this._initial_state = state_id;
  },
  
  /**
   * @ignore
   */
  get : function ()
  {
    return this._initial_state;
  }
});

/********************************************************************
                      Export
*********************************************************************/
/**
 * @private
 */
core.Fsm = Fsm;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

var edge_id_counter = 1;

/**
 *  The Dataflow class
 *
 *  @class
 *
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.core.DataFlow.
 *
 * @name vs.core.DataFlow
 *
 * @param {vs.core.Object} owner the Object using this Dataflow [mandatory]
 */
function DataFlow (comp) {
  
  // ordered node list Array<Object>
  this.dataflow_node = [];

  // edges from components Object[component.id] => Array[3] <Object, , properties>
  this.dataflow_edges = {};
  this.is_propagating = false;
//  this._node_link = {};
  this.__shouldnt_propagate__ = 0;
  
  this._list_node = [];
  this._edges_from = {};
  
  if (comp && comp.__df__) {
    comp.__df__.push (this);
  }
}

DataFlow.prototype = {
 
  propagate_values : function (obj) {
 
    var data = this.dataflow_edges [obj._id],
      connectors, edges, i = 0, j = 0, l = 0,
      fnc, descriptors,
      edge, obj_next,
      length = 0, length_desc = 0, func = null, params;
    
    if (!data) { return; }

    length = data.length;
    for (i = 0; i < length; i++) {
    
      connectors = data [i]; if (!connectors) { continue; }
      obj_next = connectors [0]; if (!obj_next) { continue; }

      edges = connectors [2];
      if (!edges || !edges.length) { continue; }
      
      for (j = 0; j < edges.length; j++) {
      
        edge = edges [j];
        func = edge [3];
        params = [];
        descriptors = edge [1]; // properties out
        length_desc = descriptors.length;

        // configure parameters
        for (l = 0; l < length_desc; l++) {
          params.push (descriptors [l].call (obj));
        }
        
        if (func) {
          params = func.apply (window, params);
          if (!util.isArray (params)) {
            params = [params];
          }
        }
        
        descriptors = edge [2]; // properties in
        length_desc = descriptors.length;

        if (params.length !== length_desc) {
          console.error ("Dataflow, invalid parameters");
          return;
        }

        // properties value propagation
        for (l = 0; l < length_desc; l++) {
          fnc = descriptors [l];
          fnc.call (obj_next, params [l]);
        }

        obj_next.__input_property__did__change__ = true;
      }
    }
  },
  
  /**
   * Propagates values along the dataflow graph
   *
   * @protected
   *
   * @param {Object} comp, an optional component form witch start the
   *                 propagation
   * @param {Boolean} force force a full propagation, without test
   *                  if properties have changed or not
   * @param {Boolean} output_propagation, do a propagation, starting from
   *         output property instead of input property (default configuration)
   */
  propagate : function (obj, force, output_propagation) {

    // The graph is sorted and save into an array.
    // Propagation consiste of take each object of tree, one by one, following
    // the array order, and propagation value between node, and call
    // propertiesDidChange method.
  
    // 1) the dataflow is propagating values, do nothing.
    if (this.is_propagating || this.__shouldnt_propagate__) { return; }

    this.is_propagating = true;
    
    var i = 0, dataflow_node = this.dataflow_node, l = dataflow_node.length;
    
    // 2) manage the first object from which starting propagation
    if (obj) {
      // find the first node corresponding to the id
      while (i < l && dataflow_node [i] !== obj) { i++; }

      // the node was found. First data propagation
      if (i < l - 1) {
        if (!output_propagation && obj.propertiesDidChange) {
          if (obj.propertiesDidChange ()) {
            // true means output properties were not changed.
            // => stop propagation

            // end of propagation
            this.is_propagating = false;
            return;
          }
        }
        this.propagate_values (obj);
        i++;
      }
      else {
        i = 0;
      }
    }

    // 3) continue the propagation to following nodes
    for (; i < l; i++) {
      obj = dataflow_node [i];
      if (!obj) { continue; }

      if (obj.__input_property__did__change__) {
        obj.__input_property__did__change__ = false;
        if (obj.propertiesDidChange) {
          if (obj.propertiesDidChange ()) {
            // true means output properties were not changed.
            // => stop propagation
            continue;
          }
        }
        this.propagate_values (obj);
      }
    }

    // 4) end of propagation
    this.is_propagating = false;
  },

  /**
   * Connect two components within the datalfow.
   * After a connection, you have to call build method to compile the dataflow.
   * Build can (should) be call when all connection are done (to avoid
   * un-necessary calculation)
   *
   * @name vs.core.DataFlow#connect 
   * @function
   * @public
   * @param {String|Object} obj_src the Component (or Id) source.
   * @param {String|Array} property_out one or an array of output property name(s)
   * @param {String|Object} obj_trg the Component (or Id) target.
   * @param {String|Array} property_in one or an array of input property name(s)
   */
  connect : function (obj_src, property_out, obj_trg, property_in, func) {

    var
      cid_src, cid_trg, properties_out, properties_in,
      data, index, data_l,
      connections, edges,
      edge_id = edge_id_counter++, edge;
  
    if (util.isString (obj_src)){
      cid_src = obj_src;
    }
    else {
      cid_src = obj_src._id;
    }
    
    obj_src = VSObject._obs [cid_src]; if (!obj_src) { return; }
    if (obj_src.__df__.indexOf (this) === -1) {
      obj_src.__df__.push (this);
    }
  
    if (util.isString (obj_trg)) {
      cid_trg = obj_trg;
    }
    else {
      cid_trg = obj_trg._id;
    }
    
    // Properties out management
    if (util.isString (property_out)) {
      properties_out = [property_out];
    }
    else if (!util.isArray (property_out)) {
      console.warn ("DataFlow.connect, error");
      return;
    }
    else {
      properties_out = property_out;
    }
  
    // Properties in management
    if (util.isString (property_in)) {
      properties_in = [property_in];
    }
    else if (!util.isArray (property_in)) {
      console.warn ("DataFlow.connect, error");
      return;
    }
    else {
      properties_in = property_in;
    }
    
    if (!func && properties_in.length !== properties_out.length) {
      console.warn ("DataFlow.connect, error");
      return;
    }
    
    if (this._list_node.indexOf (cid_src) === -1)
      this._list_node.push (cid_src);

    if (this._list_node.indexOf (cid_trg) === -1)
      this._list_node.push (cid_trg);

    data = this._edges_from [cid_src];
    if (!data) {
      data = [];
      this._edges_from [cid_src] = data;
    }
    
    data_l = data.length;
      
    // find a existing connection to the component
    for (index = 0; index < data_l; index++) {
      connections = data [index];
      if (connections[0] === cid_trg) {
        edges = connections [2];
        break;
      }
    }
    // no connection exist, create
    if (!edges) {
      edges = [];
      data.push ([cid_trg, 1, edges]);
    }
    
    edge = [edge_id, properties_out.slice (), properties_in.slice (), func];
    edges.push (edge);
    
    return edge_id;
  },

  /**
   * Remove a dataflow connection
   * After the remove, you have to call build method to compile the dataflow.
   * Build can (should) be call when all remove are done (to avoid
   * un-necessary calculation)
   *
   *  @example
   *  // there is two APIs:
   *  df.unconnect (edge_id);
   *  or
   *  df.unconnect (obj_src, property_out, obj_trg, property_in);
   *
   * @name vs.core.DataFlow#unconnect 
   * @function
   * @public
   * @param {Number|String|Object} edge_id the id of the edge to remove (this id is returned
   *                 by connect method) or obj_src the Component (or Id) source.
   * @param {String|Array} property_out one or an array of output property name(s)
   * @param {String|Object} obj_trg the Component (or Id) target.
   * @param {String|Array} property_in one or an array of input property name(s)
   */
  unconnect : function () {
    
    if (arguments.length === 1) {
      this._unconnect_by_id (arguments [0]);
    }
    else {
      this._unconnect_by_params.apply (this, arguments);  
    }
  },

  /**
   * Remove a dataflow connection using a edge parameters
   *
   * @private
   * @param {String|Object} obj_src the Component (or Id) source.
   * @param {String|Array} property_out one or an array of output property name(s)
   * @param {String|Object} obj_trg the Component (or Id) target.
   * @param {String|Array} property_in one or an array of input property name(s)
   */
  _unconnect_by_params : function (obj_src, property_out, obj_trg, property_in) {
  
    var
      cid_src, cid_trg, properties_out, properties_in,
      data, index, data_l,
      connections, edges,
      edge_id = edge_id_counter++, edge;

    if (util.isString (obj_src)){
      cid_src = obj_src;
    }
    else {
      cid_src = obj_src._id;
    }

    data = this._edges_from [cid_src];
    if (!data) { return; }
    
    obj_src = VSObject._obs [cid_src]; if (!obj_src) { return; }
    if (obj_src.__df__.indexOf (this) === -1) { return; }
  
    if (util.isString (obj_trg)) {
      cid_trg = obj_trg;
    }
    else {
      cid_trg = obj_trg._id;
    }

    // Properties out management
    if (util.isString (property_out)) {
      properties_out = [property_out];
    }
    else if (!util.isArray (property_out)) {
      console.warn ("DataFlow.unconnect, error");
      return;
    }
    else {
      properties_out = property_out;
    }
  
    // Properties in management
    if (util.isString (property_in)) {
      properties_in = [property_in];
    }
    else if (!util.isArray (property_in)) {
      console.warn ("DataFlow.unconnect, error");
      return;
    }
    else {
      properties_in = property_in;
    }
    
    function removeProperties (sources, list) {
      list.forEach (function (data) {
        var index = sources.indexOf (data);
        if (index !== -1) sources.remove (index);
      });
    }
      
    // find a existing connection to the component
    for (index = 0; index < data.length; index++) {
      connections = data [index];
      if (connections[0] === cid_trg) {
        edges = connections [2];
        
        var i = 0, edge;
        for (; i < edges.length;) {
          edge = edges [i];
      
          properties_out_s = edge [1];
          properties_in_s = edge [2];
          
          removeProperties (properties_out_s, properties_out);
          removeProperties (properties_in_s, properties_in);
          
          if (properties_out_s.length === 0 || properties_in.length === 0) {
            edges.remove (i);
          }
          else i++;
        }
        if (edges.length === 0) {
          data.remove (index);
        }
        else index++;
      }
      else index++;
    }
  },

  /**
   * Remove a dataflow connection using a edge ids
   *
   * @private
   * @param {Number} edge_id the id of the edge to remove
   */
  _unconnect_by_id : function (edge_id) {
    
    for (var cid in this._edges_from) {
      var data = this._edges_from [cid];
      if (!data) continue;
      
      var data_l = data.length;
      
      // find a existing connection to the component
      for (var index = 0; index < data_l; index++) {
        var connections = data [index];
        var edges = connections [2];

        var i = 0, edges_l = edges.length, edge;
        for (; i < edges_l; i++) {
          edge = edges [i];
      
          if (edge && edge [0] === edge_id) {
            edges.remove (i);
//             if (edges.length === 0) {
//               // remove connection
//               
//               
//             }
            return;
          }
        }
      }   
    }
  },

  /**
   * Performs a topological sort on this DAG, so that getNodes returns the
   * ordered list of nodes.<p>
   * Returns true if the graph is acyclic, false otherwise. When the graph is
   * cyclic, the algorithm does at it best to partially order it and issues a
   * warning.
   *
   * @private
   * @return {boolean}
   */
  _sort : function () {

    /// This method uses the classical sorting algorithm with cycle-detection.
    /// See, e.g., http://www.cs.umb.edu/cs310/class23.html
    /// It is normally O(|E|) but this probably won't be the case here
    /// until efficiency issues have been solved.
    /// The algorithm has also been modified in order to cyclic graphs to be
    /// partially sorted instead of being not sorted at all.

    /// 1) Calculate in-degrees for nodes
    var
      nb_node = this._list_node.length,
      indegrees = [], i, j, key, ids, index;

    for (i = 0; i < nb_node; i++) {
      indegrees [i] = 0;
    }

    for (key in this._edges_from) {
      /// FIXME: For more efficiency, store indexes into edges to avoid node
      /// search.
      ids = this._edges_from [key];
      for (j = 0; j < ids.length; j++) {
        //find the index of the node in the node list
        index = this._list_node.findItem (ids [j][0]);
        indegrees [index]++;
      }
    }

    /// 2) Initialization
    var
      pending = this._list_node.slice (),
      sorted = [], violationcount = 0;

    /// 3) Loop until everything has been sorted
    while (pending.length !== 0) {
      /// Extract a node of minimal input degree and append it to list topsorted
      var
        min_i = this._array_min (indegrees),
        indegree = indegrees [min_i];
        
      indegrees.remove (min_i);

      var n_id = pending [min_i];
      pending.remove (min_i);
      
      if (indegree > 0) {
        violationcount++;
      }
      sorted.push (n_id);

      /// 4) Decrement indegrees of nodes m adjacent to n
      /// FIXME: For more efficiency, store adjacent nodes to avoid this search.
      /// Use an adjacency matrix implementation ?
      ids = this._edges_from [n_id];
      if (ids) {
        for (j = 0; j < ids.length; j++) {
          var mi =  pending.findItem (ids [j][0]);
          if (mi !== -1) {
            indegrees [mi]--;
          }
        }
      }
    }

    /// 5) Update node list & return result
    this._list_node = sorted;
    this.is_sorted = true;
    this.is_cyclic = violationcount > 0;

    if (violationcount > 0) {
      var edgecount = Object.keys (this._edges_from).length;
      console.warn (
        "WARNING: Cycles detected during topological sort." +
        "%d dependencies out of %d have been violated.\n",
        violationcount, edgecount);
    }
    return !this.is_cyclic;
  },
  
  /**
   * Returns the index of the smallest element into an array
   *
   * @private
   * @param {Array} indegrees the Array
   * @return {integer} the index
   */
  _array_min : function (indegrees) {
    var count = indegrees.length;
    if (count === 0) return -1;
    if (count === 1) return 0;
    var min_index = 0;
    var min = indegrees [min_index];

    for (var i = 1; i < indegrees.length; i++) {
      if (indegrees [i] < min) {
        min = indegrees [i];
        min_index = i;
      }
    }
    return min_index;
  },

  /**
   * @public
   * @name vs.core.DataFlow#build 
   * @function
   */
  build : function () {
    this._sort ();

    this._data_optimize (this._edges_from, this._list_node);
  },
  
  /**
   * @private
   */
  pausePropagation : function () {
    this.__shouldnt_propagate__ ++;
  },

  /**
   * @private
   */
  restartPropagation : function () {
    this.__shouldnt_propagate__ --;
    if (this.__shouldnt_propagate__ < 0) this.__shouldnt_propagate__ = 0;
  },

  /**
   * @private
   */
  _data_optimize : function (_ref_edges, _ref_node) {
    if (!_ref_node || !_ref_edges) { return; }
  
    var temp = [], i, j, k,
      data, data_temp,
      connections, connections_temp,
      edges, edges_temp,
      edge, edge_temp,
      cid_src, cid_trg, obj_src, obj_trg,
      property_name, descriptor, properties, properties_temp;
    
    for (i = 0; i < _ref_node.length; i++) {
      cid_src = _ref_node [i];    
      obj_src = VSObject._obs [cid_src]; if (!obj_src) { continue; }
    
      temp.push (obj_src);
    }
    this.dataflow_node = temp;
  
    temp = {};
    for (cid_src in _ref_edges) {
      obj_src = VSObject._obs [cid_src]; if (!obj_src) { continue; }

      data = _ref_edges [cid_src];
      data_temp = [];
      temp [cid_src] = data_temp;
    
      if (data) for (i = 0; i < data.length; i++) {
        connections = data [i];
        connections_temp = [3];
        
        data_temp.push (connections_temp);
        cid_trg = connections [0];
        obj_trg = VSObject._obs [cid_trg];  if (!obj_trg) { continue; }
      
        connections_temp [0] = obj_trg;
        connections_temp [1] = connections [1];
      
        edges = connections [2];
        edges_temp = [];
        connections_temp [2] = edges_temp;
      
        for (j = 0; j < edges.length; j++) {
          edge = edges [j];
          edge_temp = [4];
          edges_temp.push (edge_temp);

          edge_temp [0] = edge [0]; // id copy
          if (util.isFunction (edge [3])) {
            // function copy
            edge_temp [3] = edge [3];
          }
        
          // manage out properties
          properties = edge [1], properties_temp = [];
          for (k = 0; k < properties.length; k++) {
            property_name = properties [k];
            descriptor = obj_src.getPropertyDescriptor (property_name);
            if (!descriptor) { continue; }
            if (descriptor.get) properties_temp.push (descriptor.get);
            else {
              properties_temp.push ((function (_prop_name) {
                return function () { return this[_prop_name]; };
              }('_' + util.underscore (property_name))));
            }
          }
          edge_temp [1] = properties_temp;
      
          // manage in properties
          properties = edge [2], properties_temp = [];
          for (k = 0; k < properties.length; k++) {
            property_name = properties [k];
            descriptor = obj_trg.getPropertyDescriptor (property_name);
            if (!descriptor) { continue; }
            if (descriptor.set) {
              properties_temp.push (descriptor.set);
            }
            else {
              properties_temp.push ((function (_prop_name) {
                return function (v) { this[_prop_name] = v; };
              }('_' + util.underscore (property_name))));
            }
          }
          edge_temp [2] = properties_temp;
        }
      }
    }
    this.dataflow_edges = temp;
  }
};

/********************************************************************
                      Export
*********************************************************************/
core.DataFlow = DataFlow;
vs._default_df_ = new DataFlow ();

/**
  Copyright (C) 2009-2013. David Thevenin, ViniSketch (c), ICEL Co. Ltd, and
  contributors. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  @class
 *  vs.core.Connector is Dataflow Connector. Show not be instanced. 
 *  An Connector Object is returned by the connect method call.
 *
 * @author David Thevenin
 *
 * @constructor
 * @name vs.core.Connector
 * @public
 * @param {vs.core.Object} object the Component the connector will connected
 *        from
 * @param {String} property_name the Component out property name to connect
 *        from
 */
var Connector = function (object, property_name) {
  this._base_object = object;
  this._previous_object = undefined;
  this.property_out = property_name;
}

/**
 * @name vs.core.Connector#connect 
 * @function
 * @public
 * @param {vs.core.Object} object the Component the connector will connected
 *        to
 * @param {String} property_name the Component in property name to connect
 *        to
 */
Connector.prototype.to = function (object, property_name, func) {
  vs._default_df_.connect (this._base_object, this.property_out, object, property_name, func);
  this._previous_object = object;
  
  return this;
}

/**
 * @name vs.core.Connector#connect 
 * @function
 * @public
 * @param {String} property_name the Component out property name to connect
 *        from
 */
Connector.prototype.connect = function (property_name) {
  var object = this._previous_object || this._base_object;
  
  return new Connector (object, property_name);
}/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and
  contributors. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/


// function Scheduler ()
// {
//   this.parent = core.EventSource;
//   this.parent (createId ());
//   this.constructor = vs.core.Scheduler;
// };
//
// Scheduler.prototype = {
//
// };
//util.extendClass (Scheduler, EventSource);
//

/**
 *  The vs.core.Task class
 *
 *  <p>
 *
 * Delegates:
 *  <ul>
 *    <li/>taskDidStop : function (vs.core.Task)
 *    <li/>taskDidPause : function (vs.core.Task)
 *    <li/>taskDidEnd : function (vs.core.Task)
 *  </ul>
 *
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.core.Task .
 *
 * @name vs.core.Task
 *
 * @param {Object} config the configuration structure
*/
function Task (conf)
{
  this.parent = core.Object;
  this.parent (conf);
  this.constructor = Task;
};

/**
 * The task is started
 * @const
 * @name vs.core.Task.STARTED
 */
Task.STARTED = 1;

/**
 * The task is stopped
 * @const
 * @name vs.core.Task.STOPPED
 */
Task.STOPPED = 0;

/**
 * The task is paused
 * @const
 * @name vs.core.Task.PAUSED
 */
Task.PAUSED = 2;

Task.prototype = {

/********************************************************************

********************************************************************/

  /**
   * TaskDelegate.
   * Methods are called when state changes (stop | pause)
   *
   *  <p>
   *  @example
   *  var delegate = {};
   *  delegate.taskDidEnd = function () { ... }
   *
   *  // Declare a PAR task including a SEC Task
   *  var task = new Task (...)
   *  task.delegate = delegate;
   *  task.start ();
   *
   * @name vs.core.Task#delegate
   *
   * @property {object}
   */
  delegate : null,

/********************************************************************
                  States
********************************************************************/
  /**
   *	@private
   */
  _state : Task.STOPPED,

/********************************************************************

********************************************************************/

  /**
   *  Default task destructor
   *
   * @name vs.core.Task#destructor
   * @function
   */
  destructor: function ()
  {
    this.stop ();
    core.Object.prototype.destructor.call (this);
  },
  
  /**
   * @name vs.core.Task#_clone
   * @function
   * @private
   *
   * @param {vs.core.Object} obj The cloned object
   * @param {Object} map Map of cloned objects
   */
  _clone : function (obj, cloned_map)
  {
    core.Object.prototype.destructor._clone.call (this, obj, cloned_map);
    
    obj._state = this._state;
  },
  
  /**
   *  Starts the task
   *
   * @name vs.core.Task#start
   * @function
   *
   * @param {any} param any parameter (scalar, Array, Object)
   */
  start: function (param) {},

  /**
   *  Stops the task.<br />
   *  When the task is stopped, it calls the TaskDelegate.taskDidStop
   *  if it declared.
   *
   * @name vs.core.Task#stop
   * @function
   */
  stop: function () {},

  /**
   *  Pause the task.<br />
   *  When the task is paused, it calls the TaskDelegate.taskDidPause
   *  if it declared.
   *
   * @name vs.core.Task#pause
   * @function
   */
  pause: function () {}
};
util.extendClass (Task, core.Object);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperty (Task, "state", {

  /**
   *  Return the task State. <br />
   *  Possible values: {@link vs.core.Task.STARTED},
   *  {@link vs.core.Task.STOPPED},
   *  {@link vs.core.Task.PAUSED}
   *
   * @name vs.core.Task#state
   *  @type {number}
   */
  get : function ()
  {
    return this._state;
  }
});

/**
 *  The vs.core.Task_PAR class
 *
 *  @extends vs.core.Task
 *
 *  @class
 *  Implements {@link vs.core.Task}.
 *  <p>
 *  The Task_PAR class provides a parallel group of tasks.<br />
 *  Task_PAR is a vs.core.Task that starts all its tasks when it is started itself.
 *  <br />
 *  The Task_SEQ ended when longest lasting task has ended.
 *
 *  <p>
 * The delegate has to implement:
 *  <ul>
 *    <li/>taskDidStop : function (vs.core.Task)
 *    <li/>taskDidPause : function (vs.core.Task)
 *    <li/>taskDidEnd : function (vs.core.Task)
 *  </ul>
 *
 *  Methods borrowed from class {@link vs.core.Task}:<br />
 *  &nbsp;&nbsp;&nbsp;&nbsp;{@link vs.core.Task#pause}, {@link vs.core.Task#start},
 *  {@link vs.core.Task#stop}
 *
 *  <p>
 *  @example
 *  // Declare two tasks (animations)
 *  var rotate = new vs.fx.RotateXYZAnimation (30, 50, 100);
 *  rotate.durations = '3s';
 *  var scale = new vs.fx.ScaleAnimation (2,0.5);
 *  scale.durations = '2s';
 *
 *  // Declare the Task_PAR
 *  var par = Task_PAR ([rotate, comp1], [scale, comp2]);
 *
 *  // Start the task => start animations
 *  par.start ();
 *
 *  // Declare a PAR task including a SEC Task
 *  var seq = new Task_SEQ
 *    ([scale, comp0], new Task_PAR ([rotate, comp1], [rotate, comp2]));
 *  seq.delegate = this;
 *  seq.start ();
 *
 *  @author David Thevenin
 *
 *  @borrows vs.core.Task#start as Task_PAR#start
 *
 *  @constructor
 *   Creates a new vs.core.Task.
 *
 * @name vs.core.Task_PAR
 *
 * @param list List of task to start parallel with an optional
 *  parameter
*/
function Task_PAR (tasksAndParams)
{
  this.parent = core.Task;
  this.parent ();
  this.constructor = Task_PAR;

  this._tasksAndParams = [];
  this._state = Task.STOPPED;

  if (arguments.length) this.setTasks (arguments);
};

/**
 *  Methods that create a PAR group
 *
 *  <p>
 *  @example
 *
 *  // Declare the Task_PAR
 *  var group = vs.par ([rotate, comp1], [scale, comp2]);
 *
 *  // Start the task => start animations
 *  group.start ();
 *
 * @param list List of task to start parallel with an optional
 *  parameter
 */
vs.par = function ()
{
  if (arguments.length === 0) return;

  var task = new Task_PAR ();
  task.setTasks (arguments);

  return task;
};

Task_PAR.prototype = {

/********************************************************************

********************************************************************/
  /**
   *	@private
  */
  _tasksAndParams : null,

  /**
   * taks ended
   *	@private
  */
  _tasksWillEnded : null,

/********************************************************************

********************************************************************/

  /**
   *  Set tasks.
   *  The task has to be stopped
   *
   * @name vs.core.Task_PAR#setTasks
   * @function
   *
   * @param list List of task to start parallel with an optional
   *  parameter
   */
  setTasks : function (tasksAndParams)
  {
    if (this._state !== Task.STOPPED) { return false; }
    var i, taskAndparam, task, param;

    this._tasksAndParams = [];
    for (i = 0; i < tasksAndParams.length; i ++)
    {
      taskAndparam = tasksAndParams [i];
      if (!taskAndparam) { continue; }

      param = null; task = null;

      if (util.isArray (taskAndparam))
      {
        if (taskAndparam.length === 1)
        {
          task = taskAndparam [0];
        }
        else if (taskAndparam.length === 2)
        {
          task = taskAndparam [0];
          param = taskAndparam [1];
        }
      }
      else
      {
        task = taskAndparam;
        param = null;
      }

      if (!task)
      {
        console.warn ('Undefined task');
        continue;
      }

      if (!task.start || !task.stop || !task.pause)
      {
        console.warn ('Invalid task: ' + task.toString ());
        continue;
      }

      this._tasksAndParams.push ([task, param]);
    }
  },

  /**
   *  Starts the task
   *
   * @name vs.core.Task_PAR#start
   * @function
   * @ignore
   * @param {any} param any parameter (scalar, Array, Object)
   */
  start: function (param)
  {
    if (this._state === Task.STARTED) { return false; }
    this._tasksWillEnded = this._tasksAndParams.length;
    this._state = Task.STARTED;

    var taskAndparam, i;
    for (i = 0; i < this._tasksAndParams.length; i ++)
    {
      taskAndparam = this._tasksAndParams [i];

      taskAndparam [0].delegate = this;
      taskAndparam [0].start ((taskAndparam [1])?taskAndparam [1]:param);
    }

    return true;
  },

  /**
   *  Stops the task.<br />
   *  When the task is stopped, it calls the taskDidStop if it exits.
   * @function
   * @ignore
   */
  stop: function ()
  {
    if (this._state === Task.STOPPED) { return false; }
    this._state = Task.STOPPED;

    var taskAndparam, i;
    for (i = 0; i < this._tasksAndParams.length; i ++)
    {
      taskAndparam = this._tasksAndParams [i];
      taskAndparam [0].stop ();
    }

    return true;
  },

  /**
   *  Pause the task.<br />
   *  When the task is paused, it calls the taskDidPause if it exits.
   *  @ignore
   * @function
   */
  pause: function ()
  {
    if (this._state === Task.PAUSED) { return false; }
    this._state = Task.PAUSED;

    var taskAndparam, i;
    for (i = 0; i < this._tasksAndParams.length; i ++)
    {
      taskAndparam = this._tasksAndParams [i];
      taskAndparam [0].pause ();
    }

    return true;
  },

/********************************************************************
               delegate methodes
********************************************************************/

  /**
   * @protected
   * @function
   */
  taskDidStop : function (task)
  {
    this._state = Task.STOPPED;

    this._tasksWillEnded --;
    if (this._tasksWillEnded === 0)
    {
      if (this.delegate && this.delegate.taskDidStop) {
        try {
          this.delegate.taskDidStop (this); 
        }
        catch (e) {
          if (e.stack) console.log (e.stack)
          console.error (e);
        }
      }
    }
  },

  /**
   * @protected
   * @function
   */
  taskDidPause : function (task)
  {
    this._state = Task.STOPPED;

    this._tasksWillEnded --;
    if (this._tasksWillEnded === 0)
    {
      if (this.delegate && this.delegate.taskDidPause) {
        try {
          this.delegate.taskDidPause (this);
        }
        catch (e) {
          if (e.stack) console.log (e.stack)
          console.error (e);
        }
      }
    }
  },

  /**
   * @protected
   * @function
   */
  taskDidEnd : function (task)
  {
    this._state = Task.STOPPED;

    this._tasksWillEnded --;
    if (this._tasksWillEnded === 0)
    {
      if (this.delegate && this.delegate.taskDidEnd) {
        try {
          this.delegate.taskDidEnd (this); 
        }
        catch (e) {
          if (e.stack) console.log (e.stack)
          console.error (e);
        }
      }
    }
  }
};
util.extendClass (Task_PAR, Task);

/**
 *  The Task_SEQ class
 *
 *  @extends vs.core.Task
 *
 *  @class
 *  Implements {@link vs.core.Task}.
 *  <p>
 *  The Task_SEQ class provides a sequential group of tasks.<br />
 *  Task_SEQ is a vs.core.Task that runs its tasks in sequence, i.e., it starts
 *  one task after another has ended. <br />
 *  The tasks are started in the order they are defined within the constructor.
 *  <br />
 *  The Task_SEQ finishes when its last tasks has ended.
 *
 *  <p>
 *
 * The delegate has to implement:
 *  <ul>
 *    <li/>taskDidStop : function (vs.core.Task)
 *    <li/>taskDidPause : function (vs.core.Task)
 *    <li/>taskDidEnd : function (vs.core.Task)
 *  </ul>
 *
 *  Methods borrowed from class {@link vs.core.Task}:<br />
 *  &nbsp;&nbsp;&nbsp;&nbsp;{@link vs.core.Task#pause}, {@link vs.core.Task#start},
 *  {@link vs.core.Task#stop}
 *
 *  @example
 *  // Declare two tasks (animations)
 *  var rotate = new vs.fx.RotateXYZAnimation (30, 50, 100);
 *  rotate.durations = '3s';
 *  var scale = new vs.fx.ScaleAnimation (2,0.5);
 *  scale.durations = '2s';
 *
 *  // Declare the Task_SEQ
 *  var seq = Task_SEQ ([rotate, comp1], [scale, comp2]);
 *
 *  // Start the task => start animations sequentially
 *  seq.start ();
 *
 *  // Declare a PAR task including a SEC Task
 *  var seq = new Task_SEQ
 *    ([scale, comp0], new Task_PAR ([rotate, comp1], [rotate, comp2]));
 *  seq.delegate = this;
 *  seq.start ();
 *
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.core.Task_SEQ.
 *
 * @name vs.core.Task_SEQ
 *
 * @param list List of task to start sequentially with an optional
 *  parameter
 */
function Task_SEQ (tasksAndParams)
{
  this.parent = core.Task;
  this.parent ();
  this.constructor = Task_SEQ;

  this._tasksAndParams = [];
  this._state = Task.STOPPED;

  if (arguments.length) this.setTasks (arguments);
};

/**
 *  Methods that create a SEQ group
 *
 *  <p>
 *  @example
 *
 *  // Declare the Task_PAR
 *  var group = vs.seq ([scale, comp0], [rotate, comp0]);
 *
 *  // Start the task => start animations
 *  group.start ();
 *
 * @param list List of task to start sequentially with an optional
 *  parameter
 */
vs.seq = function ()
{
  if (arguments.length === 0) return;

  var task = new Task_SEQ ();
  task.setTasks (arguments);

  return task;
};

Task_SEQ.prototype = {

/********************************************************************

********************************************************************/
  /**
   *	@private
  */
  _tasksAndParams : null,

  /**
   *	@private
  */
  _nextTaskToStart : 0,

  /**
   *	@private
  */
  _startParam : null,

/********************************************************************

********************************************************************/

  /**
   *  Set tasks.
   *  The task has to be stopped
   *
   * @name vs.core.Task_SEQ#setTasks
   * @function
   *
   * @param list List of task to start parallel with an optional
   *  parameter
   */
  setTasks : function (tasksAndParams)
  {
    if (this._state !== Task.STOPPED) { return false; }
    var i, taskAndparam, task, param;

    this._tasksAndParams = [];
    for (i = 0; i < tasksAndParams.length; i ++)
    {
      taskAndparam = tasksAndParams [i];
      if (!taskAndparam) { continue; }

      param = null; task = null;

      if (util.isArray (taskAndparam))
      {
        if (taskAndparam.length === 1)
        {
          task = taskAndparam [0];
        }
        else if (taskAndparam.length === 2)
        {
          task = taskAndparam [0];
          param = taskAndparam [1];
        }
      }
      else
      {
        task = taskAndparam;
        param = null;
      }

      if (!task)
      {
        console.warn ('Undefined task');
        continue;
      }

      if (!task.start || !task.stop || !task.pause)
      {
        console.warn ('Invalid task: ' + task.toString ());
        continue;
      }

      this._tasksAndParams.push ([task, param]);
    }
  },

  /**
   *  Starts the task
   *
   * @param {any} param any parameter (scalar, Array, Object)
   * @ignore
   * @function
   */
  start: function (param)
  {
    if (this._state === Task.STARTED) { return false; }
    
    var taskAndparam = this._tasksAndParams [this._nextTaskToStart];
    this._nextTaskToStart++;
    
    if (!taskAndparam) {
      this._nextTaskToStart = 0;
      this._state = Task.STOPED;
      return false;
    }

    this._state = Task.STARTED;
    this._startParam = param;
    
    taskAndparam [0].delegate = this;
    taskAndparam [0].start ((taskAndparam [1])?taskAndparam [1]:param);

    return true;
  },

  /**
   *  Stops the task.<br />
   *  When the task is stopped, it calls the taskDidStop if it exits.
   * @ignore
   * @function
   */
  stop: function ()
  {
    if (this._state === Task.STOPPED) { return false; }
    this._state = Task.STOPPED;

    var taskAndparam = this._tasksAndParams [this._nextTaskToStart - 1];
    this._nextTaskToStart = 0;

    if (!taskAndparam) { return false; }

    taskAndparam [0].stop ();

    return true;
  },

  /**
   *  Pause the task.<br />
   *  When the task is paused, it calls
   *  the TaskDelegate.taskDidPause if it exits.
   * @ignore
   * @function
   */
  pause: function ()
  {
    if (this._state === Task.PAUSED) { return false; }
    this._state = Task.PAUSED;

    var taskAndparam = this._tasksAndParams [this._nextTaskToStart - 1];
    if (!taskAndparam) { return false; }

    taskAndparam [0].pause ();

    return true;
  },

/********************************************************************
               delegate methodes
********************************************************************/

  /**
   * @protected
   * @function
   */
  taskDidStop : function (task)
  {
    this._state = Task.STOPPED;

    this._nextTaskToStart = 0;

    if (this.delegate && this.delegate.taskDidStop) {
      try {
        this.delegate.taskDidStop (this); 
      }
      catch (e) {
        if (e.stack) console.log (e.stack)
        console.error (e);
      }
    }
  },

  /**
   * @protected
   * @function
   */
  taskDidPause : function (task)
  {
    this._state = Task.PAUSED;

    this._nextTaskToStart = this._nextTaskToStart - 1;

    if (this.delegate && this.delegate.taskDidPause) {
      try {
        this.delegate.taskDidPause (this);
      }
      catch (e) {
        if (e.stack) console.log (e.stack)
        console.error (e);
      }
    }
  },

  /**
   * @protected
   * @function
   */
  taskDidEnd : function (task)
  {
    this._state = Task.STOPPED;

    if (this._nextTaskToStart < this._tasksAndParams.length)
    {
      // start the next task
      this.start (this._startParam);
    }
    else
    {
      this._nextTaskToStart = 0;
      if (this.delegate && this.delegate.taskDidEnd) {
        try {
          this.delegate.taskDidEnd (this); 
        }
        catch (e) {
          if (e.stack) console.log (e.stack)
          console.error (e);
        }
      }
    }
  }
};
util.extendClass (Task_SEQ, Task);

/**
 *  The vs.core.TaskWait class
 *
 *  @extends vs.core.Task
 *
 *  @class
 *  Implements {@link vs.core.Task}.
 *  <p>
 *  The vs.core.TaskWait class provides ...
 *
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.core.TaskWait.
 *
 * @name vs.core.TaskWait
 *
 * @param time The time to wait, using millisecond
 *  parameter
 */
function TaskWait (time)
{
  this.parent = core.Task;
  this.parent ();
  this.constructor = TaskWait;
  this._state = Task.STOPPED;

  this.time = time;
};

TaskWait.prototype = {

/********************************************************************

********************************************************************/
  /**
   *	@private
  */
  _time : 0,
  _left_time : 0,

  /**
   *	@private
   */
  _timer : null,

  /**
   *	@private
   */
  _start_time : 0,

/********************************************************************

********************************************************************/

  /**
   *  Starts the task
   *
   * @param {any} param any parameter (scalar, Array, Object)
   * @ignore
   * @function
   */
  start: function ()
  {
    var self = this, time = this._time;
    if (this._state === Task.STARTED) { return false; }
    if (this._state === Task.PAUSED)
    { time = this._left_time; }
    else
    { this._left_time = time; }

    this._state = Task.STARTED;

    this._start_time = new Date ().getTime ();
    var self = this;
    this._timer = setTimeout (function ()
    {
      self._state = Task.STOPPED;
      if (self.delegate && self.delegate.taskDidEnd) {
        try {
          self.delegate.taskDidEnd (self); 
        }
        catch (e) {
          if (e.stack) console.log (e.stack)
          console.error (e);
        }
      }
    }, time);

    return true;
  },

  /**
   *  Stops the task.<br />
   *  When the task is stopped, it calls the taskDidStop if it exits.
   * @ignore
   * @function
   */
  stop: function ()
  {
    if (this._state === Task.STOPPED) { return false; }
    this._state = Task.STOPPED;

    clearTimeout (this._timer);
    this._timer = null;

    this._left_time = this._time;

    if (this.delegate && this.delegate.taskDidStop) {
      try {
        this.delegate.taskDidStop (this); 
      }
      catch (e) {
        if (e.stack) console.log (e.stack)
        console.error (e);
      }
    }

    return true;
  },

  /**
   *  Pause the task.<br />
   *  When the task is paused, it calls
   *  the TaskDelegate.taskDidPause if it exits.
   * @ignore
   * @function
   */
  pause: function ()
  {
    if (this._state === Task.PAUSED) { return false; }
    this._state = Task.PAUSED;

    this._left_time =
      this._left_time - new Date ().getTime () + this._start_time;

    if (this.delegate && this.delegate.taskDidPause) {
      try {
        this.delegate.taskDidPause (this);
      }
      catch (e) {
        if (e.stack) console.log (e.stack)
        console.error (e);
      }
    }
    return true;
  }
};
util.extendClass (TaskWait, Task);

util.defineClassProperty (TaskWait, "state", {

  /**
   * Set the task time, using millisecond. <br />
   * @name vs.core.TaskWait#time
   * @type {number}
   */
  set : function (v)
  {
    if (!util.isNumber (v)) { return; }
    this._time = v;
  }
});

/********************************************************************
                      Export
*********************************************************************/
util.extend (core, {
  Task:        Task,
  Task_PAR:    Task_PAR,
  Task_SEQ:    Task_SEQ,
  TaskWait:    TaskWait
});

/*
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * This represents the mobile device, and provides properties for inspecting
 * the model, version, UUID of the
 * phone, etc.
 * @constructor
 */
 
/**
 *  @class An vs.core.DeviceConfiguration object describes the device's hardware
 *  and software.
 *  <br /><br />
 *  A global object is visible in the window global scope: 
 *  window.deviceConfiguration.
 *
 *  
 *  @example
 *  var conf = window.deviceConfiguration;
 *  console.log ("OS: " + conf.os);
 *  console.log ("Screen size: " + conf.screenResolution);
 *  console.log ("Screen ratio: " + conf.screenRatio);
 *
 *  @author David Thevenin
 *
 *  @constructor
 *  Main constructor
 *
 *  @name vs.core.DeviceConfiguration
 */
function DeviceConfiguration ()
{
  this.orientation = null;
  this.deviceId = null;
//  this.targets = {};
  
  this.browserDetect ();
  this.orientationDetect ();
  this.screenDetect ();
}

/**
 * @name vs.core.DeviceConfiguration.OS_UNKNOWN 
 * @const
 */
DeviceConfiguration.OS_UNKNOWN = 0;

/**
 * @name vs.core.DeviceConfiguration.OS_WINDOWS 
 * @const
 */
DeviceConfiguration.OS_WINDOWS = 1;

/**
 * @name vs.core.DeviceConfiguration.OS_MACOS 
 * @const
 */
DeviceConfiguration.OS_MACOS = 2;

/**
 * @name vs.core.DeviceConfiguration.OS_LINUX 
 * @const
 */
DeviceConfiguration.OS_LINUX = 4;

/**
 * @name vs.core.DeviceConfiguration.OS_IOS 
 * @const
 */
DeviceConfiguration.OS_IOS = 5;

/**
 * @name vs.core.DeviceConfiguration.OS_WP7 
 * @const
 */
DeviceConfiguration.OS_WP7 = 6;

/**
 * @name vs.core.DeviceConfiguration.OS_BLACK_BERRY 
 * @const
 */
DeviceConfiguration.OS_BLACK_BERRY = 7;

/**
 * @name vs.core.DeviceConfiguration.OS_SYMBIAN 
 * @const
 */
DeviceConfiguration.OS_SYMBIAN = 8;

/**
 * @name vs.core.DeviceConfiguration.OS_ANDROID 
 * @const
 */
DeviceConfiguration.OS_ANDROID = 9;

/**
 * @name vs.core.DeviceConfiguration.OS_MEEGO 
 * @const
 */
DeviceConfiguration.OS_MEEGO = 10;

/**
 * @name vs.core.DeviceConfiguration.SR_UNKNOWN 
 * @const
 */
DeviceConfiguration.SR_UNKNOWN = 0;

/**
 * @name vs.core.DeviceConfiguration.SR_QVGA 
 * @const
 * QVGA (320×240) 
 */
DeviceConfiguration.SR_QVGA = 1;

/**
 * @name vs.core.DeviceConfiguration.SR_WQVGA 
 * @const
 * QVGA (400×240) 
 */
DeviceConfiguration.SR_WQVGA = 2;

/**
 * @name vs.core.DeviceConfiguration.SR_HVGA 
 * @const
 * HVGA (480×320) 
 */
DeviceConfiguration.SR_HVGA = 4;

/**
 * @name vs.core.DeviceConfiguration.SR_VGA 
 * @const
 * VGA (640×480) 
 */
DeviceConfiguration.SR_VGA = 5;

/**
 * @name vs.core.DeviceConfiguration.SR_WVGA 
 * @const
 * WVGA (800×480) 
 */
DeviceConfiguration.SR_WVGA = 6;

/**
 * @name vs.core.DeviceConfiguration.SR_FWVGA 
 * @const
 * FWVGA (854×480) 
 */
DeviceConfiguration.SR_FWVGA = 7;

/**
 * @name vs.core.DeviceConfiguration.SR_SVGA 
 * @const
 * SVGA (800×600)
 */
DeviceConfiguration.SR_SVGA = 8;

/**
 * @name vs.core.DeviceConfiguration.SR_DVGA 
 * @const
 * DVGA (960×640) 
 */
DeviceConfiguration.SR_DVGA = 9;

/**
 * @name vs.core.DeviceConfiguration.SR_WDVGA 
 * @const
 * WDVGA (1136×640) 
 */
DeviceConfiguration.SR_WDVGA = 10;

/**
 * @name vs.core.DeviceConfiguration.SR_XGA 
 * @const
 * XGA (1024×768)
 */
DeviceConfiguration.SR_XGA = 11;

/**
 * @name vs.core.DeviceConfiguration.SR_N_HD 
 * @const
 * nHD (640×360)
 */
DeviceConfiguration.SR_N_HD = 12;

/**
 * @name vs.core.DeviceConfiguration.SR_Q_HD 
 * @const
 * qHD (960×540)
 */
DeviceConfiguration.SR_Q_HD = 13;

/**
 * @name vs.core.DeviceConfiguration.SR_WXGA 
 * @const
 * WXGA (1280×720/768/800)
 */
DeviceConfiguration.SR_WXGA = 14;

/**
 * @name vs.core.DeviceConfiguration.SR_QXGA 
 * @const
 * QXGA (2048x1536)
 */
DeviceConfiguration.SR_QXGA = 15;

/**
 * @name vs.core.DeviceConfiguration.BROWSER_UNKNOWN 
 * @const
 */
DeviceConfiguration.BROWSER_UNKNOWN = 0;

/**
 * @name vs.core.DeviceConfiguration.BROWSER_CHROME
 * @const
 */
DeviceConfiguration.BROWSER_CHROME = 1;

/**
 * @name vs.core.DeviceConfiguration.BROWSER_SAFARI 
 * @const
 */
DeviceConfiguration.BROWSER_SAFARI = 2;

/**
 * @name vs.core.DeviceConfiguration.BROWSER_OPERA 
 * @const
 */
DeviceConfiguration.BROWSER_OPERA = 3;

/**
 * @name vs.core.DeviceConfiguration.BROWSER_FIREFOX 
 * @const
 */
DeviceConfiguration.BROWSER_FIREFOX = 4;

/**
 * @name vs.core.DeviceConfiguration.BROWSER_MSIE 
 * @const
 */
DeviceConfiguration.BROWSER_MSIE = 5;

/**
 * @name vs.core.DeviceConfiguration.SCREEN_SIZE_UNKNOWN 
 * @const
 */
DeviceConfiguration.SS_UNKNOWN = 0;

/**
 * @name vs.core.DeviceConfiguration.SCREEN_4_INCH 
 * @const
 */
DeviceConfiguration.SS_4_INCH = 1;

/**
 * @name vs.core.DeviceConfiguration.SCREEN_7_INCH 
 * @const
 */
DeviceConfiguration.SS_7_INCH = 2;

/**
 * @name vs.core.DeviceConfiguration.SCREEN_10_INCH 
 * @const
 */
DeviceConfiguration.SS_10_INCH = 3;


DeviceConfiguration.prototype = {
  
  /** 
   * Get the device's operating system name.
   * @name vs.core.DeviceConfiguration#os 
   * @type {number}
   */
  os : DeviceConfiguration.OS_UNKNOWN,

  /** 
   * Get the browser name.
   * @name vs.core.DeviceConfiguration#browser 
   * @type {number}
   */
  browser : DeviceConfiguration.BROWSER_UNKNOWN,

  /** 
   * Get the device's screen resolution type.
   * @name vs.core.DeviceConfiguration#screenResolution 
   * @type {number}
   */
  screenResolution : DeviceConfiguration.SR_UNKNOWN,

  /** 
   * Get the device's screen ratio.
   * @name vs.core.DeviceConfiguration#screenRatio 
   * @type {number}
   */
  screenRatio : 0,

  /** 
   * Get the device's class type (4, 7, 10 inches)
   * @name vs.core.DeviceConfiguration#screenSize 
   * @type {number}
   */
  screenSize : DeviceConfiguration.SS_UNKNOWN,
  
  virtualScreenSize : null,

  /**
   * @protected
   * @function
   */
  browserDetect : function ()
  {
    function searchString (data)
    {
      var i = data.length;
      while (i--)
      {
        var dataString = data [i].string;
        var dataProp = data [i].prop;
//        this.versionSearchString = data[i].versionSearch || data[i].identity;
        if (dataString)
        {
          if (dataString.match (data[i].subString))
          { return data[i].identity; }
        }
        else if (dataProp) { return data[i].identity; }
      }
    }

    this.browser = searchString (DeviceConfiguration._data_browser) ||   
      DeviceConfiguration.BROWSER_UNKNOWN;

    this.os = searchString (DeviceConfiguration._data_OS) ||
      DeviceConfiguration.OS_UNKNOWN;
  },
  
  /**
   * @protected
   * @function
   */
  orientationDetect : function ()
  {
    if (window.orientation) this.orientation = window.orientation;
    else if (window.outerWidth > window.outerHeight) this.orientation = 90;
    else this.orientation = 0;
  },
  
  _getScreenSize : function () {
    if (window.device && window.device.width) {
      return [window.device.width, window.device.height]
    }
    else if (this.os >= DeviceConfiguration.OS_IOS &&
        this.os <= DeviceConfiguration.OS_MEEGO) {
      // MOBILE DEVICES
      return [window.screen.width, window.screen.height];
    }
    else {
      // DESKTOP
      return [window.outerWidth, window.outerHeight];
    }
  },
  
  /**
   * @protected
   * @function
   */
  screenDetect : function ()
  {
    var pixelRatio = window.devicePixelRatio, screenSize;
    if (!pixelRatio) pixelRatio = 1;
    
    screenSize = this._getScreenSize ();

    if (screenSize[0] > screenSize[1])
    {
      var temp = screenSize[0]
      screenSize[0] = screenSize[1];
      screenSize[1] = temp;
    }
    
    this.screenResolution =
        DeviceConfiguration._getScreenResolutionCode (
          screenSize[0], screenSize[1]);

    this.screenRatio = screenSize[1] / screenSize[0];
    
    var dpi = 160 * pixelRatio;
    if (window.device && window.device.dpi) dpi = device.dpi;
 
    var size = Math.sqrt (
      screenSize[0] * screenSize[0] + screenSize[1] * screenSize[1]) / 
      dpi;
      
    if (size < 6) this.screenSize = DeviceConfiguration.SS_4_INCH;
    else if (size < 9) this.screenSize = DeviceConfiguration.SS_7_INCH;
    else if (size < 11) this.screenSize = DeviceConfiguration.SS_10_INCH;
  },
  
  /**
   * Returns the current GUI orientation.
   * <p/>
   * Be careful this API does not return the device orientation, which can be
   * deferent from the GUI orientation.
   * <p/>
   * Use the orientation module to have access to the device orientation.
   *
   * @name vs.core.DeviceConfiguration#getOrientation 
   * @function
   * 
   * @return {integer} returns a integer include in [-90, 0, 90, 180];
   * @public
   */
  getOrientation : function ()
  {
    return this.orientation;
  },
  
  /**
   * @protected
   * @function
   */
  setDeviceId : function (did)
  {
    //var screenSize;
    
    if (!util.isString (did)) return; 
    
    this.screenResolution = DeviceConfiguration.SR_UNKNOWN;
   
    this.deviceId = did;
    // screenSize = this._getScreenSize ();  
    // if (screenSize[0] > screenSize[1])
    // {
    //   var temp = screenSize[0]
    //   screenSize[0] = screenSize[1];
    //   screenSize[1] = temp;
    // }
    
    if (did.indexOf ("wp7") != -1)
    {
      this.os = DeviceConfiguration.OS_WP7;
      this.screenResolution = DeviceConfiguration.SR_WVGA;
      this.screenRatio = 16/10;
      this.screenSize = DeviceConfiguration.SS_4_INCH;
    }
    else if (did.indexOf ("iphone") != -1)
    {
      this.os = DeviceConfiguration.OS_IOS;
      this.screenResolution = DeviceConfiguration.SR_HVGA;
      if (did.indexOf ("_3_2") != -1) { this.screenRatio = 3/2; }
      else if (did.indexOf ("_16_9") != -1) { this.screenRatio = 16/9; }
      this.screenSize = DeviceConfiguration.SS_4_INCH;
    }
    else if (did.indexOf ("ipad") != -1)
    {
      this.os = DeviceConfiguration.OS_IOS;
      this.screenResolution = DeviceConfiguration.SR_XGA;
      this.screenRatio = 4/3;
      this.screenSize = DeviceConfiguration.SS_10_INCH;
    }
    // else if (did.indexOf ("nokia_s3") != -1)
    // {
    //   this.os = DeviceConfiguration.OS_SYMBIAN;
    //   this.screenResolution = DeviceConfiguration.SR_N_HD;
    //   this.screenRatio = 4/3;
    //   this.screenSize = DeviceConfiguration.SS_4_INCH;
    // }
    else if (did.indexOf ("android") != -1)
    {
      this.os = DeviceConfiguration.OS_ANDROID;
      if (did.indexOf ("_3_2") != -1) { this.screenRatio = 3/2; }
      else if (did.indexOf ("_16_10") != -1) { this.screenRatio = 16/10; }
      else if (did.indexOf ("_16_9") != -1) { this.screenRatio = 16/9; }
      
      if (did.indexOf ("android_4") != -1) { this.screenSize = DeviceConfiguration.SS_4_INCH; }
      else if (did.indexOf ("android_7") != -1) { this.screenSize = DeviceConfiguration.SS_7_INCH; }
      else if (did.indexOf ("android_10") != -1) { this.screenSize = DeviceConfiguration.SS_10_INCH; }

      // this.screenResolution =
      //   DeviceConfiguration._getScreenResolutionCode (
      //     screenSize[0], screenSize[1]);
    }
    // else if (did.indexOf ("blackberry") != -1)
    // {
    //   this.os = DeviceConfiguration.OS_BLACK_BERRY;
    //   if (did.indexOf("_4_3")) { this.screenRatio = 4/3; }
    //   else if (did.indexOf("_3_2")) { this.screenRatio = 3/2; }
    //   else if (did.indexOf("_16_10")) { this.screenRatio = 16/10; }
            
    //   this.screenResolution =
    //     DeviceConfiguration._getScreenResolutionCode (
    //       screenSize[0], screenSize[1]);
    // }
  },
  
  generateDeviceId : function (force)
  {
    if (force && this.deviceId) return this.deviceId;
    
    this.orientationDetect ();
    this.screenDetect ();
    var did = "";

    switch (this.os) {
      case DeviceConfiguration.OS_IOS:
        screenSize = this._getScreenSize ();
        if (screenSize[0] === 320 || screenSize[0] === 480) did += "iphone";
        if (screenSize[0] === 640 || screenSize[0] === 960) did += "iphone";
        if (screenSize[0] === 768 || screenSize[0] === 1024) did += "ipad";
        if (screenSize[0] === 1536 || screenSize[0] === 2048) did += "ipad";
      break;
 
      case DeviceConfiguration.OS_ANDROID:
        did += "android"
      break;
 
      case DeviceConfiguration.OS_WP7:
        did += "wp7"
      break;
 
      case DeviceConfiguration.OS_BLACK_BERRY:
        did += "blackberry"
      break;
    }    

    switch (this.screenSize) {
      case DeviceConfiguration.SS_4_INCH:
        did += "_3"
      break;
 
      case DeviceConfiguration.SS_7_INCH:
        did += "_7"
      break;
 
      case DeviceConfiguration.SS_10_INCH:
        did += "_10"
      break;
    }    

    if (Math.abs (window.deviceConfiguration.screenRatio - 3/2) < 0.1) 
      did += "_3_2";
    else if (Math.abs (window.deviceConfiguration.screenRatio - 4/3) < 0.1) 
      did += "_4_3";
    else if (Math.abs (window.deviceConfiguration.screenRatio - 16/10) < 0.1) 
      did += "_16_10";
    else if (Math.abs (window.deviceConfiguration.screenRatio - 16/9) < 0.1) 
      did += "_16_9";
      
    switch (this.orientation) {
      case 90:
      case -90:
        did += "_l"
      break;

      case 0:
      case 180:
        did += "_p"
      break;
    }
    
    return did;
  },

  /**
   * Set the GUI orientation
   *
   * @name vs.ui.Application#setOrientation 
   * @function
   * @protected
   * @param {number} orientation number include in {0, 180, -90, 90}
   */
  setOrientation : function (orientation, force)
  {
    var tmp_device_id, target_id, device, i, len, id, comp, 
      width = window.innerWidth, height = window.innerHeight, t;
        
    if (width > height)
    {
      t = height;
      height = width;
      width = t;
    }
  
    for (id in core.Object._obs)
    {
      comp = core.Object._obs [id];
      if (!comp) { continue; }
      
      if (comp._orientationWillChange)
      { comp._orientationWillChange (orientation); }
      if (comp.orientationWillChange)
      { comp.orientationWillChange (orientation); }
    }
    
    if (this.targetId) {
      target_id = this.targetId.replace ('_p', '');
      target_id = target_id.replace ('_l', '');
      
      if (orientation === 0 || orientation === 180) target_id += '_p';
      else target_id += '_l';
      
      this.targetId = target_id;
      this.setActiveStyleSheet (this.targetId);
    }
    this.orientation = orientation;

    if (this.virtualScreenSize && cordova && cordova.exec) {
      cordova.exec (
        null, null,
        "VSD_Application", "setAppSize",
        [{width: this.virtualScreenSize[0], height: this.virtualScreenSize[1]}]
      );
    }

    /**
     * @private
     */
    var orientationDidChangeFct = function ()
    {
      var id, comp;
      for (id in core.Object._obs)
      {
        comp = core.Object._obs [id];
        if (!comp || !comp.orientationDidChange) { continue; }
      
        comp.orientationDidChange (orientation);
      }
    }
    if (!force)
    {
      setTimeout (orientationDidChangeFct, 100);
    }
    else
    {
      orientationDidChangeFct.call (this);
    }
  },
    
  /**
   * @protected
   * @function
   */
  setActiveStyleSheet : function (pid)
  {
    util.setActiveStyleSheet (pid);
  },
    
  /**
   * @protected
   * @function
   */
  registerTargetId : function (tid, conf)
  {
//    this.targets [tid] = conf;
  }
};

/**
 * @private
 */
DeviceConfiguration._getScreenResolutionCode = function (width, height)
{
  width *= window.devicePixelRatio;
  height *= window.devicePixelRatio;
  if (width === 240 && height === 320) return DeviceConfiguration.SR_QVGA;
  if (width === 240 && height === 400) return DeviceConfiguration.SR_WQVGA;
  if (width === 320 && height === 480) return DeviceConfiguration.SR_HVGA;
  if (width === 480 && height === 640) return DeviceConfiguration.SR_VGA;
  if (width === 480 && height === 800) return DeviceConfiguration.SR_WVGA;
  if (width === 320 && height === 854) return DeviceConfiguration.SR_WFVGA;
  if (width === 600 && height === 800) return DeviceConfiguration.SR_SVGA;
  if (width === 640 && height === 960) return DeviceConfiguration.SR_DVGA;
  if (width === 640 && height === 1136) return DeviceConfiguration.SR_WDVGA
  if (width === 768 && height === 1024) return DeviceConfiguration.SR_XGA;
  if (width === 360 && height === 640) return DeviceConfiguration.SR_N_HD;
  if (width === 540 && height === 960) return DeviceConfiguration.SR_Q_HD;
  if (width === 720 && height === 1280) return DeviceConfiguration.SR_WXGA;
  if (width === 768 && height === 1280) return DeviceConfiguration.SR_WXGA;
  if (width === 800 && height === 1280) return DeviceConfiguration.SR_WXGA;
  if (width === 1536 && height === 2048) return DeviceConfiguration.SR_QXGA;
}

/**
 * @private
 */
DeviceConfiguration._estimateScreenSize = function (metric)
{
  var w = metric.width / metric.xdpi;
  var h = metric.height / metric.ydpi;
  var size = Math.sqrt (w*w + h*h);
  
  if (size < 5) return 3;
  if (size < 8) return 7;
  else return 10;
};

if (typeof navigator != "undefined")
{
/**
 * @private
 * @const
 */
DeviceConfiguration._data_browser = [
  {
    string: navigator.userAgent,
    subString: "Chrome",
    identity: DeviceConfiguration.BROWSER_CHROME
  },
  {
    string: navigator.vendor,
    subString: "Apple",
    identity: DeviceConfiguration.BROWSER_SAFARI,
    versionSearch: "Version"
  },
  {
    prop: window.opera,
    identity: DeviceConfiguration.BROWSER_OPERA,
    versionSearch: "Version"
  },
  {
    string: navigator.userAgent,
    subString: "Firefox",
    identity: DeviceConfiguration.BROWSER_FIREFOX
  },
  {
    string: navigator.userAgent,
    subString: "MSIE",
    identity: DeviceConfiguration.BROWSER_MSIE,
    versionSearch: "MSIE"
  }
];
}
else DeviceConfiguration._data_browser = [];

if (typeof navigator != "undefined")
{
/**
 * @private
 * @const
 */
DeviceConfiguration._data_OS = [
  {
    string: navigator.platform,
    subString: "Win",
    identity: DeviceConfiguration.OS_WINDOWS
  },
  {
    string: navigator.platform,
    subString: "Mac",
    identity: DeviceConfiguration.OS_MACOS
  },
  {
    string: navigator.platform,
    subString: "Linux",
    identity: DeviceConfiguration.OS_LINUX
  },
  {
     string: navigator.userAgent,
     subString: "iPad|iPhone|iPod",
     identity: DeviceConfiguration.OS_IOS
  },
  {
     string: navigator.userAgent,
     subString: "Android",
     identity: DeviceConfiguration.OS_ANDROID
  }
];
}
else DeviceConfiguration._data_OS = [];

if (typeof window != 'undefined' && !window.deviceConfiguration)
{
/**
 * @name deviceConfiguration 
 * @type vs.core.DeviceConfiguration
 */
  window.deviceConfiguration = new DeviceConfiguration ();
}

/********************************************************************
                      Export
*********************************************************************/
/** @private */
core.DeviceConfiguration = DeviceConfiguration;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and
  contributors. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/


/**
 *  The HTTPRequest class
 *
 * @extends vs.core.EventSource
 * @name vs.core.HTTPRequest
 * @events textload, xmlload, loaderror
 * @class
 * It provides scripted client functionality for transferring data between
 * a client and a server.
 *
 *  @constructor
 *   Creates a new HTTPRequest.
 *
 *  <br />
 *  Events:
 *  <ul>textload
 *    <li/> xmlload: data [xml doc]; propagate when data are loaded
 *    <li/> textload: data [text]: propagate when data are loaded
 *    <li/> loaderror: data [error information]: propagate when an error occured
 *  </ul>
 *  <br />
 * @example
 *  var xhr = new vs.core.HTTPRequest ({url: "http..."});
 *  xhr.init ();
 *  xhr.bind ('xmlload', this, this.processRSS);
 *  xhr.send ();
 *
 * @param {Object} config the configuration structure
 */
HTTPRequest = function (config)
{
  this.parent = core.EventSource;
  this.parent (config);
  this.constructor = HTTPRequest;

  this._headers = {};
  this.__xhrs = [];
};

HTTPRequest.prototype = {

 /*********************************************************
 *                  private data
 *********************************************************/

  /**
   *
   * @protected
   * @type {string}
   */
  _url: '',

  /**
   *
   * @protected
   * @type {string}
   */
  _method: 'GET',

  /**
   *
   * @protected
   * @type {string}
   */
  _login: '',

  /**
   *
   * @protected
   * @type {string}
   */
  _password: '',

  /**
   *
   * @protected
   * @type {string}
   */
  _content_type: '',

  /**
   *
   * @protected
   * @type {Object}
   */
  _headers: null,

  /**
   *
   * @private
   * @type {Object}
   */
  __xhrs: null,

  /**
   * @protected
   * @function
   */
  destructor : function ()
  {
    this.__xhrs.forEach (function (xhr) {
      if (xhr && xhr.onload) xhr.onabort ();
    });
    this.__xhrs = null;
    
    this._headers = null;
  
    EventSource.prototype.destructor.call (this);
  },

 /*********************************************************
 *                   management
 *********************************************************/

  /**
   *
   * @name vs.core.HTTPRequest#setHeaders
   * @function
   * An object of additional header key/value pairs to send along with the
   * request.
   *
   * @param {Object} obj A <key/string> object
   */
  setHeaders : function (obj)
  {
    if (!obj) return;

    for (var key in obj)
    {
      this._headers [key] = obj [key];
    }
  },

  /**
   *
   * @name vs.core.HTTPRequest#send
   * @function
   *
   * @param {String} data The data to send [optional]
   */
  send : function (data)
  {
    var xhr = new XMLHttpRequest ();

    try
    {
      this._response_text = null;
      this._response_xml = null;

      //prepare the xmlhttprequest object
      xhr.open (this._method, this._url, true, this._login || null, this._password || null);

      xhr.setRequestHeader ("Cache-Control", "no-cache");
      xhr.setRequestHeader ("Pragma", "no-cache");

      for (var key in this._headers)
      {
        xhr.setRequestHeader (key, this._headers [key]);
      }
      this._headers = {};

      if (this._content_type)
      { xhr.setRequestHeader('Content-Type', this._content_type); }

      var self = this;
      xhr.onabort = function (e)
      {
        xhr.onload = xhr.onerror = xhr.onabort = null;
        delete (xhr);
        self.propagate ('loaderror', {'status': 'aborted'});
      }
      xhr.onerror = function (e)
      {
        xhr.onload = xhr.onerror = xhr.onabort = null;
        delete (xhr);
        self.propagate ('loaderror', {'status': 'failed', 'response':e});
      }
      xhr.onload = function ()
      {
        xhr.onload = xhr.onerror = xhr.onabort = null;
        
        function endWithError (message) {
          self.propagate ('loaderror', message);
          delete (xhr);
          return false;
        }
        
        // manage possible errors
        if (xhr.readyState !== 4) return endWithError (xkr.statusText); 
        
        else if (xhr.status === 200)
        {
          self._response_text = xhr.responseText;
          self._response_xml = xhr.responseXML;

          self.propagateChange ();

          self.propagate ('textload', self._response_text);
          if (self._response_xml)
            self.propagate ('xmlload', self._response_xml);
          delete (xhr);
          return true;
        }
        
        else
        {
          return endWithError ({
            'status': xhr.statusText,
            'response':xhr.response
          });
        }
      }

      //send the request
      xhr.send (data);
      this.__xhrs.push (xhr);
    }
    catch (e)
    {
      xhr.onload = xhr.onerror = xhr.onabort = null;
      delete (xhr);
      this.propagate ('loaderror', e);
      return;
    }
  }
};
util.extendClass (HTTPRequest, core.EventSource);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (HTTPRequest, {
  "url": {
    /**
     * Setter for the url
     * @name vs.core.HTTPRequest#url
     * @type String
     */
    set : function (v)
    {
      if (!util.isString (v)) { return; }

      this._url = v;
    }
  },

  'method': {
    /**
     * Set request method (GET | POST)
     * @name vs.core.HTTPRequest#method
     * @type String
     */
    set : function (v)
    {
      if (v != 'GET' && v != 'POST') { return; }

      this._method = v;
    }
  },

  'login': {
    /**
     * Set request login
     * @name vs.core.HTTPRequest#login
     * @type String
     */
    set : function (v)
    {
      if (!util.isString (v)) { return; }

      this._login = v;
    }
  },

  'password': {
    /**
     * Set request password
     * @name vs.core.HTTPRequest#password
     * @type String
     */
    set : function (v)
    {
      if (!util.isString (v)) { return; }

      this._password = v;
    }
  },

  'contentType': {
    /**
     * Set request content type
     * @name vs.core.HTTPRequest#contentType
     * @type String
     */
    set : function (v)
    {
      if (!util.isString (v)) { return; }

      this._content_type = v;
    }
  },

  'responseText': {
    /**
     * Return request result as Text
     * @name vs.core.HTTPRequest#responseText
     * @type String
     */
    get : function ()
    {
      return this._response_text;
    }
  },

  'responseXML': {
    /**
     * Return request result as XML document
     * @name vs.core.HTTPRequest#responseXML
     * @type Document
     */
    get : function ()
    {
      return this._response_xml;
    }
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
core.HTTPRequest = HTTPRequest;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and
  contributors. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/


/**
 *  The AjaxJSONP class
 *
 * @extends vs.core.EventSource
 * @name vs.core.AjaxJSONP
 * @events jsonload, loaderror
 * @class
 * It performs a JSONP request to fetch data from another domain.
 *
 *  @constructor
 *   Creates a new AjaxJSONP.
 *
 *  <p>
 *  Events:
 *  <ul>
 *    <li/> jsonload: data [Object]: propagate when data are loaded
 *    <li/> loaderror: data [error information]: propagate when an error occured
 *  </ul>
 *  <p>
 * @example
 *  var xhr = new vs.core.AjaxJSONP ({url: "http..."}).init ();
 *  xhr.bind ('jsonload', this, this.processRSS);
 *  xhr.send ();
 *
 * @param {Object} config the configuration structure
 */
var AjaxJSONP = core.createClass ({

  parent: core.EventSource,

  /*********************************************************
  *                  private data
  *********************************************************/

  /**
   *
   * @protected
   * @type {string}
   */
  _url: '',

  /**
   *
   * @protected
   * @type {string}
   */
  _clb_param_name: 'callback',

  /**
   *
   * @private
   * @type {number}
   */
  __index: 0,

  /*********************************************************
  *                  Properties
  *********************************************************/

  properties : {
    "url": {
      /**
       * Setter for the url
       * @name vs.core.AjaxJSONP#url
       * @type String
       */
      set : function (v)
      {
        if (!util.isString (v)) { return; }

        this._url = v;
      }
    },
    "clbParamName": {
      /**
       * Setter for the name of the callback parameter in jsonp payload
       * By default the value is 'callback'
       * @name vs.core.AjaxJSONP#clbParamName
       * @type String
       */
      set : function (v)
      {
        if (!util.isString (v)) { return; }

        this._clb_param_name = v;
      }
    },

    'responseJson': {
      /**
       * Return request result as Javascript Object
       * @name vs.core.AjaxJSONP#responseJson
       * @type Document
       */
      get : function ()
      {
        return this._response_json;
      }
    }
  },

 /*********************************************************
 *                   management
 *********************************************************/

  /**
   *
   * @name vs.core.AjaxJSONP#send
   * @function
   */
  send : function ()
  {
    var
      self = this,
      callbackName = 'jsonp' + self._id + (self.__index++),
      urlCallback = this._clb_param_name + "=" + callbackName,
      script_src = self._url, lastIndex = script_src.length - 1;

    if (script_src [lastIndex] === '?')
      script_src += urlCallback;
    else if (script_src.indexOf ('?') !== "-1")
      script_src += "&" + urlCallback;
    else if (script_src [lastIndex] === '/')
      script_src = script_src.substr (0, lastIndex) + "?" + urlCallback;
    else
      script_src += "?" + urlCallback;

    var
      script = util.importFile (script_src, null, null, 'js'),
      removeScript = function ()
      {
        if (script)
        {
          script.parentElement.removeChild (script);
          script = undefined;
        }
      },
      abortTimeout = setTimeout (function ()
      {
        removeScript ();
        if (callbackName in window) delete (window [callbackName]);
        self.propagate ('loaderror', 'Impossible to load data');
      }, 3000);

    window [callbackName] = function (data)
    {
      clearTimeout (abortTimeout)
      removeScript ();
      delete window[callbackName];

      if (!data) return;
      if (data.error)
      {
        self.propagate ('loaderror', data.error);
        return;
      }
      self._response_json = data;
      self.outPropertyChange ();
      self.propagate ('jsonload', data);
    }
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
core.AjaxJSONP = AjaxJSONP;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and
  contributors. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.

 Use code from Canto.js Copyright 2010 Steven Levithan <stevenlevithan.com>
*/

/**
 *  @class
 *  vs.core.Array is an Array of Object or Model.
 *
 * @extends vs.core.Model
 * @author David Thevenin
 *
 *  @constructor
 *  Main constructor
 *
 * @name vs.core.Array
 *
 * @param {Object} config the configuration structure
*/
function VSArray (config)
{
  this.parent = vs.core.Model;
  this.parent (config);
  this.constructor = vs.core.Array;
}

VSArray.prototype = {

  /*****************************************************************
   *
   ****************************************************************/

   _data: null,
   _model_class: null,
   _index: null,
   _value: null,

  /*****************************************************************
   *
   ****************************************************************/

  /**
   * @name vs.core.Array#initComponent
   * @function
   * @protected
   */
   initComponent : function ()
   {
     this._data = [];
     this.forEach = Array.prototype.forEach.bind (this._data);
   },

  /*****************************************************************
   *
   ****************************************************************/
   
   forEach: function () {},

  /**
   * Returns the nth element
   *
   * @name vs.core.Array#item
   * @function
   *
   * @param {number} index
   */
  item : function (index)
  {
    if (!(util.isNumber (index))) return;
    if (index < 0 || index > this._data.length) return;

    return this._data [index];
  },

  /**
   * @private
   * @name vs.core.Array#_instanceModel
   * @function
   */
  _instanciateModel : function (obj)
  {
    if (obj instanceof vs.core.Model) return obj;
    if (obj instanceof Object && this._model_class)
    {
      try
      {
        var _model = new this._model_class (obj);
        _model.init ();
        return _model;
      }
      catch (e)
      {
        if (e.stack) console.log (e.stack)
        console.error (e);
      }
    }

    return obj;
  },

  /**
   * Adds one or more elements to the end of an array and returns the
   * new length of the array.
   *
   * @name vs.core.Array#add
   * @function
   *
   * @param {...vs.core.Object} datas
   */
  add : function ()
  {
    var args = [], i = 0;
    for (;i < arguments.length; i++)
    { args.push (this._instanciateModel (arguments[i])); }

    this._data.push.apply (this._data, args);

    if (this.hasToPropagateChange ()) this.change ('add');

    return this.length;
  },

  /**
   * Adds one or more elements to the end of an array and returns the
   *
   * @name vs.core.Array#addAtIndex
   * @function
   *
   * @param {number} index the position
   * @param {...vs.core.Object} datas
   */
  addAtIndex : function ()
  {
    if (arguments.length < 2) { return; }
    var args = [], i = 1;
    for (;i < arguments.length; i++)
    { args.push (this._instanciateModel (arguments[i])); }

    this._data.splice.apply (this._data, args);
    if (this.hasToPropagateChange ())
      this.change ('add', {from: args[0], to: args.length - 2});
  },

  /**
   * Removes the elements in the specified interval of this Array.<br/>
   * Shifts any subsequent elements to the left (subtracts one from
   * their indices).<br/>
   *
   * @example
   * myarray.remove (3); //remove the fourth item
   * ...
   * myarray.remove (3, 5); //remove the fourth, fifth and sixth items
   *
   * @name vs.core.Array#remove
   * @function
   *
   * @param {int} from Index of the first element to be removed
   * @param {int} to Index of the last element to be removed
   */
  remove : function (from, to)
  {
    this._data.remove (from, to);
    if (this.hasToPropagateChange ()) this.change ('remove', {from: from, to: to});
  },

  /**
   * Removes all elements of this Array.<br/>
   * @name vs.core.Array#removeAll
   * @function
   */
  removeAll : function ()
  {
    this._data = [];
    this._index = -1;
    this._value = undefined;
    
    this.forEach = Array.prototype.forEach.bind (this._data);
    if (this.hasToPropagateChange ()) this.change ('removeall');
  },

  /**
   * Removes all elements of this Array.<br/>
   * @name vs.core.Array#clear
   * @param {Boolean} should_free free content items
   * @function
   */
  clear : function (should_free)
  {
    var i = 0, l = this._data.length;
    
    if (should_free) for (;i < l; i++) {
      vs.util.free (this._data [i]);
    }
    
    this.removeAll ();
  },

  /**
   *  .
   *
   * @name vs.core.Array#indexOf
   * @function
   * @param {String} str the url to parse
   */
  indexOf : function ()
  {
    throw ("method not yet implemented");
//    this._data.push ();
  },

  /*****************************************************************
   *
   ****************************************************************/

  /**
   *  Returns a copy of the objet's properties for JSON stringification.<p/>
   *  This can be used for persistence or serialization.
   *
   * @name vs.core.Array#toJSON
   * @function
   * @return {Object} the object value for stringify
   */
  toJSON : function ()
  {
    var result = this._toJSON (), i = 0, l = this._data.length, obj;
    
    result.data = [];
    for (;i < l; i++)
    {
      obj = this._data [i];
      if (typeof obj == "undefined") continue;
      else if (obj instanceof Date)
      { obj = '"\/Date(' + obj.getTime () + ')\/"'; }
      else if (obj && obj.toJSON) obj = obj.toJSON ();
      
      result.data.push (obj);
    }

    return result;
  },

  /**
   * @protected
   */
  parseData : function (obj)
  {
    var i, key, _model, item, self = this;
    
    this.stopPropagation ();

    function fillArray (data)
    {
      self._data = [];
      self.forEach = Array.prototype.forEach.bind (self._data);
      for (i = 0; i < data.length; i++)
      {
        item = data [i];
        
        // set model
        if (self._model_class) {
          _model = new self._model_class ().init ();
        }

        else if (util.isArray (item)) {
          _model = new VSArray ().init ();
        }
        
        else if (util.isUndefined (item) || util.isString (item) ||
          util.isNumber (item) || typeof item == "boolean" ||
          item == null || item instanceof Date) _model = null
          
        // generic model
        else _model = new Model ().init ();
        
        if (_model) {
          _model.parseData (item);
          self.add (_model);
        }
        else self.add (item);
      }
    };

    if (util.isArray (obj))
    {
      fillArray (obj);
    }
    else for (key in obj)
    {
      if (key == 'data')
      {
        fillArray (obj.data);
      }
      else this._parse_property (key, obj [key]);
    }
    
    this.change ();
  }
};
util.extendClass (VSArray, core.Model);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (VSArray, {
  "data" : {
    /**
     * Set data elements for the array
     *
     * @name vs.core.Array#data
     * @type {Array | vs.core.Array}
     */
    set : function (v)
    {
      if (!this.__i__) throw ("Component not initialized");

      if (util.isArray (v)) {
        this._data = v.slice ();
        this.forEach = Array.prototype.forEach.bind (this._data);
      }
      else if (v instanceof VSArray)
      {
        this._data = v._data.slice ();
        this.forEach = Array.prototype.forEach.bind (this._data);
      }
      else return;

      if (this.hasToPropagateChange ()) this.change ('add');
    },

    /**
     * Returns an array of elements
     *
     * @name vs.core.Array#data
     * @type {Array}
     */
    get : function ()
    {
      if (!this.__i__) throw ("Component not initialized");
      return this._data.slice ();
    }
  },

  "length" : {
    /**
     * Reflects the number of elements in an array.
     *
     * @name vs.core.Array#length
     * @type {number}
     */
    get : function ()
    {
      if (!this.__i__) throw ("Component not initialized");
      return this._data.length;
    }
  },

  "modelClass" : {
    /**
     * Set this property to specify the model class that the Array contains
     *
     * @name vs.core.Array#modelClass
     * @type {vs.core.Model}
     */
    set : function (v)
    {
      if (!(util.isFunction (v))) return;

      this._model_class = v;
    }
  },
  
  "index" : {
    /**
     * Select the nth element. The output property value, will be changed
     *
     * @name vs.core.Array#index
     * @type {number}
     */
    set : function (v)
    {
      if (util.isString (v)) v = parseInt (v, 10);
      
      if (!(util.isNumber (v))) return;
      if (v < 0 || v > this._data.length) return;
      
      v = Math.floor (v);
      
      this._index = v;
      this._value = this._data [v];
      
      this.propertyChange ("value");
    },
    
    /**
     *  Return the current index value
     *
     * @name vs.core.Array#value
     * @type {number}
     */
    get : function ()
    {
      return this._index;
    }
  },

  "value" : {
    /**
     *  Return the current selected element. This property change when
     *  array#index property change or if the method item is called.
     *
     * @name vs.core.Array#value
     * @type {number}
     */
    get : function ()
    {
      return this._value;
    }
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
core.Array = VSArray;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  @extends vs.core.EventSource
 *  @class vs.core.DataStorage 
 *  is an abstract class for managing data save and laod.
 *  <br/><br/> >>>> THIS CODE IS STILL UNDER BETA AND 
 *  THE API MAY CHANGE IN THE FUTURE <<< <p>
 *
 *  @author David Thevenin
 *
 *  @constructor
 *  Main constructor
 *
 * @name vs.core.DataStorage
 * @see vs.core.LocalStorage
 *
 * @param {Object} config the configuration structure
 */
function DataStorage (config)
{
  this.parent = core.EventSource;
  this.parent (config);
  this.constructor = vs.core.DataStorage;

  this.__models__ = {};
}

DataStorage.prototype = {

  /*****************************************************************
   *
   ****************************************************************/
   
   __models__: null,
  
  /*****************************************************************
   *              
   ****************************************************************/
   
  /*****************************************************************
   *              
   ****************************************************************/
  
  /**
   * Register a model into the sync service.
   *
   * @name vs.core.DataStorage#registerModel
   * @function
   * @param {String} name model name
   * @param {vs.core.Model} model the model to register
   */
  registerModel : function (name, model)
  {
    if (!name || !model) return;
    
    if (this.__models__ [name])
      error.log ("Model with the name already registered.");
      
    this.__models__ [name] = model;
    
    model._sync_service_ = this;
  },
  
  /**
   * Remove a model from the sync service. <br/>
   * If the you want also delete delete data you have to call before the 
   * delete methode
   *
   * @name vs.core.DataStorage#removeModel
   * @function
   * @param {String} name model name
   */
  removeModel : function (name)
  {
    if (!name) return;
    
    if (!this.__models__ [name]) return;
      
    delete (this.__models__ [name]);
  },
  
  /*****************************************************************
   *              
   ****************************************************************/
  
  /**
   * Save models. If a name is specified, it save only the model
   * associated to the name.
   *
   * @name vs.core.DataStorage#save
   * @function
   * @param {String} name model name to save [optional]
   */
  save : function (name) {},
  
  /**
   * Load models. If a name is specified, it load only the model
   * associated to the name.
   *
   * @name vs.core.DataStorage#load
   * @function
   * @param {String} name model name to save [optional]
   */
  load : function (name) {},
  
  /*****************************************************************
   *              
   ****************************************************************/
};
util.extendClass (DataStorage, core.EventSource);

/********************************************************************
                      Export
*********************************************************************/
/** @private */
core.DataStorage = DataStorage;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  @extends vs.core.DataStorage
 *  @class vs.core.LocalStorage 
 *  is an implementation of DataStorage for storing data into HTML5 LocalStorage
 *  <br/><br/> >>>> THIS CODE IS STILL UNDER BETA AND 
 *  THE API MAY CHANGE IN THE FUTURE <<< <p>
 * 
 *  @example
 *   var todoList = vs.core.Array ();
 *   todoList.init ();
 *
 *   var localStorage = new vs.core.LocalStorage ();
 *   localStorage.init ();
 *   localStorage.registerModel ("todoslist", todosList);
 *   localStorage.load ();
 *   ...
 *   // model modification
 *   localStorage.save ();
 *
 *  @author David Thevenin
 *
 *  @constructor
 *  Main constructor
 *
 * @name vs.core.LocalStorage
 *
 * @param {Object} config the configuration structure
 */
function LocalStorage (config)
{
  this.parent = DataStorage;
  this.parent (config);
  this.constructor = vs.core.LocalStorage;
}

LocalStorage.prototype = {

  /*****************************************************************
   *
   ****************************************************************/
   
  /*****************************************************************
   *              
   ****************************************************************/
   
  /*****************************************************************
   *              
   ****************************************************************/
  
  /**
   * Save models. If a name is specified, it saves only the model
   * associated to the name.
   *
   * @name vs.core.LocalStorage#save
   * @function
   * @param {String} name model name to save [optional]
   */
  save : function (name)
  {
    var self = this;
    function _save (name)
    {
      var json, model = self.__models__ [name];
      if (!model) return;
      
      try
      {
        json = JSON.stringify (model);
      }
      catch (e)
      {
        if (e.stack) console.log (e.stack)
        error.log (e);
        self.propagate ("error", e);
      }
      
      localStorage.setItem (name, json);
    }
    if (name) _save (name);
    else for (var name in this.__models__) _save (name);
    
    self.propagate ("save");
  },
  
  /**
   * Load models. If a name is specified, it load only the model
   * associated to the name.
   *
   * @name vs.core.LocalStorage#load
   * @function
   * @param {String} name model name to save [optional]
   */
  load : function (name)
  {
    var self = this;
    function _load (name)
    {
      try {
        var json, model = self.__models__ [name];
        if (!model) return;
        
        var store = localStorage.getItem (name);
        model.parseJSON (store);
      }
      catch (e)
      {
        if (e.stack) console.log (e.stack)
        console.error ("LocalStorate.load failed. " + e.toString ());
      }
    }
    if (name) _load (name);
    else for (var name in this.__models__) _load (name);
    
    self.propagate ("load");
  }
};
util.extendClass (LocalStorage, DataStorage);

/********************************************************************
                      Export
*********************************************************************/
/** @private */
core.LocalStorage = LocalStorage;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and
  contributors. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  @extends vs.core.DataStorage
 *  @class vs.core.RestStorage
 *  is an implementation of DataStorage for REST service
 *  <br/><br/> >>>> THIS CODE IS STILL UNDER BETA AND
 *  THE API MAY CHANGE IN THE FUTURE <<< <p>
 *  SUPPORT only load for now.
 *
 *  @example
 *   var todoList = new vs.core.Array ();
 *   todoList.init ();
 *
 *   var restSource = new vs.core.RestStorage ({
 *     url: "https://xxx"
 *   }).init ();
 *   restSource.registerModel ("todoslistOne", todosList);
 *   restSource.registerModel ("todoslistTwo", todosList);
 *   // Load all models
 *   restSource.load ();
 *   // Load only todoslistOne model
 *   restSource.load ("todoslistOne");
 *
 *  @author David Thevenin
 *
 *  @constructor
 *  Main constructor
 *
 * @name vs.core.RestStorage
 *
 * @param {Object} config the configuration structure
 */
function RestStorage (config)
{
  this.parent = DataStorage;
  this.parent (config);
  this.constructor = RestStorage;

  this._xhrs = {};
  this._headers = {};
}

/**
 * Configure the RestStorage to use HttpRequest. Default configuration.
 * @name vs.core.RestStorage.XHR
 * @see vs.core.RestStorage#mode
 * @const
 */
RestStorage.XHR = 0;

/**
 * Configure the RestStorage to use JSONP
 * @name vs.core.RestStorage.JSONP
 * @see vs.core.RestStorage#mode
 * @const
 */
RestStorage.JSONP = 1;

RestStorage.prototype = {

  /*****************************************************************
   *
   ****************************************************************/

  /**
   *
   * @protected
   * @type {Object}
   */
  _xhrs: null,

  /**
   *
   * @protected
   * @type {}
   */
  _mode: 0,

  /**
   *
   * @protected
   * @type {Object}
   */
  _headers: null,

  /**
   *
   * @protected
   * @type {String}
   */
  _url: '',

  /*****************************************************************
   *
   ****************************************************************/

  /**
   * @protected
   * @function
   */
  initComponent: function ()
  {
    DataStorage.prototype.initComponent.call (this);
  },

  /**
   * @protected
   * @function
   */
  destructor: function ()
  {
    DataStorage.prototype.destructor.call (this);
  },

  /**
   *
   * @name vs.core.RestStorage#setHeaders
   * @function
   * An object of additional header key/value pairs to send along with the
   * HTTP request.
   *
   * @param {Object} obj A <key/string> object
   */
  setHeaders : function (obj)
  {
    if (!obj) return;

    this._headers = {};

    for (var key in obj)
    {
      this._headers [key] = obj [key];
    }
  },

  /*****************************************************************
   *
   ****************************************************************/

  /**
   * Save models. If a name is specified, it saves only the model
   * associated to the name.
   *
   * @name vs.core.RestStorage#save
   * @function
   * @param {String} name model name to save [optional]
   */
  save : function (name)
  {
    var self = this;
    function _save (name)
    {
      var json, model = self.__models__ [name];
      if (!model) return;

      try
      {
        json = JSON.stringify (model);
      }
      catch (e)
      {
        if (e.stack) console.log (e.stack)
        error.log (e);
        self.propagate ("error", e);
      }

      RestStorage.setItem (name, json);
    }
    if (name) _save (name);
    else for (var name in this.__models__) _save (name);

    self.propagate ("save");
  },

  /**
   * Load models. If a name is specified, it load only the model
   * associated to the name.
   *
   * @name vs.core.RestStorage#load
   * @function
   * @param {String} name model name to save [optional]
   */
  load : function (name)
  {
    if (this._mode === RestStorage.XHR) this._load_xhr (name);
    if (this._mode === RestStorage.JSONP) this._load_jsonp (name);
  },

  /**
   * @private
   */
  _load_xhr : function (name)
  {
    var type = "GET";

    var dataType = 'xml';

    var self = this;
    function _load (name)
    {
      try {
        var model = self.__models__ [name];
        if (!model) return;

//        var url = self._url + name + '.json';
        var url = self._url + name;

        var ps = model.getModelProperties (), j = 0;
        if (ps && ps.length)
        {
          url += '?';
          for (var i = 0; i < ps.length; i ++)
          {
            var prop_name = ps[i], value = model ['_' + util.underscore (prop_name)];
            if (prop_name === "id" || prop_name === 'modelClass') continue
            if (!util.isString (value) && !util.isNumber (value)) continue;
            if (j++) url += '&';
            url += prop_name + '=' + escape (value);
          }
        }

        var xhr = new HTTPRequest ().init ();
        self._xhrs [xhr.id] = name;
        xhr.bind ('textload', self, self._process_xhr_result);
        xhr.setHeaders (self._headers);
        xhr.url = url;
        xhr.method = "GET";
        xhr.contentType = "application/json";
        xhr.send ();
      }
      catch (e)
      {
        if (e.stack) console.log (e.stack)
        console.error ("LocalStorate.load failed. " + e.toString ());
      }
    }
    if (name) _load (name);
    else for (var name in this.__models__) _load (name);
  },

 /**
   * @private
   */
  _load_jsonp : function (name)
  {
    var type = "GET";

    var dataType = 'xml';

    var self = this;
    function _load (name)
    {
      try {
        var model = self.__models__ [name];
        if (!model) return;

        var url = self._url + name + '.json';

        var ps = model.getModelProperties (), j = 0;
        if (ps && ps.length)
        {
          url += '?';
          for (var i = 0; i < ps.length; i ++)
          {
            var prop_name = ps[i], value = model ['_' + util.underscore (prop_name)];
            if (prop_name === "id" || prop_name === 'modelClass') continue
            if (!util.isString (value) && !util.isNumber (value)) continue;
            if (j++) url += '&';
            url += prop_name + '=' + escape (value);
          }
        }

        var xhr = new AjaxJSONP ().init ();
        self._xhrs [xhr.id] = name;
        xhr.bind ('jsonload', self, self._process_json_result);
        xhr.url = url;
        xhr.send ();
      }
      catch (e)
      {
        if (e.stack) console.log (e.stack)
        console.error ("LocalStorate.load failed. " + e.toString ());
      }
    }
    if (name) _load (name);
    else for (var name in this.__models__) _load (name);
  },

  _sync : function (method, url, specific_data)
  {
//     var params = {}, data = '';
//
//     // Ensure that we have the appropriate request data.
//     if (method == 'POST' || method == 'PUT')
//     {
//       this._xhr.contentType = 'application/json';
//       if (!specific_data)
//       { data = this.toJSON (); }
//       else
//       { data = specific_data; }
//     }
//
//     this._xhr.method = method;
//     this._xhr.url = url;
//
//     // Make the request.
//     this._xhr.send (data);
  },

  /**
   * processes the received rss xml
   *
   * @name vs.data.RSSRequester#_process_xhr_result
   * @function
   *
   * @private
   * @param Text rsstxt
   * @param Document rssxml
   */
  _process_xhr_result : function (event)
  {
    var data = event.data, xhr = event.src;
    var model_name = this._xhrs [xhr.id];
    xhr.unbind ('textload', this, this._process_xhr_result);
    vs.util.free (xhr);
    delete (this._xhrs [xhr.id]);

    if (!data)
    {
      console.error ("Failed to parse rss document that is null.");
      return false;
    }

    var model = this.__models__ [model_name];
    if (!model) return;

    model.parseJSON (data);
    model.change ();
    this.propagate ('load', model);
  },

  /**
   * processes the received rss xml
   *
   * @name vs.data.RSSRequester#_process_json_result
   * @function
   *
   * @private
   * @param Text rsstxt
   * @param Document rssxml
   */
  _process_json_result : function (event)
  {
    var data = event.data, xhr = event.src;
    var model_name = this._xhrs [xhr.id];
    xhr.unbind ('textload', this, this._process_json_result);
    vs.util.free (xhr);
    delete (this._xhrs [xhr.id]);

    var model = this.__models__ [model_name];
    if (!model) return;

    model.parseData (data);
    model.change ();
    this.propagate ('load', model);
  }
};
vs.util.extendClass (RestStorage, DataStorage);

/********************************************************************
                  Define class properties
********************************************************************/

vs.util.defineClassProperties (RestStorage, {
  "url": {
    /**
     * Setter for the url
     * @name vs.core.RestStorage#url
     * @type String
     */
    set : function (v)
    {
      if (!vs.util.isString (v)) { return; }

      this._url = v;
    },

    /**
     * Getter for the url
     * @name vs.core.RestStorage#url
     * @type String
     */
    get : function (v)
    {
      return this._url;
    }
  },

  "mode": {
    /**
     * Setter request mode
     * @name vs.core.RestStorage#mode
     * @type XHR | JSONP
     */
    set : function (v)
    {
      if (v === 0 || v === 1) this._mode = v;
    }
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
vs.core.RestStorage = RestStorage;

})(window);/** @license
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

(function (window, undefined) {

var document = window.document;

/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/********************************************************************
                   
*********************************************************************/
/** @private */
var vs = window.vs,
  util = vs.util,
  core = vs.core,
  data = vs.data;

/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
 
  Use code from Canto.js Copyright 2010 Steven Levithan <stevenlevithan.com>
*/

/**
 *  The URL class
 *  URL splits any URI into its parts, all of which are optional.<br/>
 *  This code is based on parseUri, Copyright 2010 Steven Levithan 
 *  <stevenlevithan.com>
 *
 *  @extends vs.core.Object
 * @name vs.data.URL
 *  @class
 *
 *  @example
 *  var url = new vs.data.URL ();
 *  url.parse ('http://test.com/dir1/dir2/index.html#top');
 *  console.log (url.path);
 *
 *  @example
 *  var url = new ABURL ();
 *  url.src = 'http://test.com/dir1/dir2/index.html#top';
 *  console.log (url.path);
 *
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.data.URL.
 *
 * @param {Object} config The configuration structure [mandatory]
*/
function URL (config)
{
  this.parent = core.Object;
  this.parent (config);
  this.constructor = URL;
}

URL.prototype = {

  /*****************************************************************
   *
   ****************************************************************/
   
  /**
   * @protected
   * @type {string}
   */
  _src: "",
  
  /**
   * @protected
   * @type {string}
   */
  _anchor: "",
  
  /**
   * @protected
   * @type {string}
   */
  _query: "",
  
  /**
   * @protected
   * @type {string}
   */
  _file: "",
  
  /**
   * @protected
   * @type {string}
   */
  _directory: "",
  
  /**
   * @protected
   * @type {string}
   */
  _path: "",
  
  /**
   * @protected
   * @type {string}
   */
  _relative: "",
  
  /**
   * @protected
   * @type {number}
   */
  _port: 0,
  
  /**
   * @protected
   * @type {string}
   */
  _host: "",
  
  /**
   * @protected
   * @type {string}
   */
  _password: "",
  
  /**
   * @protected
   * @type {string}
   */
  _user: "",
  
  /**
   * @protected
   * @type {string}
   */
  _authority: "",
  
  /**
   * @protected
   * @type {string}
   */
  _protocol: "",
  
  /**
   * @protected
   * @type {object}
   */
  _query_key: null,
  

  /*****************************************************************
   *              
   ****************************************************************/

  /**
   * @private
   * @type {object}
   */
  __options : {
    strictMode: false,
    key: ["_source","_protocol","_authority","_userInfo","_user","_password","_host","_port","_relative","_path","_directory","_file","_query","_anchor"],
    q:   {
      name:   "_query_key",
      parser: /(?:^|&)([^&=]*)=?([^&]*)/g
    },
    parser: {
      strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
      loose:  /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
  },
  
  /*****************************************************************
   *              
   ****************************************************************/

  /**
   *  Parse a url.
   *
   * @name vs.data.URL#parse
   * @function
   * @param {String} str the url to parse
   */
  parse : function (str)
  {
    if (!util.isString (str)) { return; }
    
    this._src = str;
    
    var	o   = this.__options,
      m   = o.parser[o.strictMode ? "strict" : "loose"].exec(str),
      i   = 14, self = this;
  
    while (i--) { this [o.key[i]] = m[i] || ""; }
  
    this [o.q.name] = {};
    this [o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
      if ($1) self [o.q.name][$1] = $2;
    });
    
    this.outPropertyChange ('src');
  }
};
util.extendClass (URL, core.Object);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (URL, {
  "src" : {
    /** 
     * The url src
     * @example
     * http://test.com/index.html#top
     *
     * @name vs.data.URL#src
     * @type {string}
     */ 
    set : function (v)
    {
      if (!util.isString (v)) { return; }
      
      this.parse (v);
    },
  
    get : function ()
    {
      return this._src;
    },
  },
  "anchor" : {
    /**
     * The url anchor
     * @example
     * top in http://test.com/index.html#top
     *
     * @name vs.data.URL#anchor 
     * @type {string}
     */
    get : function ()
    {
      return this._anchor;
    }
  },
  "query" : {
    /** 
     * The query query
     *
     * @name vs.data.URL#query
     * @type {string}
     */ 
    get : function ()
    {
      return this._query;
    }
  },
  "queryKey" : {
    /** 
     * The url query as object of <key, value>
     *
     * @name vs.data.URL#queryKey
     * @type {object}
     */ 
    get : function ()
    {
      return this._query_key;
    }
  },
  "file" : {
    /** 
     * The url file name
     * @example
     * index.html in http://test.com/index.html#top 
     *
     * @name vs.data.URL#file
     * @type {string}
     */ 
    get : function ()
    {
      return this._file;
    }
  },
  "directory" : {
    /** 
     * The url anchor
     * @example
     * dir1/dir2/ in http://test.com/dir1/dir2/index.html#top 
     *
     * @name vs.data.URL#directory
     * @type {string}
     */ 
    get : function ()
    {
      return this._directory;
    }
  },
  "path" : {
    /** 
     * The url path
     * @example
     * dir1/dir2/index.html in http://test.com/dir1/dir2/index.html#top 
     *
     * @name vs.data.URL#path
     * @type {string}
     */ 
    get : function ()
    {
      return this._path;
    }
  },
  "port" : {
    /** 
     * The url port
     *
     * @name vs.data.URL#port
     * @type {number}
     */ 
    get : function ()
    {
      return this._port;
    }
  },
  "relative" : {
    /** 
     * The url relative
     * @example
     * dir1/dir2/index.html#top in http://test.com/dir1/dir2/index.html#top 
     *
     * @name vs.data.URL#relative
     * @type {string}
     */ 
    get : function ()
    {
      return this._relative;
    }
  },
  "host" : {
    /** 
     * The url host
     * @example
     * test.com in http://test.com/dir1/dir2/index.html#top 
     *
     * @name vs.data.URL#host
     * @type {string}
     */ 
    get : function ()
    {
      return this._host;
    }
  },
  "password" : {
    /** 
     * The url password
     *
     * @name vs.data.URL#password
     * @type {string}
     */ 
    get : function ()
    {
      return this._password;
    }
  },
  "user" : {
    /** 
     * The url user
     *
     * @name vs.data.URL#user
     * @type {string}
     */ 
    get : function ()
    {
      return this._user;
    }
  },
  "authority" : {
    /** 
     * The url authority
     * @example
     * usr:pwd@www.test.com:81
     *
     * @name vs.data.URL#authority
     * @type {string}
     */ 
    get : function ()
    {
      return this._authority;
    }
  },
  "protocol" : {
    /** 
     * The url protocol
     * @example
     * http in http://test.com/dir1/dir2/index.html#top 
     *
     * @name vs.data.URL#protocol
     * @type {string}
     */ 
    get : function ()
    {
      return this._protocol;
    }
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
data.URL = URL;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and
  contributors. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * objects inside the RSSItem object
 *
 * @private
 */
function RSSEnclosure (encElement)
{
  if (!encElement)
  {
    this.url = null;
    this.length = null;
    this.type = null;
  }
  else
  {
    this.url = encElement.getAttribute ("url");
    this.length = encElement.getAttribute ("length");
    this.type = encElement.getAttribute ("type");
  }
}

/**
 * @private
 */
function RSSGuid (guidElement)
{
  if (!guidElement)
  {
    this.isPermaLink = null;
    this.value = null;
  }
  else
  {
    this.isPermaLink = guidElement.getAttribute ("isPermaLink");
    this.value = guidElement.textContent;
  }
}

/**
 * @private
 */
function RSSSource (souElement)
{
  if (!souElement)
  {
    this.url = null;
    this.value = null;
  }
  else
  {
    this.url = souElement.getAttribute ("url");
    this.value = souElement.textContent;
  }
}

/**
 *  @class
 *
 *  @author David Thevenin
 *
 *  @constructor
 *  Main constructor
 *
 *  @memberOf vs.data
 *
 * @param {Object}
 */
function RSSItem (itemxml)
{
  var properties =
    ["title", "link", "description", "author", "comments", "pubDate"];
  var _properties =
    ["_title", "_link", "_description", "_author", "_comments", "_pub_date"];

  var tmpElement = null;
  for (var i = 0; i < properties.length; i++)
  {
    tmpElement = itemxml.getElementsByTagName (properties[i])[0];
    if (tmpElement)
    {
      this [_properties [i]] = tmpElement.textContent;
    }
  }

  this._category =
    new RSSCategory (itemxml.getElementsByTagName ("category")[0]);

  this._enclosure =
    new RSSEnclosure (itemxml.getElementsByTagName ("enclosure")[0]);

  this._guid = new RSSGuid (itemxml.getElementsByTagName ("guid")[0]);
  this._source = new RSSSource (itemxml.getElementsByTagName ("source")[0]);
  this._image = new RSSImage (itemxml.getElementsByTagName ("content")[0]);

  if (this._image) {this._image_url = this.image.url};
}

RSSItem.prototype = {
  //required

  /**
   *
   * @protected
   * @type {String}
   */
  _title : '',

  /**
   *
   * @protected
   * @type {String}
   */
  _link : '',

  /**
   *
   * @protected
   * @type {String}
   */
  _description : '',

  //optional vars

  /**
   *
   * @protected
   * @type {String}
   */
  _author : '',

  /**
   *
   * @protected
   * @type {String}
   */
  _comments : '',

  /**
   *
   * @protected
   * @type {String}
   */
  _pub_date : '',

  //optional objects
  /**
   *
   * @protected
   * @type {RSSCategory}
   */
  _category : null,

  /**
   *
   * @protected
   * @type {RSSEnclosure}
   */
  _enclosure : null,

  /**
   *
   * @protected
   * @type {RSSGuid}
   */
  _guid : null,

  /**
   *
   * @protected
   * @type {RSSSource}
   */
  _source : null,

  /**
   *
   * @protected
   * @type {RSSImage}
   */
  _image: null,

  /**
   *
   * @protected
   * @type {string}
   */
  _image_url: '',

  /**
   *
   * @protected
   * @type {string}
   */
  _category: null,

  /**
   * @return {String}
   * @function
   * @private
   */
  toString : function ()
  {
    return this.title;
  }
};

util.defineClassProperties (RSSItem, {

'title': {
  /**
   * Getter for the item title
   * @name vs.data.RSSItem#title
   * @type string
   */
  get : function ()
  {
    return this._title;
  }
},
'link': {
  /**
   * Getter for the item link
   * @name vs.data.RSSItem#link
   * @type string
   */
  get : function ()
  {
    return this._link;
  }
},
'description': {
  /**
   * Getter for the item description
   * @name vs.data.RSSItem#description
   * @type string
   */
  get : function ()
  {
    return this._description;
  }
},

'author': {
  /**
   * Getter for the item author
   * @name vs.data.RSSItem#author
   * @type string
   */
  get : function ()
  {
    return this._author;
  }
},

'comments': {
  /**
   * Getter for the item comments
   * @name vs.data.RSSItem#comments
   * @type string
   */
  get : function ()
  {
    return this._comments;
  }
},

'pubDate': {
  /**
   * Getter for the item pubDate
   * @name vs.data.RSSItem#pubDate
   * @type string
   */
  get : function ()
  {
    return this._pub_date;
  }
},

'category': {
  /**
   * Getter for the item category
   * @name vs.data.RSSItem#category
   * @type RSSCategory
   */
  get : function ()
  {
    return this._category;
  }
},

'enclosure': {
  /**
   * Getter for the item enclosure
   * @name vs.data.RSSItem#enclosure
   * @type RSSEnclosure
   */
  get : function ()
  {
    return this._enclosure;
  }
},

'guid': {
  /**
   * Getter for the item guid
   * @name vs.data.RSSItem#guid
   * @type RSSGuid
   */
  get : function ()
  {
    return this._guid;
  }
},

'source': {
  /**
   * Getter for the item source
   * @name vs.data.RSSItem#source
   * @type RSSSource
   */
  get : function ()
  {
    return this._source;
  }
},

'image': {
  /**
   * Getter for the image information
   * @name vs.data.RSSItem#image
   * @type RSSImage
   */
  get : function ()
  {
    return this._image;
  }
},
'imageUrl': {
  /**
   * Getter for the image url
   * @name vs.data.RSSItem#imageUrl
   * @type string
   */
  get : function ()
  {
    return this._image_url;
  }
}
});

/**
 * objects inside the RSSChannel object
 *
 * @private
 */
function RSSCategory (catElement)
{
  if (!catElement)
  {
    this.domain = null;
    this.value = null;
  }
  else
  {
    this.domain = catElement.getAttribute ("domain");
    this.value = catElement.textContent;
  }
}

/**
 * object containing RSS image tag info
 *
 * @private
 */
function RSSImage (imgElement)
{
  if (!imgElement)
  {
    this.url = null;
    this.link = null;
    this.width = null;
    this.height = null;
    this.description = null;
  }
  else
  {
    imgAttribs = ["url", "title", "link", "width", "height", "description"];

    for (var i = 0; i < imgAttribs.length; i++)
    {
      if (imgElement.getAttribute (imgAttribs[i]))
      {
        this [imgAttribs [i]] = imgElement.getAttribute (imgAttribs[i]);
      }
    }
  }
}

/**
 * object containing the parsed RSS 2.0 channel
 *
 * @private
 */
function RSSChannel (rssFeed, rssxml)
{
  rssFeed._items = [];

  if (!rssxml)
  {
    console.error ("Failed to parse rss document that is null.");
    return false;
  }

  var chanElement = rssxml.getElementsByTagName ("channel")[0];
  var itemElements = rssxml.getElementsByTagName ("item");

  for (var i = 0; i < itemElements.length; i++)
  {
    Item = new RSSItem (itemElements[i]);
    rssFeed._items.push (Item);
    //chanElement.removeChild(itemElements[i]);
  }

  var _properties = ["_title", "_link", "_description", "_language",
     "_copyright", "_managing_editor", "_web_master", "_pub_date",
     "_last_build_date", "_generator", "_docs", "_ttl", "_rating"];

  var properties = ["title", "link", "description", "language", "copyright",
     "managingEditor", "webMaster", "pubDate", "lastBuildDate", "generator",
     "docs", "ttl", "rating"];

  var tmpElement = null;

  for (var i = 0; i < properties.length; i++)
  {
    tmpElement = chanElement.getElementsByTagName (properties [i]) [0];

    if (tmpElement)
    {
      rssFeed [_properties [i]] = tmpElement.textContent;
    }
  }

  rssFeed._category =
    new RSSCategory (chanElement.getElementsByTagName ("category")[0]);

  rssFeed._image =
    new RSSImage (chanElement.getElementsByTagName ("image")[0]);
};

/**
 *  The RSSFeed class
 *
 *  @extends vs.core.EventSource
 * @name vs.data.RSSFeed
 *
 *  @class
 *  An RSSFeed should not be instantiated. Its the output of RSSRequester
 *  object after a rss feed is loaded and parsed.
 *
 *  @author David Thevenin
 *  @see RSSRequester
 *  @constructor
 *   Creates a new vs.data.RSSFeed.
 *
 * @param {Object} config the configuration structure [mandatory]
*/
var RSSFeed = function (config)
{
  this.parent = vs.core.EventSource;
  this.parent (config);
  this.constructor = RSSFeed;
};

RSSFeed.prototype = {

 /*********************************************************
 *                  private data
 *********************************************************/

  /**
   *
   * @protected
   * @type {Array}
   */
  _items: null,

  /**
   *
   * @protected
   * @type {string}
   */
  _title: null,

  /**
   *
   * @protected
   * @type {string}
   */
  _link: null,

  /**
   *
   * @protected
   * @type {string}
   */
  _description: null,

  /**
   *
   * @protected
   * @type {string}
   */
  _language: null,

  /**
   *
   * @protected
   * @type {string}
   */
  _copyright: null,

  /**
   *
   * @protected
   * @type {string}
   */
  _managing_editor: null,

  /**
   *
   * @protected
   * @type {string}
   */
  _web_master: null,

  /**
   *
   * @protected
   * @type {string}
   */
  _pub_date: null,

  /**
   *
   * @protected
   * @type {string}
   */
  _last_build_date: null,

  /**
   *
   * @protected
   * @type {string}
   */
  _generator: null,

  /**
   *
   * @protected
   * @type {string}
   */
  _docs: null,

  /**
   *
   * @protected
   * @type {string}
   */
  _ttl: null,

  /**
   *
   * @protected
   * @type {string}
   */
  _rating: null,
};
util.extendClass (RSSFeed, core.EventSource);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (RSSFeed, {
'items': {
   /**
   * Getter for the result RSS
   * @name vs.data.RSSFeed#items
   * @type Array
   */
  get : function ()
  {
    return this._items;
  }
},
'title': {
  /**
   * Getter for the feed language
   * @name vs.data.RSSFeed#title
   * @type string
   */
  get : function ()
  {
    return this._title;
  }
},
'link': {
  /**
   * Getter for the feed copyright
   * @name vs.data.RSSFeed#link
   * @type string
   */
  get : function ()
  {
    return this._link;
  }
},
'description': {
  /**
   * Getter for the feed managingEditor
   * @name vs.data.RSSFeed#description
   * @type string
   */
  get : function ()
  {
    return this._description;
  }
},
'language': {
  /**
   * Getter for the feed language
   * @name vs.data.RSSFeed#language
   * @type string
   */
  get : function ()
  {
    return this._language;
  }
},
'copyright': {
  /**
   * Getter for the feed copyright
   * @name vs.data.RSSFeed#copyright
   * @type string
   */
  get : function ()
  {
    return this._copyright;
  }
},
'managingEditor': {
  /**
   * Getter for the feed managingEditor
   * @name vs.data.RSSFeed#managingEditor
   * @type string
   */
  get : function ()
  {
    return this._managing_editor;
  }
},
'webMaster': {
  /**
   * Getter for the feed webMaster
   * @name vs.data.RSSFeed#webMaster
   * @type string
   */
  get : function ()
  {
    return this._web_master;
  }
},
'pubDate': {
  /**
   * Getter for the feed pubDate
   * @name vs.data.RSSFeed#pubDate
   * @type string
   */
  get : function ()
  {
    return this._pub_date;
  }
},
'lastBuildDate': {
  /**
   * Getter for the feed lastBuildDate
   * @name vs.data.RSSFeed#lastBuildDate
   * @type string
   */
  get : function ()
  {
    return this._last_build_date;
  }
},
'generator': {
  /**
   * Getter for the feed generator
   * @name vs.data.RSSFeed#generator
   * @type string
   */
  get : function ()
  {
    return this._generator;
  }
},
'docs': {
  /**
   * Getter for the feed docs
   * @name vs.data.RSSFeed#docs
   * @type string
   */
  get : function ()
  {
    return this._docs;
  }
},
'rating': {
  /**
   * Getter for the feed rating
   * @name vs.data.RSSFeed#rating
   * @type string
   */
  get : function ()
  {
    return this._rating;
  }
},
'image': {
  /**
   * Getter for the image information
   * @name vs.data.RSSFeed#image
   * @type Object
   */
  get : function ()
  {
    return this._image;
  }
},
'imageUrl': {
  /**
   * Getter for the image url
   * @name vs.data.RSSFeed#imageUrl
   * @type string
   */
  get : function ()
  {
    return this._image_url;
  }
},
'category': {
  /**
   * Getter for the feed rating
   * @name vs.data.RSSFeed#category
   * @type string
   */
  get : function ()
  {
    return this._category;
  }
}
});

/**
 *  The RSSRequester class
 *
 *  @extends RSSFeed
 * @name vs.data.RSSRequester
 *  @events rssload, rssloaderror
 *  @class
 *  Instantiate a RSSRequester when you want load a rss feeds.
 *  The system works asynchronously
 *
 * The delegate that should be implemented:
 *  <ul>
 *    <li/>performAlternateRequest : function ()
 *  </ul>
 *  This delegate make a request if the HTTpRequest failed for instance
 *  because of Cross Domain issue. The defautl delegate use Yahoo Pipes as
 *  alternate request.
 *
 *  @example
 *  var request = new RSSRequester ({});
 *  request.bind ('rssload', this, 'onRssload');
 *  request.bind ('rssloaderror', this, 'onError');
 *
 *  request.url = "http://feeds.arstechnica.com/arstechnica/index.xml";
 *  request.loadRSS ();
 *
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new RSSRequester.
 *
 * @param {Object} config the configuration structure [mandatory]
*/
var RSSRequester = function (config)
{
  this.parent = RSSFeed;
  this.parent (config);
  this.constructor = RSSRequester;

  this._rss = this;
};

RSSRequester.prototype = {

 /*********************************************************
 *                  private data
 *********************************************************/

  /**
   *
   * @protected
   * @type {string}
   */
  _url: '',

  /**
   *
   * @protected
   * @type {RSSFeed}
   */
  _rss: null,

 /*********************************************************
 *                  RSS management
 *********************************************************/

  /**
   * @protected
   * @name vs.data.RSSRequester#initComponent
   * @function
   */
  initComponent : function ()
  {
    RSSFeed.prototype.initComponent.call (this);

    this._xhr = new core.HTTPRequest ();
    this._xhr.init ();
    this._xhr.bind ('xmlload', this, this.processRSS);
    this._xhr.bind ('loaderror', this, this.processError);
  },

  /**
   * @protected
   * @name vs.data.RSSRequester#destructor
   * @function
   */
  destructor : function ()
  {
    this._xhr.unbind ('xmlload', this, this.processRSS);
    this._xhr.unbind ('loaderror', this, this.processError);
    free (this._xhr);

    RSSFeed.prototype.destructor.call (this);
  },

  /**
   * start RSS load
   *
   * @name vs.data.RSSRequester#loadRSS
   * @function
   */
  loadRSS : function ()
  {
    this._xhr.send ();
  },

  /**
   * processes the received rss xml
   *
   * @name vs.data.RSSRequester#processRSS
   * @function
   *
   * @private
   * @param Text rsstxt
   * @param Document rssxml
   */
  processRSS: function (event)
  {
    var rssDocument = event.data;
    if (!rssDocument)
    {
      rssDocument = new DOMParser ().parseFromString
        (this._xhr.responseText, 'application/xml');

      if (!rssDocument)
      {
        console.error ("Failed to parse rss document that is null.");
        this.propagate ('rssloaderror', 'document null.');
        return false;
      }
    }

    RSSChannel (this, rssDocument);
    this.propagate ('rssload', this);
    this.outPropertyChange ();
  },

  /**
   * processes the received rss xml
   *
   * @name vs.data.RSSRequester#processRSS
   * @function
   *
   * @private
   * @param Text rsstxt
   * @param Document rssxml
   */
  processError: function (event)
  {
    if (event && event.data && event.data.status === 'failed')
    {
      if (this.performAlternateRequest) this.performAlternateRequest ();
      else this.propagate ('rssloaderror');
    }
    else this.propagate ('rssloaderror');
  },

  /**
   * propertiesDidChange
   * @protected
   *
   * @name vs.data.RSSRequester#propertiesDidChange
   * @function
   */
  propertiesDidChange : function ()
  {
    this.loadRSS ();
    
    // stop the propagation, it will restart when RSS data will be loaded
    return true; 
  },

/********************************************************************
                  delegate implementation
********************************************************************/
  /**
   * @protected
   *
   */
   performAlternateRequest : _performAlternateYahooPipeRequest,
};
util.extendClass (RSSRequester, RSSFeed);

function _performAlternateYahooPipeRequest ()
{
  var ajaxp = new core.AjaxJSONP ().init ();
  ajaxp.url = "http://pipes.yahoo.com/pipes/pipe.run?" +
    "_id=9oyONQzA2xGOkM4FqGIyXQ&" +
    "_render=json&" +
    "feed=" + escape (this._url);

  ajaxp.clbParamName = '_callback';

  ajaxp.bind ('jsonload', this, function (event)
    {
      var data = event.data;
      if (!data || !data.value || !data.value.items)
      {
        this.propagate ('rssloaderror', 'document null.');
        return;
      }
      var value = data.value;

      this._pub_date = value.pubDate;
      this._items = [];

      itemElements = value.items;
      for (var i = 0; i < itemElements.length; i++)
      {
//        Item = new RSSItem (itemElements[i]);
        this._items.push (itemElements[i]);
      }
      this.propagate ('rssload', this);
      this.outPropertyChange ();
    });
  ajaxp.bind ('loaderror', this, function (data)
    {
      this.propagate ('rssloaderror');
    });

  ajaxp.send ();
}

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (RSSRequester, {
  "url": {

    /**
     * Setter for the rss's url
     * @name vs.data.RSSRequester#url
     * @type String
     */
    set : function (v)
    {
      if (!util.isString (v)) { return; }

      this._url = v;
      this._xhr.url = v;
    }
  },

  'rss': {

    /**
     * Getter for the result rss feeds
     * @name vs.data.RSSRequester#rss
     * @type RSSFeed
     */
    get : function ()
    {
      return this._rss;
    }
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
data.RSSFeed = RSSFeed;
data.RSSRequester = RSSRequester;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The GoogleSearch class
 *
 *  @extends vs.core.EventSource
 *  @name vs.data.GoogleSearch
 *  @class vs.data.GoogleSearch
 *  provides an API to search information with the Google search engine.
 *  It allow to search using the local or the video search envines.
 *  <p>
 * Delegates:
 *  <ul>
 *  </ul>
 *  <p>
 * Events:
 *  <ul> engineload : after setSearchEngine call, when the engines are loaded
 *       and usable.
 *  </ul>
 *  <p>
 *  
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new GoogleSearch.
 *
 * @param {Object} config the configuration structure [mandatory]
 */
var GoogleSearch = function (config)
{
  this.parent = core.EventSource;
  this.parent (config);
  this.constructor = GoogleSearch;
  
  GoogleSearch.loadService (this);

  this.ERROR_CODE = 0;
  this._addresses = [];
  this._position = [];
}

/** @private */
GoogleSearch.loadService = function (obj)
{
  if (!GoogleSearch.__google_loaded__)
  {
    if (!GoogleSearch.__google_wait_loaded__)
    {
      GoogleSearch.__google_wait_loaded__ = true;
      var url = "http://www.google.com/jsapi?key=" + GoogleSearch.key + "&callback=vs.data.GoogleSearch.__on_loaded";

      util.importFile (url, null, null, 'js');
    }
    
    if (obj)
    {
      GoogleSearch._to_finish_init.push (obj);
    }
  }
}

/**
 * @name vs.data.GoogleSearch.key
 * @type {String}
 */
GoogleSearch.key = " ABQIAAAAE4BGaIh0t-7l9PDR7PA0rRR6KW34AlT62yZeC298tyhOjAL-9hQQpk22pW6ZfaCFEr3zjz2Q8rjqAw";

GoogleSearch.__google_wait_loaded__ = false;
GoogleSearch.__google_loaded__ = false;
GoogleSearch._to_finish_init = new Array ();

/**
 * The Google Local Search allows you to execute map searches.
 * @name vs.data.GoogleSearch.LOCAL_SEARCH_ENGINE
 * @const
 */
GoogleSearch.LOCAL_SEARCH_ENGINE = 1;

/**
 * The Google Video Search allows you to execute searches and receive results 
 * from the Google Video Search service.
 * @name vs.data.GoogleSearch.VIDEO_SEARCH_ENGINE
 * @const
 */
GoogleSearch.VIDEO_SEARCH_ENGINE = 2;


/** @private */
GoogleSearch.__on_loaded = function ()
{
  google.load ('search', '1', 
    {nocss: true, callback:vs.data.GoogleSearch.__on_search_loaded});
}

/** @private */
GoogleSearch.__on_search_loaded = function ()
{
  var i, l; 
  
  GoogleSearch.__google_loaded__ = true;
  GoogleSearch.__google_wait_loaded__ = false;
  
  for (i = 0, l = GoogleSearch._to_finish_init.length; i < l; i ++)
  {
    GoogleSearch._to_finish_init [i].finishInit ();
  }
  
  GoogleSearch._to_finish_init = null;
}

/**
 * @name vs.data.GoogleSearch.ERROR_CODE_STR
 * @type {Array}
 */
GoogleSearch.ERROR_CODE_STR = [
 /** 0  */ 'No error',
 /** 1  */ 'Unknown error',
 /** 2  */ 'Unvalid parameters data',
 /** 3  */ 'Error with google server',
 /** 4  */ 'Connexion error',
 /** 5  */ 'Unvalid google response'
];

GoogleSearch.prototype = {
  
  __local_search : undefined,
  __video_search : undefined,
  __init_ok : false,
  __engine_to_init : 0,
  __end_init_clb : null,
  _engine_loaded : false,
  _str_address: '',
  _addresses: null,
  _position: null,
 
  /**
   * @private
   * @function
   */
  finishInit : function ()
  {
    this.__init_ok = true;
    if (this.__engine_to_init)
    {
      this.setSearchEngine (this.__engine_to_init);
      this.__engine_to_init = 0;
    }
  },
  
  /**
   * Initialize the Search Engine (local and/or video)
   *
   * @name vs.data.GoogleSearch#setSearchEngine
   * @function
   * @param {number} code the search engine code 
   * (GoogleSearch.VIDEO_SEARCH_ENGINE || GoogleSearch.LOCAL_SEARCH_ENGINE)
   */
  setSearchEngine : function (code)
  {
    if (!this.__init_ok)
    {
      this.__engine_to_init = code;
      return;
    }
    
    if ((code | GoogleSearch.LOCAL_SEARCH_ENGINE) && !this.__local_search)
    {
      this.__local_search = new google.search.LocalSearch ();
      this.__local_search.setResultSetSize 
        (google.search.Search.SMALL_RESULTSET);
      this.__local_search.setNoHtmlGeneration ();
    }
    if ((code | GoogleSearch.VIDEO_SEARCH_ENGINE) && !this.__video_search)
    {
      this.__video_search = new google.search.VideoSearch ();
      this.__video_search.setResultSetSize 
        (google.search.Search.SMALL_RESULTSET);
      this.__video_search.setNoHtmlGeneration ();
    }
    this._engine_loaded = true;
    this.propagate ('engineload');
    this.outPropertyChange ('engineLoaded');
  },
  
/********************************************************************
                   Video Method
********************************************************************/


/********************************************************************
                   Local Search methods
********************************************************************/

  /**
   * @private
   * @function
   */
  _newGoogleLocalSearch : function (data, clb)
  {
    var self = this;
    this.__local_search.setSearchCompleteCallback (this, function () {
      clb.call (self, self.__local_search.results);
    })
    
    if (!data || typeof (data) !== 'string')
    {
      this.ERROR_CODE = 2;
      clb.call (self, null);
      return;
    }
    
    // execute  search
    this.__local_search.execute (data);
  },
  
  /**
   * @private
   * @function
   */
  _googleLocalSearch : function (data, clb)
  {
    if (this.__local_search)
    {
      this._newGoogleLocalSearch (data, clb);
      return;
    }
    
    if (!data || typeof (data) !== 'string')
    {
      this.ERROR_CODE = 2;
      clb.call (this, null);
      return;
    }
    
    // 1) build request
    var url = "http://ajax.googleapis.com/ajax/services/search/local?v=1.0&q=" + data;
    
    // 2) build XML HTTP object
    var xmlhttp = new XMLHttpRequest ();
    
    // 3) send the request
    xmlhttp.open ("GET", url, false);
    xmlhttp.send (null);
    
    // 4) parse the result.
    if (xmlhttp.readyState === 4)
    {
      var coord_data = eval ('(' + xmlhttp.responseText + ')');
      if (coord_data.responseStatus !== 200)
      {
        this.ERROR_CODE = 3;
        clb.call (this, null);
        return;
      }
      
      if (!coord_data.responseData)
      {
        this.ERROR_CODE = 5;
        clb.call (this, null);
        return;
      }
      
      clb.call (this, coord_data.responseData);
      return;
    }

    this.ERROR_CODE = 4;
    clb.call (this, null);
    return;
  },
  
  /*
   * This is a synchronous function.
   *
   * @name vs.data.GoogleSearch#GPSCoordinateToAddress
   * @function
   *
   * @param {array} coord the GPS coordinate
   * @return {object} the associated Address
   * {title, addressLine, streetAddress, city, region, country_code, postalCode}
   * @return {Object} ctx
   */
  GPSCoordinateToAddress : function (coord, clb, ctx)
  {
    if (!this.__local_search)
    {
      console.error ("The local search engine is not initialized");
      return;
    }
    if (!ctx) { ctx = this; }

    // 0) verify parameters
    if (!coord || !coord.length)
    {
      this.ERROR_CODE = 2;
      clb.call (ctx, null);
      return;
    }
    
    // 1) build request
//    var sep = "%2C%20";
    var sep = ",";
    var data = coord [0] + sep + coord [1];
    var self = this;
    var search_clb = function (results)
    {
      if (!results)
      {
        this.ERROR_CODE = 5;
        clb.call (ctx, null);
        return;
      }
      
      if (results.length === 0 || !results[0])
      {
        this.ERROR_CODE = 5;
        clb.call (ctx, null);
        return;
      }
      self._addresses = [];
      var result = {
        title: '',
        addressLine: '',
        streetAddress: '',
        city: '',
        region: '',
        country_code: '',
        postalCode: 0
      };
      result.title = results[0].titleNoFormatting;
      result.addressLine = results[0].addressLines.join (', ');
      result.streetAddress = results[0].streetAddress;
      result.city = results[0].city;
      result.region = results[0].region;
      result.country_code = results[0].country;
      result.postalCode = results[0].postalCode;
      result.locale = self.countryToLocal (result.country_code);
      
      self._addresses.push (result);
      clb.call (ctx, result);
      self.outPropertyChange ('addresses');
    };
    this._googleLocalSearch (data, search_clb);
  },
  
  /**
   * @private
   * @function
   */
  countryToLocal : function (code)
  {
    switch (code)
    {
      case 'US': return 'en_US';
      case 'GB': return 'en_GB';
      case 'FR': return 'fr_FR';
      case 'CA': return 'fr_CA';
      case undefined: return 'en_US'; 
      default: return code.toLowerCase ();
    }
  },
  
  /*
   *
   * @name vs.data.GoogleSearch#addressToGPSCoordinate
   * @function
   *
   * @param {string} the address
   * @return {array} the associated coord the GPS coordinate
   * @return {Object} ctx
   */
  addressToGPSCoordinate : function (address, clb, ctx)
  {
    if (!this.__local_search)
    {
      console.error ("The local search engine is not initialized");
      return;
    }
    var result = [0, 0];
    
    if (!ctx) { ctx = this; }
    
    // 0) verify parameters
    if (!address || typeof (address) !== 'string')
    {
      this.ERROR_CODE = 2;
      clb.call (ctx, null);
      return;
    }
    
    // 1) build request
    var data = '"' + address + '"';
    
    var self = this;
    var search_clb = function (results)
    {
      if (!results) {return;}
      
      if (!results[0])
      {
        this.ERROR_CODE = 5;
        clb.call (ctx, null);
        return;
      }
      
      result [0] = parseFloat (results[0].lat);
      result [1] = parseFloat (results[0].lng);
      
      self._position = result;
      
      clb.call (ctx, result.slice ());
      self.outPropertyChange ('position');
    }
    this._googleLocalSearch (data, search_clb);
  },
  
  /**
   *
   * @name vs.data.GoogleSearch#searchAddress
   * @function
   *
   * @param {string} the [incomplete] address
   * @return {array} the of address
   * @return {Object} ctx
   */
  searchAddress : function (info, clb, ctx)
  {
    if (!this.__local_search)
    {
      console.error ("The local search engine is not initialized");
      return;
    }
    if (!ctx) { ctx = this; }

    // 0) verify parameters
    if (!info || typeof (info) !== 'string')
    {
      this.ERROR_CODE = 2;
      clb.call (ctx, null);
      return;
    }
    
    // 1) build request
    var data = '"' + info + '"';
    var self = this;
    var search_clb = function (results) {
      self._addresses = [];
      
      if (!results)
      {
        clb.call (ctx, []);
        self.outPropertyChange ('addresses');
        return;
      }
      
      for (var i = 0; i < results.length; i++)
      {
        var entry = {};
        entry.title = results[i].titleNoFormatting;
        entry.addressLine = results[i].addressLines.join (', ');
        entry.streetAddress = results[i].streetAddress;
        entry.city = results[i].city;
        entry.region = results[i].region;
        entry.country_code = results[i].country;
        entry.postalCode = results[i].postalCode;
        
        self._addresses.push (entry);
      }
      
      clb.call (ctx, self._addresses.slice ());
      self.outPropertyChange ('addresses');
    }
    this._googleLocalSearch (data, search_clb);
  }
};
util.extendClass (GoogleSearch, core.EventSource);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (GoogleSearch, {
  "strAddress": {

    /** 
     * Setter for the address to look for.
     * @name vs.data.GoogleSearch#strAddress 
     * @type String
     */ 
    set : function (v)
    {
      if (!util.isString (v)) return;
      
      this._str_address = v;
      var self = this;
      // Full address search
      this.searchAddress (v, function (result) {
        // GPS coordinate search
        self.addressToGPSCoordinate (v, function (coord) {
        }, this);
      }, this);
    }
  },
  
  "addresses": {
    /** 
     * Getter to retrieve addresses matching a strAddress or a coordinate
     * @name vs.data.GoogleSearch#addresses 
     * @type Array
     */ 
    get : function (v)
    {
      return this._addresses;
    }
  },
  
  'position': {
    /** 
     * Getter/setter to get a GPS coordinate associate to a strAddress or for
     * looking the address associate to this coordinate
     * @name vs.data.GoogleSearch#position 
     * @type Array
     */ 
    set : function (v)
    {
      if (!util.isArray (v) || v.length !== 2) return;
      if (!util.isNumber (v[0]) || !util.isNumber (v[1])) return;
      
      // Full address search
      this.GPSCoordinateToAddress (v, function (result) {}, this);
    },
    
    /**
     * @ignore
     */ 
    get : function ()
    {
      return this._position;
    }
  },
  
  'engineLoaded': {
    /** 
     * Return true if the Search Engine is loaded, false other wise.
     * The Component can be used only if the search engine is loaded.
     * @name vs.data.GoogleSearch#engineLoaded 
     * @type RSSFeed
     */ 
    get : function ()
    {
      return this._engine_loaded;
    }
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
data.GoogleSearch = GoogleSearch;

})(window);/** @license
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

(function (window, undefined) {

var document = window.document;

/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/********************************************************************
                   
*********************************************************************/
/** @private */
var vs = window.vs,
  util = vs.util,
  core = vs.core,
  ui = vs.ui,
  fx = vs.fx,
  setElementTransform = util.setElementTransform,
  getElementTransform = util.getElementTransform,
  DeviceConfiguration = core.DeviceConfiguration,
  SUPPORT_3D_TRANSFORM = vs.SUPPORT_3D_TRANSFORM;

/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and
  contributors. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  @class
 *  vs.ui.Template is GUI template system you can use to create the view
 *  of component for instance. <br/>
 *  A template is a HTML text fragment containing template tags. There is two
 *  ways to use template :
 * <ul>
 *   <li> By expanding tags using values provides in an Object</li>
 *   <li> By generating a vs.ui.View with properties linked to tags</li>
 * </ul>
 *  @author David Thevenin
 * <br/>
 * <br/>
 * Typical template description:
 * <pre class='code'>
 *  var str = '&lt;span style="${style}"&gt;name:${lastname}, \
 *     ${firstname}&lt;/span&gt;';
 * </pre>
 *
 * Expanding the template:
 * <pre class='code'>
 *  var myTemplate = new Template (str);
 * <br/>
 *  var values = {
 *    lastname : "Doe",
 *    firstname : "John",
 *    style : "color:blue"
 *  };
 * <br/>
 *  console.log (myTemplate.apply (values));
 *  // -> &lt;span style="color:blue"&gt;name:Doe,John&lt;/span&gt;
 * </pre>
 *
 * Generating a vs.ui.View from the template:
 * <pre class='code'>
 *  var myTemplate = new Template (str);
 * <br/>
 *  var myView = myTemplate.compileView ();
 * <br/>
 *  myApp.add (myView); //|| document.body.appendChild (myView.view);
 * <br/>
 *  // property changes, automatically update the DOM
 *  myView.lastname = "Doe";
 *  myView.firstname = "John";
 *  myView.style = "color:blue";
 * <br/>
 * </pre>
 *
 *  @constructor
 *  Main constructor
 *
 * @name vs.ui.Template
 *
 * @param {string} config the configuration structure [mandatory]
 */
function Template (str) {
  this._str = str;
}

/** @name vs.ui.Template# */
Template.prototype = {
  /**
   * @protected
   * @Array
   */
  _str : null,
  _regexp_templ : /\$\{((([\w\-]+)(\.([\w\.]*)+)?)|@)\}/g,
  _regexp_index : /\$\{\*([\d]+)\*\}/g,
  _shadow_view : null,

  /***************************************************************

  ***************************************************************/

  /**
   * HTML String of the template <p>
   *
   * @name vs.ui.Template#toString
   * @function
   *
   * @return {String} HTML String of the template
   */
  toString : function () {
    return this._str;
  },

  /**
   *
   * @name vs.ui.Template#compileView
   * @function
   *
   * @param {String} className The view class Name. By default vs.ui.View.
   *                 [optional]
   * @param {Object|Model} data The view data configuration | model
   *                 [optional]
   * @return {vs.ui.View} the View
   */
  compileView : function (className, data) {
    if (!this._shadow_view) {
      this._shadow_view = _pre_compile_shadow_view (this, className);
    }
    
    var obj = _instanciate_shadow_view (this._shadow_view, data);

    // Clone data
    obj.__shadow_view = this._shadow_view;
    // Clone surcharge
    obj.clone = _template_view_clone.bind (obj);
    obj._clone = _template_view__clone.bind (obj);

    return obj;
  },

  /**
   *
   * @name vs.ui.Template#compileView
   * @function
   * @private
   *
   * @param {vs.ui.View} comp Extends a component with this template
   *                 [mandatory]
   * @return {HTMLElement} The component view
   */
   __extend_component : function (comp) {
    if (!this._shadow_view) {
      this._shadow_view = _pre_compile_shadow_view (this);
    }
    
    var new_node = this._shadow_view.__node.cloneNode (true);
    comp.view = new_node;
  
    _instrument_component (comp, this._shadow_view, new_node);
  
    // Clone data
    comp.__shadow_view = this._shadow_view;
    // Clone surcharge
    comp.clone = _template_view_clone.bind (comp);
    comp._clone = _template_view__clone.bind (comp);

    return new_node;
  },

  /**
   * Returns an HTML String of this template with the specified values.
   *
   * @example
   *  myTemplate.apply (['John', 25]);
   *
   * @name vs.ui.Template#apply
   * @function
   *
   * @param {Object} values The template values.
   * @return {String} The HTML string
   */
  apply : function (values) {
    if (!values) return this._str;

    function replace_fnc (str, key, p1, p2, offset, html) {
      var value = values [key], key, keys, i, l;

      if (offset) {
        keys = p1.split ('.'); i = 1; l = keys.length;
        value = values [keys[0]];
        while (value && i < l) value = value [keys [i++]];
      }

      return value;
    }

    return this._str.replace (this._regexp_templ, replace_fnc);
  }
};

/**
 * @private
 */
function _resolveClass (name) {
  if (!name) { return null; }

  var namespaces = name.split ('.');
  var base = window;
  while (base && namespaces.length) {
    base = base [namespaces.shift ()];
  }

  return base;
}

/**
 * @private
 */
var _template_view_clone = function (config, cloned_map) {
  if (!config) { config = {}; }
  
  config.node =
    (this.__shadow_view)?this.__shadow_view.__node.cloneNode (true):
    (config.node)?config.node:this.view.cloneNode (true);
  
  return core.EventSource.prototype.clone.call (this, config, cloned_map);
};

/**
 * @private
 */
var _template_view__clone = function (obj, cloned_map) {
  ui.View.prototype._clone.call (this, obj, cloned_map);

  _instrument_component (obj, this.__shadow_view, obj.view);

  // Clone data
  obj.__shadow_view = this.__shadow_view;
  // clone surcharge
  obj.clone = _template_view_clone.bind (obj);
  obj._clone = _template_view__clone.bind (obj);
  // rewrite properties to point cloned nodes
};

/**
 * @private
 */
function _instrument_component (obj, shadow_view, node) {

  /**
   * @private
   */
  var _create_node_property = function (view, prop_name, nodes) {
    var desc = {}, _prop_name = '_' + util.underscore (prop_name);

    desc.set = (function (nodes, prop_name, _prop_name) {
      return function (v) {
        var i = 0, node, l = nodes.length, r;
        this [_prop_name] = v;
        for (; i < l; i++) {
          node = nodes [i];
          if (node.nodeType === 3) { //TEXT_NODE
            node.data = v;
          }
          else if (node.nodeType === 2) {
            r = eval(node.__attr_eval_str);
            //ATTRIBUTE_NODE
            if (node.name == 'value' && node.ownerElement.tagName == 'INPUT') {
              node.ownerElement.value = r;
            }
            //ATTRIBUTE_NODE
            else {
              node.value = r;
            }
          }
        }
        if (prop_name == '_$_') this.propertyChange ();
        else this.propertyChange (prop_name);
      };
    }(nodes, prop_name, _prop_name));

    desc.get = (function (_prop_name) {
      return function () {
        return this[_prop_name];
      };
    }(_prop_name));

    // save this string for clone process
//    desc.set.__vs_attr_eval_str = attr_eval_str;

    view.defineProperty (prop_name, desc);
  };

  /**
   * @private
   */
  var _create_iterate_property =
    function (obj, prop_name, shadow_view, parentElement) {
    var desc = {}, _prop_name = '_' + util.underscore (prop_name);
      
    desc.set = (function (prop_name, _prop_name, shadow_view, parentElement) {
      return function (v) {
        if (!util.isArray (v)) { return; }
      
        var i = 0, l = v.length, obj;
        this [_prop_name] = v;
        util.removeAllElementChild (parentElement);
        for (; i < l; i++) {
          obj = _instanciate_shadow_view (shadow_view, v [i]);
          parentElement.appendChild (obj.view);
        }

        this.propertyChange (prop_name);
      };
    }(prop_name, _prop_name, shadow_view, parentElement));

    desc.get = (function (_prop_name) {
      return function () {
        return this[_prop_name];
      };
    }(_prop_name));

    obj.defineProperty (prop_name, desc);
  };

  /**
   * @private
   */
  var _createPropertiesToObject = function (obj, ctx, view_node) {
    var node_ref = [];

    // configure properties
    
    // Properties pointing on a node
    var l = ctx.__all_properties.length;
    while (l--) {
      var prop_name = ctx.__all_properties [l],
        nodes = ctx.__prop_nodes [l],
        paths, nodes_cloned;
      
      if (nodes) {
        paths = _getPaths (ctx.__node, nodes);
        nodes_cloned = _evalPaths (view_node, paths);

        node_ref.push ([prop_name, nodes]);
        if (prop_name === '@') _create_node_property (obj, '_$_', nodes_cloned);
        else _create_node_property (obj, prop_name, nodes_cloned);
      }
    }

    // Iterate Properties
    var l = ctx.__all_properties.length;
    while (l--) {
      var prop_name = ctx.__all_properties [l],
        shadow_view = ctx.__list_iterate_prop [prop_name], paths, nodes_cloned;
      
      if (shadow_view) {
        path = _getPath (ctx.__node, shadow_view.__parent_node);
        node_cloned = _evalPath (view_node, path);

        _create_iterate_property (obj, prop_name, shadow_view, node_cloned);
      }
    }
    obj.__node__ref__ = node_ref;
  };
  
  _createPropertiesToObject (obj, shadow_view, node);
};

/**
 * @private
 */
function _instanciate_shadow_view (shadow_view, data) {
  var new_node = shadow_view.__node.cloneNode (true);
  var obj = new shadow_view.__class ({node: new_node});
  
  _instrument_component (obj, shadow_view, new_node);
  
  obj.init ();
  if (data) {
    obj.configure (data);
  }
  if (obj.isProperty ('_$_')) { obj._$_ = data; }
  
  return obj;
};

/**
 * @private
 */
function _pre_compile_shadow_view (self, className) {
  var shadow_view = {};
  shadow_view.__prop_nodes = [];
  shadow_view.__list_iterate_prop = {};
  shadow_view.__all_properties = [];

  shadow_view.__class = _resolveClass (className);
  if (!util.isFunction (shadow_view.__class)) {
    shadow_view.__class = ui.View;
  }

  /**
   * Replacement function
   * Replace a Template tag into a temporary index code
   * This code will be used to identify DOM nodes
   */
  function replace_fnc (str, key, p1, p2, offset, html) {
    var i = shadow_view.__all_properties.indexOf (key);
    if (i === -1) {
      i = shadow_view.__all_properties.length;
      // a new property is found
      shadow_view.__all_properties.push (key);
    }
    return "\${*" + i + "*}";
  }

  // 1) parse and index the html string
  self._regexp_templ.lastIndex = 0; // reset the regex
  var str = self._str.replace (self._regexp_templ, replace_fnc);

  // 2) the template is indexed, now parse it for generating the
  // DOM fragment
  shadow_view.__node = Template.parseHTML (str);

  /**
   * Attributes parsing function
   */
  function parseAttributes (nodes, ctx) {
    if (!nodes) return;
    var l = nodes.length;
    while (l--) {
      var node_temp = nodes.item (l), result,
        str = node_temp.value, indexs = [], index;

      self._regexp_index.lastIndex = 0;// reset the regex
      result = self._regexp_index.exec (str);
      if (result) {
        while (result) {
          index = parseInt (result[1], 10);
          indexs.push (index);
          if (!ctx.__prop_nodes [index])
          { ctx.__prop_nodes [index] = [node_temp]; }
          else { ctx.__prop_nodes [index].push (node_temp); }
          result = self._regexp_index.exec (str);
        }
        node_temp.value = '';

        for (var i = 0; i < indexs.length; i++) {
          index = indexs [i];
          str = str.replace (
            "${*" + index + "*}",
            "\"+this._" + util.underscore (ctx.__all_properties [index]) + "+\""
          );
        }
        
        node_temp.__attr_eval_str = "\"" + str + "\"";
      }
    }
  }
  
  /**
   * Node parsing function
   * Parse the DOM fragment to retrieve attribute and text node
   * associated to a template tag
   */
  function parseNode (node, ctx) {
    var interate_attr = node.getAttribute ('data-iterate');
    if (interate_attr) {
      var parentElement = node.parentElement;
      parentElement.removeChild (node);
      
      if (ctx.__all_properties.indexOf (interate_attr) === -1) {
        ctx.__all_properties.push (interate_attr);
      }

      var shadow_view = {};
      ctx.__list_iterate_prop [interate_attr] = shadow_view;
      
      shadow_view.__prop_nodes = [];
      shadow_view.__list_iterate_prop = {};
      shadow_view.__parent_node = parentElement;
      shadow_view.__node = node;
      shadow_view.__all_properties = ctx.__all_properties;
      shadow_view.__class = ui.View;
      
      ctx = shadow_view;
    }
    
    /**
     * Nodes parsing function
     */
    function parseNodes (nodes, ctx) {
      if (!nodes) return;
      var l = nodes.length;
      while (l--) {
        var node_temp = nodes.item (l);
        if (node_temp.nodeType === 3) { // TEXT_NODE
          var value = node_temp.data, result, index = 0, i, text_node;

          self._regexp_index.lastIndex = 0;// reset the regex
          // put white space to avoid IE nodeClone removes empty textNode
          node_temp.data = ' ';
          result = self._regexp_index.exec (value);
          while (result) {
            if (result.index) {
              text_node = document.createTextNode
                (value.substring (index, result.index));
              node.insertBefore (text_node, node_temp);
            }

            i = parseInt (result[1], 10);
            if (!ctx.__prop_nodes [i]) {
              ctx.__prop_nodes [i] = [node_temp];
            }
            else {
              ctx.__prop_nodes [i].push (node_temp);
            }
            
            index = result.index + result[0].length;

            result = self._regexp_index.exec (value);
            if (result) {
              // put white space to avoid IE nodeClone removes empty textNode
              text_node = document.createTextNode (' ');
              if (node_temp.nextSibling) {
                node.insertBefore (text_node, node_temp.nextSibling);
              }
              else {
                node.appendChild (text_node);
              }
              node_temp = text_node;
            }
          }
          var end_text = value.substring (index);
          if (end_text) {
            text_node = document.createTextNode (end_text);
            if (node_temp.nextSibling) {
              node.insertBefore (text_node, node_temp.nextSibling);
            }
            else {
              node.appendChild (text_node);
            }
          }
        }
        else if (node_temp.nodeType === 1) { // ELEMENT_NODE
          parseNode (node_temp, ctx);
        }
      }
    }

    parseAttributes (node.attributes, ctx);
    parseNodes (node.childNodes, ctx);
  }
  parseNode (shadow_view.__node, shadow_view);

  return shadow_view;
};

/**
 * @private
 */
var _getPaths = function (root, nodes) {
  var paths = [], i = 0, l = nodes.length, node;
  for (; i < l; i++) {
    node = nodes[i];
    paths.push ([_getPath (root, node), node.__attr_eval_str]);
  }
  return paths;
}

/**
 * @private
 */
var _getPath = function (root, node, path) {
  var count = 1;
  path = path || [];

  // 1) manage node atribute
  if (node.nodeType === 2) {
    if (node.ownerElement) {
      path = _getPath (root, node.ownerElement, path);
    }
    path.push ([2, node.nodeName.toLowerCase ()]);
    return path;
  }

  // 2) current node is the root : stop
  if (root === node) {
    return path;
  }

  // 2) Manage parent
  if (node.parentNode) {
    path = _getPath (root, node.parentNode, path);
  }

  // 1) manage node atribute
  var sibling = node.previousSibling
  while (sibling) {
    if ((sibling.nodeType === 1 || sibling.nodeType === 3) &&
         sibling.nodeName == node.nodeName) {
      count++;
    }
    sibling = sibling.previousSibling;
  }

  path.push ([1, node.nodeName.toLowerCase(), count]);
  return path;
};

/**
 * @private
 */
var _evalPaths = function (root, paths) {
  var nodes = [], i = 0, l = paths.length, path, node;
  for (; i < l; i++) {
    path = paths[i];
    node = _evalPath (root, path[0]);
    node.__attr_eval_str = path[1];
    nodes.push (node);
  }
  return nodes;
}

/**
 * @private
 */
var _evalPath = function (root, path) {
  if (!path || !path.length || !root) {
    return root;
  }

  var info = path.shift (), attrs, l, node_temp, sibbling,
    type = info [0], nodeName = info [1], count;

  // 1) manage node atribute
  if (type === 2) {
    attrs = root.attributes;
    l = attrs.length;
    while (l--) {
      node_temp = attrs.item (l);
      if (node_temp.nodeName.toLowerCase () ==  nodeName) { return node_temp; }
    }
    return null;
  }
  else if (type === 1) {
    sibbling = root.firstChild; l = info [2], count = 1;
    while (sibbling) {
      if (sibbling.nodeName.toLowerCase () === nodeName) {
        if (l === count) {
          return _evalPath (sibbling, path);
        }
        else {
          count ++;
        }
      }
      sibbling = sibbling.nextSibling;
    }
  }

  return null;
};

/**
 * @protected
 */
Template.parseHTML = function (html) {
  var div = document.createElement ('div');
  try {
    util.safeInnerHTML (div, html);

    div = div.firstElementChild;
    if (div) {
      div.parentElement.removeChild (div);
    }
  }
  catch (e) {
    console.error ("vs.ui.Template.parseHTML failed:");
    if (e.stack) console.log (e.stack);
    console.error (e);
    return undefined;
  }
  return div;
}
/********************************************************************
                      Export
*********************************************************************/
/** @private */
vs.ui.Template = Template;
/*
  Copyright (C) 2009-2013. David Thevenin, ViniSketch (c), and
  IGEL Co., Ltd. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @protected
 */
var RecognizerManager = {
  /**
   * @protected
   * @function
   */
  handleEvent: function (e)
  {
    if (this.__pointer_recognizers.length) {
      
      if (!this._enable) { return; }
     
      switch (e.type) {
        case core.POINTER_START:
          this.__pointer_recognizers.forEach (function (recognizer) {
            recognizer.pointerStart (e);
          });
        break;

        case core.POINTER_MOVE:
          this.__pointer_recognizers.forEach (function (recognizer) {
            recognizer.pointerMove (e);
          });
        break;

        case core.POINTER_END:
          this.__pointer_recognizers.forEach (function (recognizer) {
            recognizer.pointerEnd (e);
          });
        break;

        case core.POINTER_CANCEL:
          this.__pointer_recognizers.forEach (function (recognizer) {
            recognizer.pointerCancel (e);
          });
        break;

        case core.GESTURE_START:
          this.__pointer_recognizers.forEach (function (recognizer) {
            recognizer.gestureStart (e);
          });
          break;
        
        case core.GESTURE_CHANGE:
          this.__pointer_recognizers.forEach (function (recognizer) {
            recognizer.gestureChange (e);
          });
          break;
        
        case core.GESTURE_END:
          this.__pointer_recognizers.forEach (function (recognizer) {
            recognizer.gestureEnd (e);
          });
          break;
      }
    }
    else if (this._propagateToParent) this._propagateToParent (e);
  },
  
  __pointer_recognizers: null,
  
  addPointerRecognizer: function (recognizer)
  {
    if (!recognizer instanceof PointerRecognizer) return;
    
    if (this.__pointer_recognizers.indexOf (recognizer) !== -1) return;
    
    this.__pointer_recognizers.push (recognizer);
    recognizer.init (this);
  },

  removePointerRecognizer: function (recognizer)
  {
    if (!recognizer instanceof PointerRecognizer) return;
    
    this.__pointer_recognizers.remove (recognizer);
    recognizer.uninit ();
  }
};
ui.RecognizerManager = RecognizerManager;/*
  Copyright (C) 2009-2013. David Thevenin, ViniSketch (c), and
  IGEL Co., Ltd. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.ui.PointerRecognizer class
 *
 *  @class
 *  vs.ui.PointerRecognizer is an abstract class that helps with detecting and
 *  responding to the various UI pointer/gesture events common on devices.<br />
 *  Build on top of PointerEvent API, PointerRecognizer will works with mouse
 *  and/or touche devices.<br />
 *
 *  vs.ui.PointerRecognizer is an abstract class, with the following concrete
 *  subclasses, one for each type of available recognizer:
 *  <ul>
 *    <li /> vs.ui.TapRecognizer
 *    <li /> vs.ui.DragRecognizer
 *    <li /> vs.ui.RotationRecognizer
 *    <li /> vs.ui.PinchRecognizer
 *  </ul>
 *  <p>
 *  Depending on the type of recognizer, there are various behaviors that you
 *  can configure. For instance, with the vs.ui.TapRecognizer, you can specify
 *  the number of taps and number of touches.<br />
 * 
 *  In response to recognized actions, a delegate method call to a delegate
 *  object that you specify within the constructor. Depending on the type of
 *  gesture additional information about the gesture may be available in the
 *  delegate method, for example, the scale factor of a pinch.<br />
 *
 *  @author David Thevenin
 *  @see vs.ui.TapRecognizer
 *  @see vs.ui.DragRecognizer
 *  @see vs.ui.RotationRecognizer
 *  @see vs.ui.PinchRecognizer
 *
 *  @constructor
 *   Creates a new vs.ui.PointerRecognizer.
 *
 * @name vs.ui.PointerRecognizer
 *
 * @param {ReconizerDelegate} delegate the delegate [mandatory]
 */
function PointerRecognizer (delegate) {
  this.constructor = PointerRecognizer;

  this.delegate = delegate;
}

var POINTER_LISTENERS = [];

PointerRecognizer.prototype = {

  /**
   * @name vs.ui.PointerRecognizer#addPointerListener
   * @function
   * @protected
   *
   * @param {HTMLElement} node The node to listen
   * @param {String} type the event to listen
   * @param {Function | Object} listener the listener
   * @param {Boolean} useCapture 
   */
  addPointerListener: function (node, type, listener, useCapture) {
    if (!node || !type || !listener) return false;

    var i = 0, len = POINTER_LISTENERS.length, binding;
    for (; i < len; i++) {
      binding = POINTER_LISTENERS [i];
      if (binding.target === node &&
          binding.type === type &&
          binding.listener === listener) {
        binding.nb ++;
        return true;
      }
    }
    
    binding = {};
    binding.target = node;
    binding.type = type;
    binding.listener = listener;
    binding.nb = 1;
    POINTER_LISTENERS.push (binding);
    vs.addPointerListener (node, type, listener, useCapture);
    return true;
  },

  /**
   * @name vs.ui.PointerRecognizer#removePointerListener
   * @function
   * @protected
   *
   * @param {HTMLElement} node The node to listen
   * @param {String} type the event to listen
   * @param {Function | Object} listener the listener
   * @param {Boolean} useCapture 
   */
  removePointerListener: function (node, type, listener, useCapture) {
    if (!node || !type || !listener) return false;

    var i = 0, len = POINTER_LISTENERS.length, binding;
    for (; i < len; i++) {
      binding = POINTER_LISTENERS [i];
      if (binding.target === node &&
          binding.type === type &&
          binding.listener === listener) {
        binding.nb --;
        if (binding.nb === 0) {
          vs.removePointerListener (node, type, listener, useCapture);
          POINTER_LISTENERS.remove (i);
        }
        return true;
      }
    }
    
    return false;
  },

  /**
   * @name vs.ui.PointerRecognizer#init
   * @function
   * @protected
   *
   * @param {vs.ui.View} obj The view object to listen
   */
  init : function (obj) {
    this.obj = obj;
  },

  /**
   * @name vs.ui.PointerRecognizer#uninit
   * @function
   * @protected
   */
  uninit: function () {},

  /**
   * @name vs.ui.PointerRecognizer#reset
   * @function
   * @protected
   */
  reset: function () {},

  /**
   * @name vs.ui.PointerRecognizer#pointerStart
   * @function
   * @protected
   */
  pointerStart: function (event) {},

  /**
   * @name vs.ui.PointerRecognizer#pointerMove
   * @function
   * @protected
   */
  pointerMove: function (event) {},

  /**
   * @name vs.ui.PointerRecognizer#pointerEnd
   * @function
   * @protected
   */
  pointerEnd: function (event) {},

  /**
   * @name vs.ui.PointerRecognizer#pointerCancel
   * @function
   * @protected
   */
  pointerCancel: function (event) {},

  /**
   * @name vs.ui.PointerRecognizer#gestureStart
   * @function
   * @protected
   */
  gestureStart: function (event) {},

  /**
   * @name vs.ui.PointerRecognizer#gestureChange
   * @function
   * @protected
   */
  gestureChange: function (event) {},

  /**
   * @name vs.ui.PointerRecognizer#gestureEnd
   * @function
   * @protected
   */
  gestureEnd: function (event) {}
};

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.PointerRecognizer = PointerRecognizer;
/*
  Copyright (C) 2009-2013. David Thevenin, ViniSketch (c), and
  IGEL Co., Ltd. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.ui.TapRecognizer class
 *
 *  @extends vs.ui.PointerRecognizer
 *
 *  @class
 *  vs.ui.TapRecognizer is a concrete subclass of vs.ui.PointerRecognizer that
 *  looks for single or multiple taps/clicks.<br />
 *
 *  The TapRecognizer delegate has to implement following methods:
 *  <ul>
 *    <li /> didTouch (comp, target, event). Call when the element is touched; It useful to
 *      implement this method to implement a feedback on the event (for instance
 *      add a pressed class)
 *    <li /> didUntouch (comp, target, event). Call when the element is untouched; It useful to
 *      implement this method to implement a feedback on the event (for instance
 *      remove a pressed class)
 *    <li /> didTap (nb_tap, comp, target, event). Call when the element si tap/click. nb_tap
 *      is the number of tap/click.
 *  </ul>
 *  <p>
 *
 *  @example
 *  var my_view = new vs.ui.View ({id: "my_view"}).init ();
 *  var recognizer = new TapRecognizer ({
 *    didTouch : function (comp) {
 *      comp.addClassName ("pressed");
 *    },
 *    didUntouch : function (comp) {
 *      comp.removeClassName ("pressed");
 *    },
 *    didTap : function (nb_tap, view) {
 *      comp.view.hide ();
 *    }
 *  });
 *  my_view.addPointerRecognizer (recognizer);
 *
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.ui.TapRecognizer.
 *
 * @name vs.ui.TapRecognizer
 *
 * @param {ReconizerDelegate} delegate the delegate [mandatory]
 */
function TapRecognizer (delegate) {
  this.parent = PointerRecognizer;
  this.parent (delegate);
  this.constructor = TapRecognizer;
}

var MULTI_TAP_DELAY = 100;

TapRecognizer.prototype = {

  __is_touched: false,
  __unselect_time_out: 0,
  __unselect_clb: null,
  __did_tap_time_out: 0,
  __tap_mode: 0,

  /**
   * @name vs.ui.TapRecognizer#init
   * @function
   * @protected
   */
  init : function (obj) {
    PointerRecognizer.prototype.init.call (this, obj);
    
    this.addPointerListener (this.obj.view, core.POINTER_START, this.obj);
    this.reset ();
  },

  /**
   * @name vs.ui.TapRecognizer#uninit
   * @function
   * @protected
   */
  uninit : function () {
    this.removePointerListener (this.obj.view, core.POINTER_START, this.obj);
  },

  /**
   * @name vs.ui.TapRecognizer#pointerStart
   * @function
   * @protected
   */
  pointerStart: function (e) {
    if (this.__is_touched) { return; }
    // prevent multi touch events
    if (e.targetPointerList.length === 0 || e.nbPointers > 1) { return; }
    
    if (this.__tap_mode === 0) {
      this.__tap_mode = 1;
    }

    if (this.__unselect_time_out) {
      clearTimeout (this.__unselect_time_out);
      this.__unselect_time_out = 0;
      if (this.__unselect_clb) this.__unselect_clb ();
    }

    this.__tap_elem = e.targetPointerList[0].currentTarget;

    try {
      if (this.delegate && this.delegate.didTouch)
        this.delegate.didTouch (this.__tap_elem._comp_, this.__tap_elem, e);
    } catch (exp) {
      if (exp.stack) console.log (exp.stack);
      console.log (exp);
    }

    if (this.__did_tap_time_out) {
      this.__tap_mode ++;
      clearTimeout (this.__did_tap_time_out);
      this.__did_tap_time_out = 0;
    }
  
    this.addPointerListener (document, core.POINTER_END, this.obj);
    this.addPointerListener (document, core.POINTER_MOVE, this.obj);
  
    this.__start_x = e.targetPointerList[0].pageX;
    this.__start_y = e.targetPointerList[0].pageY;
    this.__is_touched = true;
  
    return false;
  },

  /**
   * @name vs.ui.TapRecognizer#pointerMove
   * @function
   * @protected
   */
  pointerMove: function (e) {
    // do not manage event for other targets
    if (!this.__is_touched || e.pointerList.length === 0) { return; }

    var dx = e.pointerList[0].pageX - this.__start_x;
    var dy = e.pointerList[0].pageY - this.__start_y;
    
    if (Math.abs (dx) + Math.abs (dy) < View.MOVE_THRESHOLD) {
      // we still in selection mode
      return false;
    }

    // cancel the selection mode
    this.removePointerListener (document, core.POINTER_END, this.obj);
    this.removePointerListener (document, core.POINTER_MOVE, this.obj);
    this.__is_touched = false;

    try {
      if (this.delegate && this.delegate.didUntouch)
        this.delegate.didUntouch (this.__tap_elem._comp_, this.__tap_elem, e);
    } catch (exp) {
      if (exp.stack) console.log (exp.stack);
      console.log (exp);
    }
  },

  /**
   * @name vs.ui.TapRecognizer#init
   * @function
   * @protected
   */
  pointerEnd: function (e) {
    if (!this.__is_touched) { return; }
    this.__is_touched = false;
    var
      self = this,
      target = self.__tap_elem,
      comp = (target)?target._comp_:null;
    
    self.__tap_elem = undefined;
  
    this.removePointerListener (document, core.POINTER_END, this.obj);
    this.removePointerListener (document, core.POINTER_MOVE, this.obj);

    if (this.delegate && this.delegate.didUntouch) {
      this.__unselect_clb = function () {
        try {
          self.delegate.didUntouch (comp, target, e);
        } catch (exp) {
          if (exp.stack) console.log (exp.stack);
          console.log (exp);
        }
        self.__unselect_time_out = 0;
        delete (self.__unselect_clb);
      }
      this.__unselect_time_out = setTimeout (this.__unselect_clb, View.UNSELECT_DELAY);        
    }
    
    if (this.delegate && this.delegate.didTap) {
      this.__did_tap_time_out = setTimeout (function () {
        try {
          self.delegate.didTap (self.__tap_mode, comp, target, e);
        } catch (exp) {
          if (exp.stack) console.log (exp.stack);
          console.log (exp);
        }
        self.__tap_mode = 0;
        self.__did_tap_time_out = 0;
      }, MULTI_TAP_DELAY);
    } else {
      self.__tap_mode = 0;
    }
  },

  /**
   * @name vs.ui.TapRecognizer#pointerCancel
   * @function
   * @protected
   */
  pointerCancel: function (e) {
    return this.pointerEnd (e);
  }
};
util.extendClass (TapRecognizer, PointerRecognizer);

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.TapRecognizer = TapRecognizer;
/*
  Copyright (C) 2009-2013. David Thevenin, ViniSketch (c), and
  IGEL Co., Ltd. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/


/**
 *  The vs.ui.DragRecognizer class
 *
 *  @extends vs.ui.PointerRecognizer
 *
 *  @class
 *  vs.ui.DragRecognizer is a concrete subclass of vs.ui.PointerRecognizer
 *  that looks for drag gestures. When the user moves
 *  the fingers, the underlying view should translate in a corresponding
 *  direction and speed...<br />
 *
 *  The DragRecognizer delegate has to implement following methods:
 *  <ul>
 *    <li /> didDragStart (event, comp). Call when the drag start.
 *    <li /> didDragEnd (event, comp). Call when the drag end.
 *    <li /> didDrag (drag_info, event, comp). Call when the element is dragged.
 *      drag_info = {dx: dx, dy:dy}, the drag delta form the beginning.
 *  </ul>
 *  <p>
 *
 *  @example
 *  var my_view = new vs.ui.View ({id: "my_view"}).init ();
 *  var recognizer = new DragRecognizer ({
 *    didDrag : function (drag_info, event) {
 *      my_view.translation = [drag_info.dx, drag_info.dy];
 *    },
 *    didDragEnd : function (event) {
 *      // save drag translation
 *      my_view.flushTransformStack ();
 *    }
 *  });
 *  my_view.addPointerRecognizer (recognizer);
 *
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.ui.DragRecognizer.
 *
 * @name vs.ui.DragRecognizer
 *
 * @param {ReconizerDelegate} delegate the delegate [mandatory]
 */
function DragRecognizer (delegate) {
  this.parent = PointerRecognizer;
  this.parent (delegate);
  this.constructor = DragRecognizer;     
}

DragRecognizer.prototype = {

  __is_dragged: false,
  
  /**
   * @name vs.ui.DragRecognizer#init
   * @function
   * @protected
   */
  init : function (obj) {
    PointerRecognizer.prototype.init.call (this, obj);
    
    this.addPointerListener (this.obj.view, core.POINTER_START, this.obj);
    this.reset ();
  },

  /**
   * @name vs.ui.DragRecognizer#uninit
   * @function
   * @protected
   */
  uninit : function () {
    this.removePointerListener (this.obj.view, core.POINTER_START, this.obj);
  },

  /**
   * @name vs.ui.DragRecognizer#pointerStart
   * @function
   * @protected
   */
  pointerStart: function (e) {
    if (this.__is_dragged) { return; }
    // prevent multi touch events
    if (!e.targetPointerList || e.targetPointerList.length > 1) { return; }

    var pointer = e.targetPointerList [0];

    this.__start_x = pointer.pageX;
    this.__start_y = pointer.pageY;
    this.__pointer_id = pointer.identifier;
    this.__is_dragged = true;

    this.addPointerListener (document, core.POINTER_END, this.obj);
    this.addPointerListener (document, core.POINTER_MOVE, this.obj);
  
    try {
      if (this.delegate && this.delegate.didDragStart)
        this.delegate.didDragStart (e, e.targetPointerList[0].currentTarget._comp_);
    } catch (exp) {
      if (exp.stack) console.log (exp.stack);
      console.log (exp);
    }
    return false;
  },

  /**
   * @name vs.ui.DragRecognizer#pointerMove
   * @function
   * @protected
   */
  pointerMove: function (e) {
    if (!this.__is_dragged) { return; }

    var i = 0, l = e.targetPointerList.length, pointer, dx, dy;
    for (; i < l; i++) {
      pointer = e.targetPointerList [i];
      if (pointer.identifier === this.__pointer_id) { break; }
      pointer = null;
    }
    if (!pointer) { return; }

    dx = pointer.pageX - this.__start_x;
    dy = pointer.pageY - this.__start_y;
    
    try {
      if (this.delegate && this.delegate.didDrag)
        this.delegate.didDrag ({dx: dx, dy:dy}, e, e.targetPointerList[0].currentTarget._comp_);
    } catch (exp) {
      if (exp.stack) console.log (exp.stack);
      console.log (exp);
    }
  },

  /**
   * @name vs.ui.DragRecognizer#pointerEnd
   * @function
   * @protected
   */
  pointerEnd: function (e) {
    if (!this.__is_dragged) { return; }

    var i = 0, l = e.changedPointerList.length, pointer, dx, dy;
    for (; i < l; i++) {
      pointer = e.changedPointerList [i];
      if (pointer.identifier === this.__pointer_id) { break; }
      pointer = null;
    }
    if (!pointer) { return; }

    this.__is_dragged = false;
    this.__start_x = undefined;
    this.__start_y = undefined;
    this.__pointer_id = undefined;
  
    this.removePointerListener (document, core.POINTER_END, this.obj);
    this.removePointerListener (document, core.POINTER_MOVE, this.obj);

    try {
      if (this.delegate && this.delegate.didDragEnd)
        this.delegate.didDragEnd (e, e.changedPointerList[0].target._comp_);
    } catch (exp) {
      if (exp.stack) console.log (exp.stack);
      console.log (exp);
    }
  },

  /**
   * @name vs.ui.DragRecognizer#pointerCancel
   * @function
   * @protected
   */
  pointerCancel: function (e) {
    return this.pointerEnd (e);
  }
};
util.extendClass (DragRecognizer, PointerRecognizer);

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.DragRecognizer = DragRecognizer;/*
  Copyright (C) 2009-2013. David Thevenin, ViniSketch (c), and
  IGEL Co., Ltd. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/


/**
 *  The vs.ui.PinchRecognizer class
 *
 *  @extends vs.ui.PointerRecognizer
 *
 *  @class
 *  The vs.ui.PinchRecognizer is a concrete subclass of vs.ui.PointerRecognizer
 *  that looks for pinching gestures involving two touches. When the user moves
 *  the two fingers toward each other, the conventional meaning is zoom-out;<br />
 *  when the user moves the two fingers away from each other, the conventional
 *  meaning is zoom-in<br />
 *
 *  The PinchRecognizer delegate has to implement following methods:
 *  <ul>
 *    <li /> didPinchChange (scale, event, comp). Call when the element is pinched.
 *      scale is The scale factor relative to the points of the two touches
 *      in screen coordinates
 *    <li /> didPinchStart (event, comp). Call when the pinch start
 *    <li /> didPinchEnd (event, comp). Call when the pinch end
 *  </ul>
 *  <p>
 *
 *  @example
 *  var my_view = new vs.ui.View ({id: "my_view"}).init ();
 *  var recognizer = new PinchRecognizer ({
 *    didPinchChange : function (scale, event) {
 *      my_view.scaling = scale;
 *    },
 *    didPinchStart : function (event) {
 *      xxx
 *    },
 *    didPinchEnd : function (event) {
 *      mss
 *    }
 *  });
 *  my_view.addPointerRecognizer (recognizer);
 *
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.ui.PinchRecognizer.
 *
 * @name vs.ui.PinchRecognizer
 *
 * @param {ReconizerDelegate} delegate the delegate [mandatory]
 */
function PinchRecognizer (delegate) {
  this.parent = PointerRecognizer;
  this.parent (delegate);
  this.constructor = PinchRecognizer;
}

PinchRecognizer.prototype = {

  /**
   * @name vs.ui.PinchRecognizer#init
   * @function
   * @protected
   */
  init : function (obj) {
    PointerRecognizer.prototype.init.call (this, obj);
    
    this.addPointerListener (this.obj.view, core.GESTURE_START, this.obj);
    this.reset ();
  },

  /**
   * @name vs.ui.PinchRecognizer#uninit
   * @function
   * @protected
   */
  uninit : function () {
    this.removePointerListener (this.obj.view, core.GESTURE_START, this.obj);
  },

  /**
   * @name vs.ui.PinchRecognizer#gestureStart
   * @function
   * @protected
   */
  gestureStart: function (e) {
    this.addPointerListener (document, core.GESTURE_CHANGE, this.obj);
    this.addPointerListener (document, core.GESTURE_END, this.obj);

    try {
      if (this.delegate && this.delegate.didPinchStart)
        this.delegate.didPinchStart (
          event, event.targetPointerList[0].target._comp_
        );
    } catch (e) {
      if (e.stack) console.log (e.stack);
      console.log (e);
    }
    return false;
  },

  /**
   * @name vs.ui.PinchRecognizer#gestureChange
   * @function
   * @protected
   */
  gestureChange: function (event) {
    try {
      if (this.delegate && this.delegate.didPinchChange)
        this.delegate.didPinchChange (
          event.scale, event, event.targetPointerList[0].target._comp_
        );
    } catch (e) {
      if (e.stack) console.log (e.stack);
      console.log (e);
    }
  },

  /**
   * @name vs.ui.PinchRecognizer#gestureEnd
   * @function
   * @protected
   */
  gestureEnd: function (e) {
    this.removePointerListener (document, core.GESTURE_CHANGE, this.obj);
    this.removePointerListener (document, core.GESTURE_END, this.obj);
    
    try {
      if (this.delegate && this.delegate.didPinchEnd)
        this.delegate.didPinchEnd (
          event, event.targetPointerList[0].target._comp_
        );
    } catch (e) {
      if (e.stack) console.log (e.stack);
      console.log (e);
    }
  },

  /**
   * @name vs.ui.PinchRecognizer#pointerCancel
   * @function
   * @protected
   */
  pointerCancel: function (e) {
    return this.pointerEnd (e);
  }
};
util.extendClass (PinchRecognizer, PointerRecognizer);

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.PinchRecognizer = PinchRecognizer;/*
  Copyright (C) 2009-2013. David Thevenin, ViniSketch (c), and
  IGEL Co., Ltd. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/


/**
 *  The vs.ui.RotationRecognizer class
 *
 *  @extends vs.ui.PointerRecognizer
 *
 *  @class
 *  vs.ui.RotationRecognizer is a concrete subclass of vs.ui.PointerRecognizer
 *  that looks for rotation gestures involving two touches. When the user moves
 *  the fingers opposite each other in a circular motion, the underlying view
 *  should rotate in a corresponding direction and speed...<br />
 *
 *  The RotationRecognizer delegate has to implement following methods:
 *  <ul>
 *    <li /> didRotationChange (rotation, event). Call when the element is rotated.
 *      rotation The rotation of the gesture in degrees.
 *    <li /> didRotationStart (event). Call when the rotation start
 *    <li /> didRotationEnd (event). Call when the rotation end
 *  </ul>
 *  <p>
 *
 *  @example
 *  var my_view = new vs.ui.View ({id: "my_view"}).init ();
 *  var recognizer = new RotationRecognizer ({
 *    didRotationChange : function (rotation, event) {
 *      my_view.rotation = rotation;
 *    }
 *  });
 *  my_view.addPointerRecognizer (recognizer);
 *
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.ui.RotationRecognizer.
 *
 * @name vs.ui.RotationRecognizer
 *
 * @param {ReconizerDelegate} delegate the delegate [mandatory]
 */
function RotationRecognizer (delegate) {
  this.parent = PointerRecognizer;
  this.parent (delegate);
  this.constructor = RotationRecognizer;
}

RotationRecognizer.prototype = {

  /**
   * @name vs.ui.RotationRecognizer#init
   * @function
   * @protected
   */
  init : function (obj) {
    PointerRecognizer.prototype.init.call (this, obj);
    
    this.addPointerListener (this.obj.view, core.GESTURE_START, this.obj);
    this.reset ();
  },

  /**
   * @name vs.ui.RotationRecognizer#uninit
   * @function
   * @protected
   */
  uninit : function () {
    this.removePointerListener (this.obj.view, core.GESTURE_START, this.obj);
  },

  /**
   * @name vs.ui.RotationRecognizer#gestureStart
   * @function
   * @protected
   */
  gestureStart: function (e) {
    this.addPointerListener (document, core.GESTURE_CHANGE, this.obj);
    this.addPointerListener (document, core.GESTURE_END, this.obj);

    try {
      if (this.delegate && this.delegate.didRotationStart)
        this.delegate.didRotationStart (event);
    } catch (e) {
      if (e.stack) console.log (e.stack);
      console.log (e);
    }

    return false;
  },

  /**
   * @name vs.ui.RotationRecognizer#gestureChange
   * @function
   * @protected
   */
  gestureChange: function (event) {
    try {
      if (this.delegate && this.delegate.didRotationChange)
        this.delegate.didRotationChange (event.rotation, event);
    } catch (e) {
      if (e.stack) console.log (e.stack);
      console.log (e);
    }
  },

  /**
   * @name vs.ui.RotationRecognizer#gestureEnd
   * @function
   * @protected
   */
  gestureEnd: function (e) {
    this.removePointerListener (document, core.GESTURE_CHANGE, this.obj);
    this.removePointerListener (document, core.GESTURE_END, this.obj);

    try {
      if (this.delegate && this.delegate.didRotationEnd)
        this.delegate.didRotationEnd (event);
    } catch (e) {
      if (e.stack) console.log (e.stack);
      console.log (e);
    }
  },

  /**
   * @name vs.ui.RotationRecognizer#pointerCancel
   * @function
   * @protected
   */
  pointerCancel: function (e) {
    return this.pointerEnd (e);
  }
};
util.extendClass (RotationRecognizer, PointerRecognizer);

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.RotationRecognizer = RotationRecognizer;/*
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and
  contributors. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @private
 */
function _findNodeRef (node, ref)
{
  if (!node.getAttribute) { return false; }

  if (node.getAttribute ('x-hag-ref') === ref) { return node; }
  if (node.getAttribute ('x-hag-comp') === ref) { return node; }

  var child = node.firstElementChild, result;
  while (child)
  {
    result = _findNodeRef (child, ref);
    if (result) { return result; }

    child = child.nextElementSibling;
  }

  return false;
}

/**
 *  The vs.ui.View class
 *
 *  @extends vs.core.EventSource
 *  @class
 *  vs.ui.View is a class that defines the basic drawing, event-handling, of
 *  an application. You typically don’t interact with the vs.ui.View API
 *  directly; rather, your custom view classes inherit from vs.ui.View and
 *  override many of its methods., Its also supports 2D
 *  transformations (translate, rotate, scale).
 *  <p>
 *  If you’re not creating a custom view class, there are few methods you
 *  need to use
 *
 *  Events:
 *  <ul>
 *    <li /> POINTER_START: Fired after the user click/tap on the view, when
 *           the user depresses the mouse/screen
 *    <li /> POINTER_MOVE: Fired after the user move the mouse/his finger on
 *           the view.
 *    <li /> POINTER_END: Fired after the user click/tap on the view, when
 *           the user release the mouse/ the pressur on screen.
 *  </ul>
 *  <p>
 *
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.ui.View.
 *
 * @name vs.ui.View
 *
 * @param {Object} config the configuration structure [mandatory]
 */
function View (config)
{
  this.parent = core.EventSource;
  this.parent (config);
  this.constructor = View;
  
  // init recognizer support
  this.__pointer_recognizers = [];
}

/********************************************************************
                    Layout constant
*********************************************************************/

/**
 * No particular layout
 * @see vs.ui.View#layout
 * @name vs.ui.View.DEFAULT_LAYOUT
 * @const
 */
View.DEFAULT_LAYOUT = null;

/**
 * Horizontal layout
 * @see vs.ui.View#layout
 * @name vs.ui.View.HORIZONTAL_LAYOUT
 * @const
 */
View.HORIZONTAL_LAYOUT = 'horizontal';
/** @private */
View.LEGACY_HORIZONTAL_LAYOUT = 'horizontal_layout';

/**
 * Vertical layout
 * @see vs.ui.View#layout
 * @name vs.ui.View.VERTICAL_LAYOUT
 * @const
 */
View.VERTICAL_LAYOUT = 'vertical';
/** @private */
View.LEGACY_VERTICAL_LAYOUT = 'vertical_layout';

/**
 * Absolute layout
 * @see vs.ui.View#layout
 * @name vs.ui.View.ABSOLUTE_LAYOUT
 * @const
 */
View.ABSOLUTE_LAYOUT = 'absolute';
/** @private */
View.LEGACY_ABSOLUTE_LAYOUT = 'absolute_layout';

/**
 * Html flow layout
 * @see vs.ui.View#layout
 * @name vs.ui.View.FLOW_LAYOUT
 * @const
 */
View.FLOW_LAYOUT = 'flow';
/** @private */
View.LEGACY_FLOW_LAYOUT = 'flow_layout';

/********************************************************************
                    Delay constant
*********************************************************************/

/**
 * Feed back remanence in ms before select a item
 * @name vs.ui.View.SELECT_DELAY
 * @const
 */
View.SELECT_DELAY = 150;

/**
 * Feed back remanence in ms  before unselect a item
 * @name vs.ui.View.UNSELECT_DELAY
 * @const
 */
View.UNSELECT_DELAY = 300;

/**
 * Threshold in px  use to unselect a item when pointer move
 * @name vs.ui.View.MOVE_THRESHOLD
 * @const
 */
View.MOVE_THRESHOLD = 20;

/********************************************************************
                    Magnet contants
*********************************************************************/

/**
 * No magnet
 * @name vs.ui.View.MAGNET_NONE
 * @const
 */
View.MAGNET_NONE = 0;

/**
 * The widget will be fixed on left
 * @name vs.ui.View.MAGNET_LEFT
 * @const
 */
View.MAGNET_LEFT = 3;

/**
 * The widget will be fixed on bottom
 * @name vs.ui.View.MAGNET_BOTTOM
 * @const
 */
View.MAGNET_BOTTOM = 2;

/**
 * The widget will be fixed on top
 * @name vs.ui.View.MAGNET_TOP
 * @const
 */
View.MAGNET_TOP = 1;

/**
 * The widget will be fixed on right
 * @name vs.ui.View.MAGNET_RIGHT
 * @const
 */
View.MAGNET_RIGHT = 4;

/**
 * The widget will centered
 * @name vs.ui.View.MAGNET_CENTER
 * @const
 */
View.MAGNET_CENTER = 5;

/********************************************************************

*********************************************************************/

/**
 * @private
 */
View.NON_G_OBJECT = '_non_g_object';
/**
 * @private
 */
View.ANY_PLACE = 'children';
/**
 * @private
 */
View._positionStyle = undefined;
/**
 * @private
 */
View.__comp_templates = {};

/**
 * @private
 */
View._propagate_pointer_event = function (obj, func_ptr, event)
{
  var event_name = "";
  if (event.type === core.POINTER_START) { event_name = 'POINTER_START'; }
  if (event.type === core.POINTER_END) { event_name = 'POINTER_END'; }
  if (event.type === core.POINTER_MOVE) { event_name = 'POINTER_MOVE'; }

  event.type = event_name;

  func_ptr.call (obj, event);
};

/**
 * @private
 */
var _template_nodes = null;

View.prototype = {

  /*****************************************************************
   *                Private members
   ****************************************************************/
  /**
   * @protected
   * @type {boolean}
   */
  _visible: true,

  /**
   * @protected
   * @type {number}
   */
  _magnet: View.MAGNET_NONE,

  /**
   * @private
   * @type {Array.<int>}
   */
  _autosizing: null,

  /**
   * @protected
   * @type {Object}
   */
  _pointerevent_handlers: null,

  /**
   *
   * @protected
   * @type {boolean}
   */
  _enable: true,

  /**
   * @protected
   * @type {Array}
   */
  _pos : null,

  /**
   * Translate value on x
   * @private
   * @type {number}
   */
  __view_t_x : 0,

  /**
   * Translate value on y
   * @private
   * @type {number}
   */
  __view_t_y : 0,

  /**
   * @protected
   * @type {Array}
   */
  _size : null,

   /**
   * Opacity value
   * @protected
   * @type {number}
   */
  _opacity : 1,

   /**
   * Scale value
   * @protected
   * @type {number}
   */
  _scaling : 1,

   /**
   * Rotation value
   * @protected
   * @type {number}
   */
  _rotation : 0,

  /**
   * @protected
   * @type {number}
   */
  _min_scale : 0.5,

  /**
   * @protected
   * @type {number}
   */
  _max_scale : 3,

   /**
   * @protected
   * @type {String}
   */
  _layout: null,

  /**
   * @protected
   * @type {Array.<number>}
   */
  _transform_origin: null,

  /**
   * @protected
   * @type {vs.CSSMatrix}
   */
  _transforms_stack: null,

  /**
   * @protected
   * @type {vs.fx.Animation}
   */
  _show_animation: null,
  __show_clb: null,

  /**
   * @protected
   * @type {vs.fx.Animation}
   */
  _hide_animation: null,
  __hide_clb: null,

  /*****************************************************************
   *
   ****************************************************************/

  /**
   * @protected
   * @function
   */
  destructor : function ()
  {
    var key, a, i, child;
    if (this.__parent)
    {
      this.__parent.remove (this);
    }
    for (key in this.__children)
    {
      a = this.__children [key];
      if (!a) { continue; }

      if (a instanceof Array)
      {
        for (i = 0; i < a.length; i++)
        {
          child = a [i];
          util.free (child);
        }
      }
      else
      { util.free (a); }
      delete (this.__children [key]);
    }
    this.__children = {};
    delete (this.view);

    this.clearTransformStack ();

    core.EventSource.prototype.destructor.call (this);
  },

  /**
   * @protected
   * @function
   */
  refresh : function ()
  {
    var key, a, i, child, view = this.view;

    // refresh element real size and position
    if (view && view.parentElement)
    {
      this._size [0] = view.offsetWidth;
      this._size [1] = view.offsetHeight;
      this._pos [0] = view.offsetLeft;
      this._pos [1] = view.offsetTop;
    }

    for (key in this.__children)
    {
      a = this.__children [key];
      if (!a) { continue; }

      if (a instanceof Array)
      {
        for (i = 0; i < a.length; i++)
        {
          child = a [i];
          if (!child || !child.refresh) { continue; }
          child.refresh ();
        }
      }
      else if (a.refresh)
      { a.refresh (); }
    }
  },

  /**
   * @name vs.ui.View#clone
   * @function
   * @private
   *
   * @param {vs.core.Object} obj The cloned object
   * @param {Object} map Map of cloned objects
   */
  clone : function (config, cloned_map)
  {
    function _getPaths (root, nodes)
    {
      var paths = [], i = 0, l = nodes.length, node;
      for (; i < l; i++)
      {
        node = nodes[i];
        paths.push ([node, _getPath (root, node)]);
      }
      return paths;
    }

    function _evalPaths (root, paths, clonedViews)
    {
      var nodes = [], i = 0, l = paths.length, path;
      for (; i < l; i++)
      {
        path = paths[i];
        if (!path.id) path.id = core.createId ();
        clonedViews [path[0].id] = _evalPath (root, path[1]);
      }
    }

    function makeClonedNodeMap (comp, clonedViews)
    {
      var
        clonedNode = comp.view.cloneNode (true),
        nodes = [], paths;
        
      function manageChild (child)
      {
        if (child.__gui_object__hack_view__)
        { nodes.push (child.__gui_object__hack_view__); }
        else if (child.view) { nodes.push (child.view); }
      
        retreiveChildNodes (child);
      }
        
      function retreiveChildNodes (comp)
      {
        var key, a, i, l, child;
        for (key in comp.__children)
        {
          a = comp.__children [key];
          if (!a) { continue; }
          
          if (util.isArray (a))
          {
            l = a.length;
            for (i = 0; i < l; i++)
            {
              manageChild (a [i]);
            }
          }
          else manageChild (a);
        }
      }
      
      retreiveChildNodes (comp);
      
      paths = _getPaths (comp.view, nodes);
      _evalPaths (clonedNode, paths, clonedViews);
      
      return clonedNode;
    }
    
    if (!cloned_map) { cloned_map = {}; }
    if (!cloned_map.__views__) { cloned_map.__views__ = {}; }    
    if (!config) { config = {}; }
    if (!config.node)
    {
      var node = cloned_map.__views__ [this.view.id];
      if (!node)
      {
        node = makeClonedNodeMap (this, cloned_map.__views__);
      }
      config.node = node;
    }

    return core.EventSource.prototype.clone.call (this, config, cloned_map);
  },

   /**
   * @name vs.core.Object#_clone_properties_value
   * @function
   * @protected
   *
   * @param {vs.core.Object} obj The cloned object
   * @param {Object} map Map of cloned objects
   */
  _clone_properties_value : function (obj, cloned_map)
  {
    var key;

    for (key in this)
    {
      if (key == 'id') continue;

      if (key == "size" || key == "position")
      {
        value = this.size;
        if (!value || value.length !== 3 ||
            (value[0] === 0 && value[1] === 0))
        { continue; }
      }
  
      // property value copy
      if (this.isProperty (key))
      { core.Object.__propertyCloneValue (key, this, obj); }
    }
  },

  /**
   * @name vs.ui.View#_clone
   * @function
   * @private
   *
   * @param {vs.core.Object} obj The cloned object
   * @param {Object} map Map of cloned objects
   */
  _clone : function (obj, cloned_map)
  {
    var anim, a, key, child, l, hole, cloned_comp;

    core.EventSource.prototype._clone.call (this, obj, cloned_map);

    // animations clone
    if (this._show_animation)
    {
      anim = cloned_map [this._show_animation._id];
      if (anim)
        obj._show_animation = anim;
      else
        obj._show_animation = this._show_animation.clone ();

      obj.__show_clb = this.__show_clb;
    }
    if (this._hide_animation)
    {
      anim = cloned_map [this._hide_animation._id];
      if (anim)
        obj._hide_animation = anim;
      else
        obj._hide_animation = this._hide_animation.clone ();

      obj.__hide_clb = this.__hide_clb;
    }

    // remove parent link
    obj.__parent = undefined;

    function getClonedComp (comp, cloned_map) {
      if (!comp || !cloned_map) return null;
      
      if (cloned_map [comp._id]) return cloned_map [comp._id];
      
      var  view = cloned_map.__views__ [comp._id];
        
      return (view)?view._comp_:null;
    }

    for (key in this.__children)
    {
      a = this.__children [key];
      hole = obj._holes [key];
      if (!a || !hole) { continue; }

      if (a instanceof Array)
      {
        l = a.length;
        while (l--)
        {
          child = a [l];
          cloned_comp = getClonedComp (child, cloned_map);
          if (!cloned_comp) {
            cloned_comp = child.clone (null, cloned_map);
            obj.add (cloned_comp, key);
          }
          else {
            cloned_map [child._id] = cloned_comp;
          }
        }
      }
      else
      {
        cloned_comp = getClonedComp (a, cloned_map);
        if (!cloned_comp) {
          cloned_comp = a.clone (null, cloned_map);
          obj.add (cloned_comp, key);
        }
        else {
          cloned_map [a._id] = cloned_comp;
        }
      }
    }
  },

  /**
   * @protected
   * @function
   */
  _getGUInode : function (config)
  {
    var node = this.__getGUInode (config), compName, doc, doc_elem;
    if (node) { return node; }

    var _template = (config.template)?config.template:this.template;
    if (_template)
    {
      var template = new Template (_template);
      var node = template.__extend_component (this);
      util.free (template);
      return node;
    }

    // 4) no node exists, generate a warning a create a div node.
    if (this.html_template)
    {
      node = Template.parseHTML (this.html_template);
      if (node) return node;
    }
    if (util.isFunction (this.constructor))
    { compName = this.constructor.name; }
    else if (util.isString (this.constructor))
    { compName = this.constructor; }
    else
    { compName = View; }

    console.warn ("Impossible to instance view of component '" + compName + ", id [" + config.id +
      "]. A default one is created");
    node = document.createElement ('div');

    return node;
  },

  /**
   * @protected
   * @function
   */
  __getGUInode : function (config)
  {
    // 1) the node is passed within config object
    if (config.node)// && config.node instanceof HTMLElement)
    {
      return config.node;
    }

    var node = null, node_ref, root_id, root_node, obj, regexp_result;
    // find a direct reference
    if (config.node_id)
    {
      node = document.getElementById (config.node_id);
      if (node) { return node; }
    }

    // 2) find a template node in a view
    node_ref = config.node_ref;
    if (node_ref)
    {
      regexp_result = View._ref_template_reg.exec (node_ref);
      // node ref with the new syntax : ref = root_id'#'node_ref
      if (regexp_result && regexp_result.length == 3)
      {
        root_id = regexp_result [1];
        node_ref = regexp_result [2];
      }
      // old syntax
      else root_id = config.root_ref;

      if (node_ref && root_id)
      {
        root_node = null;
        obj = core.Object._obs [root_id];

        if (obj && obj.view) { root_node = obj.view; }
        else
        {
          root_node = document.getElementById (this.id);
        }
        if (root_node)
        {
          node = _findNodeRef (root_node, node_ref);
        }

        if (node) { return node; }
      }
    }

    // 3) find a template node
    if (config.template_ref)
    {
      node = this._getTemplateNode (config.template_ref);
      if (node) { return node; }
    }

    // last case : find a direct reference with component id
    if (config.id)
    {
      node = document.getElementById (config.id);
      if (node) { return node; }
    }

    return undefined;
  },

  /**
   * @private
   * @function
   */
  _getTemplateNode : function (ref)
  {
    var node = null;
    
    if (!_template_nodes) {
      _template_nodes = document.querySelector (".application_templates");
      if (_template_nodes) {
        _template_nodes.parentElement.removeChild (_template_nodes);
      }
    }
    if (_template_nodes) {
      var node = _template_nodes.querySelector ("." + ref);
    }   
      
    if (node) { return document.importNode (node, true); }
  },

  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    core.EventSource.prototype.initComponent.call (this);

    // position and size : according autosizing rules, can change
    // automaticaly if the parent container is resized
    this._pos = [-1, -1];
    this._size = [-1, -1];
    this._transform_origin = [0, 0];

    // rules for positionning a object
    this._autosizing = [4,4];

    this._holes = {};
    this.__children = {};
    this._pointerevent_handlers = [];

    if (!this.__config__) this.__config__ = {};
    this.__config__.id = this.id;

    this.view = this._getGUInode (this.__config__);
    if (!this.view)
    {
      console.error ('vs.ui.View constructor failed. No view!');
      return;
    }

    this.view.id = this._id;
    this.view._comp_ = this;
    this.view.setAttribute ('x-hag-comp', this.id);

    this._parse_view (this.view);
  },

  /**
   * @protected
   * @function
   */
  componentDidInitialize : function ()
  {
    core.EventSource.prototype.componentDidInitialize.call (this);
    if (this._magnet) this.view.style.setProperty ('position', 'absolute', null);

    if (this._magnet === View.MAGNET_CENTER)
    {
      this._updateSizeAndPos ();
      this._applyTransformation ();
    }
  },

  /**
   * Notifies that the component's view was added to the DOM.<br/>
   * You can override this method to perform additional tasks
   * associated with presenting the view.<br/>
   * If you override this method, you must call the parent method.
   *
   * @name vs.ui.View#viewDidAdd
   * @function
   */
  viewDidAdd : function ()
  {
    var view = this.view, self = this;
    if (!view || !view.parentElement) return;

    // update the real element size and position
    vs.scheduleAction (function () {
      self._size [0] = view.offsetWidth;
      self._size [1] = view.offsetHeight;
      self._pos [0] = view.offsetLeft;
      self._pos [1] = view.offsetTop;
    });
  },

  /**
   * @protected
   * @function
   */
  notify : function (event) {},

  /**
   * @protected
   * @function
   */
  _parse_view : function (node)
  {
    if (!node || node.nodeType === 3) { return; }

    var hole_attribute, child;

    if (node.attributes !== null)
    {
      hole_attribute = node.attributes.getNamedItem ("x-hag-hole");
      if (hole_attribute)
      {
        this._holes [hole_attribute.nodeValue] = node;
        return; // hole can not include hode
      }
    }

    child = node.firstElementChild;
    while (child)
    {
      this._parse_view (child);
      child = child.nextElementSibling;
    }
  },

  /**
   *  Instantiate, init and add the specified child component to this component.
   *  <p>
   *  The view of the MyGUIComponent is dynamically loaded (from file),
   *  instanciated and  added into the HTML DOM.
   *  <p>
   *  @example
   *  var id =
   *    myObject.createAndAddComponent ('MyGUIComponent', config, 'children');
   *
   * @name vs.ui.View#createAndAddComponent
   * @function
   *
   * @param {String} comp_name The GUI component name to instanciate
   * @param {Object} config Configuration structure need to build the component.
   * @param {String} extension The hole into the vs.ui.View will be insert.
   * @return {vs.core.Object} the created component
   */
  createAndAddComponent : function (comp_name, config, extension)
  {
    var comp_class = window [comp_name];
    if (!comp_class) {
      console.error ("Impossible to fund component '" + comp_name + "'.");
      return;
    }

    // verify the component view already exists
    if (!config) {config = {};}

    if (!config.id) { config.id = core.createId (); }

    var view = this.__getGUInode (config),
      path, data, xmlRequest, div, children, i, len, obj, msg;


    // Find template into the DOM
    if (!view) { view = this._getTemplateNode (comp_name); }

    // Find template into the component prototype
    if (!view)
    {
      if (comp_class.prototype && comp_class.prototype.template)
      {
        view = Template.parseHTML (comp_class.prototype.template);
      }
    }

    if (!view)
    {
      if (comp_class.prototype && comp_class.prototype.node_template)
      {
        view = document.importNode (comp_class.prototype.node_template, true);
      }
    }

    // If no template was found, try to load it
    if (!view)
    {
      path = comp_name + '.xhtml';

      data = View.__comp_templates [path];
      if (!data)
      {
        xmlRequest = new XMLHttpRequest ();
        xmlRequest.open ("GET", path, false);
        xmlRequest.send (null);

        if (xmlRequest.readyState === 4)
        {
          if (xmlRequest.status === 200 || xmlRequest.status === 0)
          {
            data = xmlRequest.responseText;
            View.__comp_templates [path] = data;
          }
          else
          {
            console.error ("Template file for component '" + comp_name + "' unfound.");
            return;
          }
        }
        else
        {
          console.error ("Pb when load the component '" + comp_name + "' template.");
          return;
        }
        xmlRequest = null;
      }

      view = Template.parseHTML (data);
    }
    config.node = view;
    obj = null;

    // Build object
    try { obj = new comp_class (config); }
    catch (exp)
    {
      msg = "Impossible to instanciate comp: " + comp_name;
      msg += " => " + exp.message;
      console.error (msg);
      if (exp.stack) console.error (exp.stack);
      return;
    }

    // Initialize object
    try
    {
      obj.init ();
      obj.configure (config);
    }
    catch (exp)
    {
      if (exp.line && exp.sourceURL)
      {
        msg = "Error when initiate comp: " + comp_name;
        msg += " => " + exp.message;
        msg += "\n" + exp.sourceURL + ":" + exp.line;
      }
      else { msg = exp; }
      console.error (msg);
      if (exp.stack) console.error (exp.stack);
    }

    // Add object to its parent
    this.add (obj, extension);
    obj.refresh ();

    return obj;
  },

  /**
   *  Return true if the set component is a child o the current component
   *
   * @name vs.ui.View#isChild
   * @function
   *
   * @param {vs.core.EventSource} child The component to be removed.
   * @return {boolean}
   */
  isChild : function (child)
  {
    if (!child) { return false; }

    var key, a, hole;

    for (key in this.__children)
    {
      a = this.__children [key];
      if (!a) { continue; }

      if (a === child || (a instanceof Array && a.indexOf (child) !== -1))
      {
        return true;
      }
    }

    return false;
  },

  /**
   *  Add the specified child component to this component.
   *  <p>
   *  The component can be a graphic component (vs.ui.View) or
   *  a non graphic component (vs.core.EventSource).
   *  In case of vs.ui.View its mandatory to set the extension.
   *  <p>
   *  The add is a lazy add! The child's view can be already in
   *  the HTML DOM. In that case, the add methode do not modify the DOM.
   *  <p>
   *  @example
   *  var myButton = new Button (conf);
   *  myObject.add (myButton, 'children');
   *
   * @name vs.ui.View#add
   * @function
   *
   * @param {vs.core.EventSource} child The component to be added.
   * @param {String} extension [optional] The hole into a vs.ui.View will be
   *       insert.
   */
  add : function (child, extension, view /** hack view */)
  {
    if (!child) { return; }
    if (!view) { view = child.view; }
    else { child.__gui_object__hack_view__ = view; }

    if (this.isChild (child)) { return; }

    var key, a, b, hole;
    if (!view) { key = View.NON_G_OBJECT; }
    // a non graphical object
    else if (!extension) { key = View.ANY_PLACE; }
    else { key = extension; }

    a = this.__children [key];
    if (a && util.isArray (a)) { a.push (child); }
    else if (a)
    {
      b = [];
      b.push (a);
      b.push (child);
      this.__children [key] = b;
    }
    else { this.__children [key] = child; }

    hole = this._holes [key];
    if (view && hole)
    {
      if (view.parentElement)
      {
        if (view.parentElement === hole)
        {
          child.__parent = this;
          if (child.viewDidAdd) child.viewDidAdd ();
          return;
        }
        view.parentElement.removeChild (view);
      }
      hole.appendChild (view);
      child.__parent = this;

      if (child.viewDidAdd) child.viewDidAdd ();
    }
  },

  /**
   *  Remove the specified child component from this component.
   *
   *  @example
   *  myObject.remove (myButton);
   *
   * @name vs.ui.View#remove
   * @function
   *
   * @param {vs.core.EventSource} child The component to be removed.
   */
  remove : function (child)
  {
    if (!child) { return; }

    var key, a, view;

    if (child.__gui_object__hack_view__)
    {
      view = child.__gui_object__hack_view__;
    }
    else { view = child.view; }

    if (view)
    {
      for (key in this.__children)
      {
        a = this.__children [key];
        if (!a) { continue; }

        if (a === child || (a instanceof Array && a.indexOf (child) !== -1))
        {
          if (a instanceof Array) {a.remove (child);}
          else { delete (this.__children [key]); }

          if (view.parentElement)
          {
            view.parentElement.removeChild (view);
          }
//          hole = this._holes [key];
//          if (hole) { hole.removeChild (view); }

          child.__parent = null;
          break;
        }
      }
    }
  },

  /**
   *  Remove all children components from this component and free them.
   *
   *  @example
   *  myObject.removeAllChildren ();
   *
   * @name vs.ui.View#removeAllChild
   * @function
   * @param {Boolean} should_free free children
   * @param {String} extension [optional] The hole from witch all views will be
   *   removed
   * @return {Array} list of removed child if not should_free
   */
  removeAllChildren : function (should_free, extension)
  {
    var key, self = this, children = [];

    /** @private */
    function removeChildrenInHole (ext)
    {
      var a, child;

      a = self.__children [ext];
      if (!a) { return; }

      if (a instanceof Array)
      {
        while (a.length)
        {
          child = a [0];
          self.remove (child);
          if (should_free) util.free (child);
          else children.push (child);
        }
      }
      else
      {
        self.remove (a);
        if (should_free) util.free (a);
        else children.push (a);
      }
      delete (self.__children [ext]);
    };

    if (extension)
    {
      removeChildrenInHole (extension);
    }
    else
    {
      for (key in self.__children)
      {
        removeChildrenInHole (key);
      }
      this.__children = {};
    }
    
    return (should_free)?undefined:children;
  },

  /**
   * @protected
   * @function
   */
  findNodeRef : function (ref)
  {
    if (!this.view) { return; }

    return _findNodeRef (this.view, ref);
  },

/********************************************************************
                  GUI Utilities
********************************************************************/
  /**
   *  The event bind method to listen events
   *  <p>
   *  When you want listen an event generated by this object, you can
   *  bind your object (the observer) to this object using 'bind' method.
   *  <p>
   *  Warning:<br>
   *  If you know the process of your callback can take time or can be blocking
   *  you should set delay to 'true' otherwise you application will be stuck.
   *  But be careful this options add an overlay in the event propagation.
   *  For debug purpose or more secure coding you can force delay to true, for
   *  all bind using global variable vs.core.FORCE_EVENT_PROPAGATION_DELAY.<br/>
   *  You just have set as true (vs.core.FORCE_EVENT_PROPAGATION_DELAY = true)
   *  at beginning of your program.
   *
   * @name vs.ui.View#bind
   * @function
   *
   * @param {string} spec the event specification [mandatory]
   * @param {vs.core.Object} obj the object interested to catch the event
   *    [mandatory]
   * @param {string} func the name of a callback. If its not defined
   *        notify method will be called [optional]
   * @param {boolean} delay if true the callback 'func' will be call within
   *        an other "simili thread".
   */
  bind : function (spec, obj, func, delay)
  {
    if (spec === 'POINTER_START' || spec === 'POINTER_END' ||
        spec === 'POINTER_MOVE' || spec === core.POINTER_START ||
        spec === core.POINTER_END || spec === core.POINTER_MOVE)
    {
      if (!this.view) { return; }

      var func_ptr, self = this, handler;
      if (!func) { func = 'notify'; }
      if (util.isFunction (func)) { func_ptr = func; }
      else if (util.isString (func) &&
               util.isFunction (obj [func]))
      {
        func_ptr = obj [func];
      }
      else
      {
        console.error ('Invalid bind arguments.');
        return;
      }

      if (!func_ptr)
      {
        console.warn ('Invalid bind arguments. Unknown func: ' + func);
        return;
      }

      var self = this;
      handler = function (event)
      {
        if (core.EVENT_SUPPORT_TOUCH && event.changedTouches &&
            event.changedTouches.length > 1) { return; }

//        event.stopPropagation ();
//        event.preventDefault ();

        event.src = self;
        if (core.EVENT_SUPPORT_TOUCH && event.changedTouches)
        {
          event.pageX = event.changedTouches[0].pageX;
          event.pageY = event.changedTouches[0].pageY;
          var rec = util.getElementAbsolutePosition (self.view);
          event.offsetX = event.changedTouches[0].pageX - rec.x;
          event.offsetY = event.changedTouches[0].pageY - rec.y;
        }
        View._propagate_pointer_event (obj, func_ptr, event);
      };

      if (spec === 'POINTER_START') { spec = core.POINTER_START; }
      if (spec === 'POINTER_MOVE') { spec = core.POINTER_MOVE; }
      if (spec === 'POINTER_END') { spec = core.POINTER_END; }

      this._pointerevent_handlers [obj.id + spec] = handler;

      vs.addPointerListener (this.view, spec, handler);
    }
    return core.EventSource.prototype.bind.call (this, spec, obj, func, delay);
  },

  /**
   *  The event unbind method
   *  <p>
   *  Should be call when you want stop event listening on this object
   *
   * @name vs.ui.View#unbind
   * @function
   *
   * @param {string} spec the event specification [mandatory]
   * @param {vs.core.Object} obj the object you want unbind [mandatory]
   */
  unbind : function (spec, obj)
  {
    if (!spec || !obj) { return; }
    if (spec === core.POINTER_START || spec === core.POINTER_END ||
        spec === core.POINTER_MOVE)
    {
      var handler = this._pointerevent_handlers [obj.id + spec];
      if (!handler || !this.view) { return; }

      vs.removePointerListener (this.view, core.POINTER_END, handler);
    }
    core.EventSource.prototype.unbind.call (this, spec, obj);
  },

/********************************************************************
                  GUI Utilities
********************************************************************/

  /**
   * @protected
   * @function
   */
  _setMagnet : function (code)
  {
    this._magnet = code;
    if (this._magnet)
    { this.view.style.setProperty ('position', 'absolute', null); }
    else
    { this.view.style.removeProperty ('position'); }

    this._updateSizeAndPos ();
    this._applyTransformation ();
  },

  /**
   * @protected
   * @function
   * This function cost a lot!
   */
  _updateSizeAndPos : function ()
  {
    var
      x = this._pos [0], y = this._pos [1],
      w = this._size [0], h = this._size [1],
      width, height, pWidth = 0, pHeight = 0,
      left = 'auto', top = 'auto', right = 'auto', bottom = 'auto',
      aH = this._autosizing [0], aV = this._autosizing [1],
      view = this.view, parentElement, style;

    if (!view) { return; }
//     if (w < 0) { w = 0; }
//     if (h < 0) { h = 0; }

    parentElement = view.parentElement;
    if (parentElement)
    {
      pWidth = parentElement.offsetWidth;
      pHeight = parentElement.offsetHeight;
    }

    if (this._magnet === View.MAGNET_LEFT) x = 0;
    if (this._magnet === View.MAGNET_TOP) y = 0;

    if (w < 0) { width = ''; }
    else if (aH === 5 || aH === 7) { width = 'auto'; }
    else if (aH === 4 || aH === 1) { width = w + 'px'; }
    else if (aH === 2 || aH === 3 || aH === 6 || aH === 0)
    {
      if (pWidth)
      {
        width = (w / pWidth * 100) + '%';
      }
      else { width = w + 'px'; }
    }

    else { width = '100%'; }

    if (h < 0) { height = ''; }
    else if (aV === 5 || aV === 7) { height = 'auto'; }
    else if (aV === 4 || aV === 1) { height = h + 'px'; }
    else if (aV === 2 || aV === 3 || aV === 6 || aV === 0)
    {
      if (pHeight)
      {
        height = (h / pHeight * 100) + '%';
      }
      else { height = h + 'px'; }
    }
    else { height = '100%'; }

    if (aH === 4 || aH === 5 || aH === 6 || aH === 7 || (aH === 2 && !pWidth))
    { left = x + 'px'; }
    else if ((aH === 2 || aH === 0) && pWidth)
    { left = (x / pWidth * 100) + '%'; }

    if ((w >=0) && (aH === 1 || aH === 3 || aH === 5 || aH === 7))
    {
      right = pWidth - (x + w);
      if (right < 0) right = 0;
      right += 'px';
    }

    if (aV === 4 || aV === 5 || aV === 6 || aV === 7 || (aV === 2 && !pHeight))
    { top = y + 'px'; }
    else if ((aV === 2 || aV === 0) && pHeight)
    { top = (y / pHeight * 100) + '%'; }

    if ((h >= 0) && (aV === 1 || aV === 3 || aV === 5 || aV === 7))
    {
      bottom = pHeight - (y + h);
      if (bottom < 0) bottom = 0;
      bottom += 'px';
    }

    if (this._magnet === View.MAGNET_BOTTOM) { top = 'auto'; bottom = '0px'; }
    if (this._magnet === View.MAGNET_RIGHT) { left = 'auto'; right = '0px'; }

    if (this._magnet === View.MAGNET_CENTER) {
      top = '50%'; bottom = 'auto';
      left = '50%'; right = 'auto';
    }

    style = view.style;
    style.left = left;
    style.right = right;
    style.top = top;
    style.bottom = bottom;
    style.width = width;
    style.height = height;
  },

/********************************************************************
 CSS manipulation
********************************************************************/

  /**
   *  Returns the given CSS property value the vs.ui.View view.
   *  <p>
   *  This method looks up the CSS property of the vs.ui.View view whether
   *  it was applied inline or in a stylesheet.
   *
   *  @example
   *  myObject.getStyle ('color');
   *  // -> 'red'
   *
   * @name vs.ui.View#getStyle
   * @function
   *
   * @param {String} property the property name
   * @return {String} value the property value or null if
   */
  getStyle : function (property)
  {
    if (!this.view) { return undefined; }
    var css = this.view.style, value, _view;
    if (css) { value = css [property]; }

    if (property === 'opacity') { return value ? parseFloat (value) : 1.0; }
    return value === 'auto' ? null : value;
  },

  /**
   *  Returns the given CSS property computed value the vs.ui.View view.
   *  <p>
   *  This method looks up the CSS property of the vs.ui.View view whether
   *  it was applied inline or in a stylesheet.
   *
   *  @example
   *  myObject.getComputedStyle ('border-left-width');
   *  // -> '5px'
   *
   * @name vs.ui.View#getComputedStyle
   * @function
   *
   * @param {String} property the property name
   * @return {String} value the property value or null if
   */
  getComputedStyle : function (property)
  {
    var css = this._getComputedStyle (this.view);
    return value = css ? css [property] : null;
  },

  /**
   * @private
   * @function
   * @parent {DivHTMLElement} elem the element to get style
   * @return the computed CCS if it exists
   */
  _getComputedStyle : function (elem)
  {
    if (!elem) { elem = this.view; }
    if (!elem) { return undefined; }

    var doc = elem.ownerDocument;
    if (!doc || !doc.defaultView) { doc = document; }
    if (!doc || !doc.defaultView) { return undefined;}

    return doc.defaultView.getComputedStyle (elem, null);
  },

  /**
   *  Modifies vs.ui.View view CSS style property.
   *  <p>
   *  The method change the css inline style of the vs.ui.View view. Then
   *  it preempts css style defined in CSS stylesheets.
   *  @see vs.ui.View#addCssRules
   *  @see vs.ui.View#addCssRule if you want to
   *  modify CSS rules.
   *
   *  @example
   *  myObject.setStyle ('color', 'red');
   *
   * @name vs.ui.View#setStyle
   * @function
   *
   * @param {String} property the property name
   * @param {String} value the property value
   */
  setStyle : function (property, value)
  {
    if (!property) { return; }
    if (!this.view || !this.view.style ||
        !this.view.style.removeProperty || !this.view.style.setProperty)
    { return; }

    if (typeof value === 'undefined')
    { this.view.style.removeProperty (property); }
    else
    {
      if (util.isNumber (value)) value = '' + value; // IE need string
      this.view.style.setProperty (property, value, null);
    }
  },

  /**
   *  Modifies vs.ui.View view CSS style properties.Styles are passed as a hash
   *  of property-value pairs in which the properties are specified in their
   *  camelized form.
   *  <p>
   *  The method change the css inline style of the vs.ui.View view. Then
   *  it preempts css style defined in CSS stylesheets.
   *  @see vs.ui.View#addCssRules
   *  @see vs.ui.View#addCssRule if you want to
   *  modify CSS rules.
   *
   *  @example
   *  myObject.setStyles ({
   *    left: '0px', top: '0px', bottom: 'auto', 
   *    width: '100%', height: '50px'
   *  });
   *
   * @name vs.ui.View#setStyles
   * @function
   *
   * @param {Object} style The style to modify
   */
  setStyles : function (style)
  {
    if (!style) { return; }
    if (!this.view || !this.view.style)
    { return; }

    util.setElementStyle (this.view, style);
  },

  /**
   *  Add new CSS rules related to this component.
   *
   *  @example
   *  myObject.addCssRules ('.classname1', ['color: red', 'margin: 0px']);
   *  <=> to
   *  vs.util.addCssRules ('#' + myObject.id + ' .classname1', ['color: red', 'margin: 0px']);
   *
   * @name vs.ui.View#addCssRules
   * @function
   *
   * @param {String} selector CSS Selector
   * @param {Array} rules the array of rules
   */
  addCssRules : function (selector, rules)
  {
    util.addCssRules ('#' + this._id + ' ' + selector, rules);
  },

  /**
   *  Add new CSS rule related to this component.
   *
   *  @example
   *  myObject.addCssRule ('.classname1', 'color: red');
   *  <=> to
   *  vs.util.addCssRule ('#' + myObject.id + ' .classname1', 'color: red');
   *
   * @name vs.ui.View#addCssRule
   * @function
   *
   * @param {String} selector CSS Selector
   * @param {String} rule the rule using the following format:
   *   "prop_name: value"
   */
  addCssRule : function (selector, rule)
  {
    util.addCssRule ('#' + this._id + ' ' + selector, rule);
  },

/********************************************************************

********************************************************************/

  /**
   *  Force the redraw of your widget.
   *  <p>
   *  Some time a redraw is required to force the browser to rerender
   *  a part of you GUI or the entire GUI.
   *  Call redraw function on you Application object for a entire redraw or just
   *  on a specific widget.
   *
   * @name vs.ui.View#redraw
   * @function
   *
   * @param {Function} clb Optional function to call after the redraw
   */
  redraw : function (clb)
  {
    if (!this.view) { return; }
    var n = this.view, display = n.style.display, self = this;

    n.style.display = 'none';
    vs.scheduleAction (function()
    {
      if (display)
      { n.style.display = display; }
      else
      { n.style.removeProperty ('display'); }

      vs.scheduleAction (function()
      {
        self.refresh ();
        if (clb && util.isFunction (clb)) clb.call (self);
      });
    });
  },

  /**
   *  Displays the GUI Object
   *
   * @name vs.ui.View#show
   * @param {Function} clb a function to call a the end of show process
   * @function
   */
  show : function (clb)
  {
    if (!this.view) { return; }
    if (this._visible) { return; }
    if (!util.isFunction (clb)) clb = undefined; 

    if (this.__view_display)
    {
      this.view.style.display = this.__view_display;
    }
    else
    {
      this.view.style.removeProperty ('display');
    }
    this.__view_display = undefined;

    this.__is_hidding = false;
    this.__is_showing = true;

    if (this._show_animation)
    {
      this._show_animation.process (this, function () {
        this._show_object (clb);
      }, this);
    }
    else
    {
      this._show_object (clb);
    }
  },

  /**
   *  Show the GUI Object
   *
   * @private
   * @param {Function} clb a function to call a the end of show process
   * @function
   */
  _show_object : function (clb)
  {
    if (!this.view) { return; }
    this.__visibility_anim = undefined;

    if (!this.__is_showing) { return; }
    this.__is_showing = false;

    this._visible = true;
    var self = this;

    this.propertyChange ();
    if (this.__show_clb || clb)
    {
      if (this._show_animation)
      {
        if (this.__show_clb) this.__show_clb.call (this);
        if (clb) clb.call (this);
      }
      else
      {
        if (this.__show_clb) {
          vs.scheduleAction (function () {self.__show_clb.call (self);});
        }
        if (clb) {
          vs.scheduleAction (function () {clb.call (self);});
        }
      }
    }
  },

  /**
   *  Set the animation used when the view will be shown.
   *  <br/>
   * Options :
   * <ul>
   *   <li /> duration: animation duration for all properties
   *   <li /> timing: animation timing for all properties
   *   <li /> origin: Specifies the number of times an animation iterates.
   *   <li /> iterationCount: Sets the origin for the transformations
   *   <li /> delay: The time to begin executing an animation after it
   *          is applied
   * </ul>
   *
   *  Ex:
   *  @example
   *  myComp.setShowAnimation ([['translate', '0,0,0'], ['opacity', '1']]);
   *
   *  @example
   *  myAnim = new ABTranslateAnimation (50, 50);
   *  myComp.setShowAnimation (myAnim);
   *
   * @name vs.ui.View#setShowAnimation
   * @function
   *
   * @param animations {Array|vs.fx.Animation} array of animation <property,
   *        value>, or an vs.fx.Animation object
   * @param options {Object} list of animation options
   * @param clb {Function} the method to call when the animation end
   * @return {String} return the identifier of the animation process. You can
   *       use it to stop the animation.
   */
  setShowAnimation:function (animations, options, clb)
  {
    if (typeof animations === "undefined" || animations === null)
    {
      this._show_animation = null;
    }
    else
    {
      if (animations instanceof vs.fx.Animation)
      {
        this._show_animation = animations.clone ();
      }
      else if (util.isArray (animations))
      {
        this._show_animation = new vs.fx.Animation ();
        this._show_animation.setAnimations (animations);
      }
      else
      {
        console.warn ('vs.ui.View.setShowAnimation invalid parameters!');
        return;
      }
      if (options)
      {
        if (options.duration)
        { this._show_animation.duration = options.duration; }
        if (options.timing)
        { this._show_animation.timing = options.timing; }
        if (options.origin)
        { this._show_animation.origin = options.origin; }
        if (options.iterationCount)
        { this._show_animation.iterationCount = options.iterationCount; }
        if (options.delay)
        { this._show_animation.delay = options.delay; }
      }
    }
    if (util.isFunction (clb)) { this.__show_clb = clb; }
    else { this.__show_clb = clb; }
  },

  /**
   *  Hides the GUI Object
   *
   * @name vs.ui.View#hide
   * @param {Function} clb a function to call a the end of show process
   * @function
   */
  hide : function (clb)
  {
    if (!this.view) { return; }
    if (!this._visible && !this.__is_showing) { return; }
    if (!util.isFunction (clb)) clb = undefined; 

    this._visible = false;
    
    this.__is_showing = false;
    this.__is_hidding = true;
    
    if (this._hide_animation)
    {
      this._hide_animation.process (this, function () {
        this._hide_object (clb);
      }, this);
    }
    else
    {
      this._hide_object (clb);
    }
  },

  /**
   *  Hides the GUI Object
   *
   * @private
   * @function
   * @param {Function} clb a function to call a the end of show process
   */
  _hide_object: function (clb)
  {
    if (!this.view || this._visible) { return; }
    this.__visibility_anim = undefined;

    if (!this.__is_hidding) { return; }
    
    this.__is_hidding = false;
    if (this.view.style.display)
    {
      this.__view_display = this.view.style.display;
      if (this.__view_display === 'none')
      { this.__view_display = undefined; }
    }
    else
    {
      this.__view_display = undefined;
    }
    this.view.style.display = 'none'
    if (this.__hide_clb || clb)
    {
      if (this._show_animation)
      {
        if (this.__hide_clb) this.__hide_clb.call (this);
        if (clb) clb.call (this);
      }
      else
      {
        if (this.__hide_clb) {
          vs.scheduleAction (function () {self.__hide_clb.call (self);});
        }
        if (clb) {
          vs.scheduleAction (function () {clb.call (self);});
        }
      }
    }
    this.propertyChange ();
  },

  /**
   *  Set the animation used when the view will be hidden.
   * <br/>
   * Options :
   * <ul>
   *   <li /> duration: animation duration for all properties
   *   <li /> timing: animation timing for all properties
   *   <li /> origin: Specifies the number of times an animation iterates.
   *   <li /> iterationCount: Sets the origin for the transformations
   *   <li /> delay: The time to begin executing an animation after it
   *          is applied
   * </ul>
   *
   *  Ex:
   *  @example
   *  myComp.setHideAnimation ([['translate', '100px,0,0'], ['opacity', '0']], options);
   *
   *  @example
   *  myAnim = new ABTranslateAnimation (50, 50);
   *  myComp.setHideAnimation (myAnim, t);
   *
   * @name vs.ui.View#setHideAnimation
   * @function
   *
   * @param animations {Array|vs.fx.Animation} array of animation <property,
   *        value>, or an vs.fx.Animation object
   * @param options {Object} list of animation options
   * @param clb {Function} the method to call when the animation end
   * @return {String} return the identifier of the animation process. You can
   *       use it to stop the animation.
   */
  setHideAnimation: function (animations, options, clb)
  {
    if (typeof animations === "undefined" || animations === null)
    {
      this._hide_animation = null;
     }
    else
    {
      if (animations instanceof vs.fx.Animation)
      {
        this._hide_animation = animations.clone ();
      }
      else if (util.isArray (animations))
      {
        this._hide_animation = new vs.fx.Animation ();
        this._hide_animation.setAnimations (animations);
      }
      else
      {
        console.warn ('vs.ui.View.setHideAnimation invalid parameters!');
        return;
      }
      if (options)
      {
        if (options.duration)
        { this._hide_animation.duration = options.duration; }
        if (options.timing)
        { this._hide_animation.timing = options.timing; }
        if (options.origin)
        { this._hide_animation.origin = options.origin; }
        if (options.iterationCount)
        { this._hide_animation.iterationCount = options.iterationCount; }
        if (options.delay)
        { this._hide_animation.delay = options.delay; }
      }
    }
    if (util.isFunction (clb)) { this.__hide_clb = clb; }
    else { this.__hide_clb = clb; }
  },

/********************************************************************
                  state management
********************************************************************/

  /**
   *  Set the visibility of the vs.ui.View.
   *
   *  <p>
   *  @example
   *  myObject.setVisible (false);
   *
   * @name vs.ui.View#setVisible
   * @function
   *
   * @param {Boolean} visibility The visibility can be 'true' or 'false'.
   */
  setVisible: function (visibility)
  {
    if (!this.view) { return; }

    util.setElementVisibility (this.view, visibility);
  },

/********************************************************************

********************************************************************/
  /**
   *  Checks whether the vs.ui.View view has the given CSS className.
   *
   *  <p>
   *  @example
   *  myObject.hasClassName ('selected');
   *  // -> true | false
   *
   * @name vs.ui.View#hasClassName
   * @function
   *
   * @param {String} className the className to check
   * @return {Boolean} true if the view has the given className
   */
  hasClassName: function (className)
  {
    if (!this.view) { return false; }

    return util.hasClassName (this.view, className);
  },

  /**
   *  Adds a CSS classname to vs.ui.View view.
   *
   *  <p>
   *  @example
   *  myObject.addClassName ('selected');
   *  myObject.addClassName ('selected', 'small');
   *
   * @name vs.ui.View#addClassName
   * @function
   *
   * @param {String} className the className to add
   */
  addClassName: function ()
  {
    if (!this.view) { return; }

    var args = Array.prototype.slice.call (arguments);
    args.unshift (this.view);
    util.addClassName.apply (this.view, args);
  },

  /**
   *  Removes CSS className
   *
   *  <p>
   *  @example
   *  myObject.removeClassName ('selected');
   *  myObject.removeClassName ('selected', 'small');
   *
   * @name vs.ui.View#removeClassName
   * @function
   *
   * @param {String} className the className to add
   */
  removeClassName: function (className)
  {
    if (!this.view) { return; }

    var args = Array.prototype.slice.call (arguments);
    args.unshift (this.view);
    util.removeClassName.apply (this.view, args);
  },

  /**
   *  Toggle CSS className
   *
   *  <p>
   *  @example
   *  myObject.toggleClassName ('selected');
   *
   * @name vs.ui.View#toggleClassName
   * @function
   *
   * @param {String} className the className to add/remove
   */
  toggleClassName: function (className)
  {
    if (!this.view || !util.isString (className)) { return; }

    util.toggleClassName (this.view, className);
  },

/********************************************************************

********************************************************************/

  /**
   * @protected
   * @function
   */
  _propagateToParent : function (e)
  {
    if (this._bubbling && this.__parent && this.__parent.handleEvent)
    {
      this.__parent.handleEvent (e);
    }
  },

  /**
   * @name vs.ui.View#notifyToParent
   * @function
   */
  notifyToParent : function (e)
  {
    if (!this.__parent) { return; }
    if (this.__parent.handleEvent)
    {
      this.__parent.handleEvent (e);
    }
    else if (this.__parent.notify)
    {
      this.__parent.notify (e);
    }
  },

  /**
   * Did enable delegate
   * @name vs.ui.View#_didEnable
   * @protected
   */
   _didEnable : function () {},

  /*****************************************************************
   *                Animation methods
   ****************************************************************/

  /**
   *  Animate the component view.
   *
   *  Ex:
   *  @example
   *  myComp.animate ([['translate', '100px,0,0'], ['opacity', '0']]);
   *
   *  @example
   *  myAnim = new ABTranslateAnimation (50, 50);
   *  myComp.animate (myAnim); //<=> myAnim.process (myAnim);
   *
   * Options :
   * <ul>
   *   <li /> duration: animation duration for all properties
   *   <li /> timing: animation timing for all properties
   *   <li /> origin: Specifies the number of times an animation iterates.
   *   <li /> iterationCount: Sets the origin for the transformations
   *   <li /> delay: The time to begin executing an animation after it
   *          is applied
   * </ul>
   *
   * @name vs.ui.View#animate
   * @function
   *
   * @param animations {Array|vs.fx.Animation} array of animation
   *     <property, value>, or an vs.fx.Animation object
   * @param options {Object} list of animation options
   * @param clb {Function} the method to call when the animation end
   * @return {String} return the identifier of the animation process. You can
   *       use it to stop the animation.
   */
  animate: function (animations, options, clb)
  {
    var anim;
    if (animations instanceof vs.fx.Animation)
    {
      anim = animations
    }
    else if (util.isArray (animations))
    {
      var anim = new vs.fx.Animation ();
      anim.setAnimations (animations);
    }
    else
    {
      console.warn ('vs.ui.View.animate invalid parameters!');
      return;
    }
    if (options)
    {
      if (options.duration) { anim.duration = options.duration; }
      if (options.timing) { anim.timing = options.timing; }
      if (options.origin) { anim.origin = options.origin; }
      if (options.iterationCount)
      { anim.iterationCount = options.iterationCount; }
      if (options.delay) { anim.delay = options.delay; }
    }
    return anim.process (this, clb, this);
  },

  /*****************************************************************
   *                Transformation methods
   ****************************************************************/

  /**
   *  Move the view in x, y.
   *
   * @name vs.ui.View#translate
   * @function
   *
   * @param x {int} translation over the x axis
   * @param y {int} translation over the y axis
   */
  translate: function (x, y)
  {
    if (!util.isNumber (x) || !util.isNumber (y)) { return };
    if (this.__view_t_x === x && this.__view_t_y === y) { return; }

    this.__view_t_x = x;
    this.__view_t_y = y;

    this._applyTransformation ();
  },

  /**
   *  Rotate the view about the horizontal and vertical axes.
   *  <p/>The angle units is radians.
   *
   * @name vs.ui.View#rotate
   * @function
   *
   * @param r {float} rotion angle
   */
  rotate: function (r)
  {
    if (!util.isNumber (r)) { return };

    if (this._rotation === r) { return; }

    this._rotation = r;

    this._applyTransformation ();
  },

  /**
   *  Scale the view
   *  <p/>The scale is limited by a max and min scale value.
   *
   * @name vs.ui.View#scale
   * @function
   *
   * @param s {float} scale value
   */
  scale: function (s)
  {
    if (!util.isNumber (s)) { return };

    if (s > this._max_scale) { s = this._max_scale; }
    if (s < this._min_scale) { s = this._min_scale; }
    if (this._scaling === s) { return; }

    this._scaling = s;

    this._applyTransformation ();
  },

  /**
   *  Define a new transformation matrix, using the transformation origin
   *  set as parameter.
   * @public
   * @function
   *
   * @param {Object} origin is a object reference a x and y position
   */
  setNewTransformOrigin : function (origin)
  {
    if (!origin) { return; }
    if (!util.isNumber (origin.x) || !util.isNumber (origin.y)) { return; }

    this.flushTransformStack ();
    
    this._transform_origin = [origin.x, origin.y];
  },

  /**
   *  Flush all current transformation, into the transformation stack.
   * @public
   * @function
   */
  flushTransformStack : function ()
  {
    // Save current transform into a matrix
    var matrix = new vs.CSSMatrix ();
    matrix = matrix.translate
      (this._transform_origin [0], this._transform_origin [1], 0);
    matrix = matrix.translate (this.__view_t_x, this.__view_t_y, 0);
    matrix = matrix.rotate (0, 0, this._rotation);
    matrix = matrix.scale (this._scaling, this._scaling, 1);
    matrix = matrix.translate
      (-this._transform_origin [0], -this._transform_origin [1], 0);

    if (!this._transforms_stack) this._transforms_stack = matrix;
    {
      this._transforms_stack = matrix.multiply (this._transforms_stack);
      delete (matrix);
    }

    // Init a new transform space
    this.__view_t_x = 0;
    this.__view_t_y = 0;
    this._scaling = 1;
    this._rotation = 0;
  },

  /**
   * Push a new transformation matrix into your component transformation
   * stack.
   *
   * @public
   * @function
   *
   * @param {vs.CSSMatrix} matrix the matrix you want to add
   */
  pushNewTransform : function (matrix)
  {
    if (!matrix) { return; }

    if (!this._transforms_stack) this._transforms_stack = matrix;
    else
    {
      this._transforms_stack = matrix.multiply (this._transforms_stack);
    }
  },

  /**
   *  Remove all previous transformations set for this view
   * @public
   * @function
   */
  clearTransformStack : function ()
  {
    if (this._transforms_stack) delete (this._transforms_stack);
    this._transforms_stack = undefined;
  },

  /**
   *  Return the current transform matrix apply to this graphic Object.
   * @public
   * @function
   * @return {vs.CSSMatrix} the current transform matrix
   */
  getCTM: function ()
  {
    var matrix, identity = new vs.CSSMatrix ();

    // apply current transformation
    matrix = identity.translate (
      this._transform_origin [0] + this.__view_t_x,
      this._transform_origin [1] + this.__view_t_y, 0
    );
    matrix = matrix.multiply (identity.rotate (0, 0, this._rotation));
    matrix = matrix.scale (this._scaling, this._scaling, 1);
    matrix = matrix.translate (
      -this._transform_origin [0],
      -this._transform_origin [1],
      0
    );

    // apply previous transformations and return the matrix
    if (this._transforms_stack) return matrix.multiply (this._transforms_stack);
    else return matrix;
  },

  /**
   *  Returns the current transform combination matrix generate by the
   *  hierarchical parents of this graphic Object.
   *  Its returns the multiplication of the parent's CTM and parent of parent's
   *  CTM etc.
   *  If the component has no parent it returns the identity matrix.
   * @public
   * @function
   * @return {vs.CSSMatrix} the current transform matrix
   */
  getParentCTM: function ()
  {

    function multiplyParentTCM (parent)
    {
      // no parent return identity matrix
      if (!parent) return new vs.CSSMatrix ();
      // apply parent transformation matrix recurcively
      return multiplyParentTCM (parent.__parent).multiply (parent.getCTM ());
    }

    return multiplyParentTCM (this.__parent);
  },

  /**
   * @protected
   * @function
   */
  _applyTransformation: function ()
  {
    var
      matrix = this.getCTM (),
      transform = matrix.getMatrix3dStr ();

    if (this._magnet === View.MAGNET_CENTER)
    {
      transform += " translate(-50%,-50%)";
    }

    setElementTransform (this.view, transform);
    delete (matrix);
  }
};
util.extend (View.prototype, RecognizerManager);
util.extendClass (View, core.EventSource);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (View, {

  'size': {
    /**
     * Getter|Setter for size. Gives access to the size of the GUI Object
     * @name vs.ui.View#size
     *
     * @type {Array.<number>}
     */
    set : function (v)
    {
      if (!util.isArray (v) || v.length !== 2) { return; }
      if (!util.isNumber (v[0]) || !util.isNumber(v[1])) { return; }

      this._size [0] = v [0];
      this._size [1] = v [1];

      if (!this.view) { return; }
      this._updateSizeAndPos ();
    },

    /**
     * @ignore
     * @type {Array.<number>}
     */
    get : function ()
    {
      return this._size.slice ();
    }
  },

  'position': {
    /**
     * Getter|Setter for position. Gives access to the position of the GUI
     * Object
     * @name vs.ui.View#position
     *
     * @type Array
     */
    set : function (v)
    {
      if (!v) { return; }
      if (!util.isArray (v) || v.length != 2) { return; }
      if (!util.isNumber (v[0]) || !util.isNumber(v[1])) { return; }

      this._pos [0] = v [0];
      this._pos [1] = v [1];

      if (!this.view) { return; }
      this._updateSizeAndPos ();
    },

    /**
     * @ignore
     * @type {Array.<number>}
     */
    get : function ()
    {
      return this._pos.slice ();
    }
  },

  'autosizing': {

    /**
     * Set size and position behavior according parent size.
     * @name vs.ui.View#autosizing
     *
     * @type Array
     */
    set : function (v)
    {
      if (!v) { return; }
      if (!util.isArray (v) || v.length != 2) { return; }
      if (!util.isNumber (v[0]) || !util.isNumber(v[1])) { return; }

      if (this._autosizing [0] === v [0] && this._autosizing [1] === v [1])
      { return; }

      this._autosizing [0] = v [0];
      this._autosizing [1] = v [1];

      if (!this.view) { return; }
      this._updateSizeAndPos ();
    }
  },

  'magnet': {

    /**
     * Set magnet
     * @name vs.ui.View#magnet
     *
     * @type Number
     */
    set : function (code)
    {
      if (this._magnet === code) return;
      if (!util.isNumber (code) || code < 0 || code > 5) return;
      this._setMagnet (code);
    }
  },

  'visible': {

    /**
     * Hide or show the object.
     * obj.visible = true <=> obj.show (), obj.visible = false <=> obj.hide (),
     * @name vs.ui.View#visible
     * @type {boolean}
     */
    set : function (v)
    {
      if (v)
      { this.show (); }
      else
      { this.hide (); }
    },

    /**
     * Return true is the object is visible. False otherwise.
     * @ignore
     * @type {boolean}
     */
    get : function ()
    {
      return this._visible;
    }
  },

  'bubbling': {

    /**
     * Allow pointer event bubbling between views (by default set to false)
     * @name vs.ui.View#bubbling
     * @type boolean
     */
    set : function (v)
    {
      if (v) { this._bubbling = true; }
      else { this._bubbling = false; }
    }
  },

  'enable': {

    /**
     * Activate or deactivate a view.
     * @name vs.ui.View#enable
     * @type {boolean}
     */
    set : function (v)
    {
      if (v && !this._enable)
      {
        this._enable = true;
        this.removeClassName ('disabled');
        this._didEnable ();
      }
      else if (!v && this._enable)
      {
        this._enable = false;
        this.addClassName ('disabled');
        this._didEnable ();
      }
    },

    /**
     * @ignore
     * @return {boolean}
     */
    get : function ()
    {
      return this._enable;
    }
  },

  'opacity': {

    /**
     * Change view opacity.
     * value is include in this range [0, 1]
     * @name vs.ui.View#opacity
     * @type {number}
     */
    set : function (v)
    {
      if (!util.isNumber (v)) return;
      if (v < 0 || v > 1) return;

      if (this.view) this.view.style.opacity = v;
      this._opacity = v;
    }
  },

  'translation': {

    /**
     * Translation vector [tx, ty]
     * <=> obj.translate (tx, ty)
     * @name vs.ui.View#translation
     * @type {Array}
     */
    set : function (v)
    {
      if (!util.isArray (v) || v.length !== 2) { return };

      this.translate (v[0], v[1]);
    },

    /**
     * @ignore
     * @type {Array}
     */
    get : function ()
    {
      return [this.__view_t_x, this.__view_t_y];
    }
  },

  'rotation': {

    /**
     * Rotation angle in degre
     * @name vs.ui.View#rotation
     * @type {float}
     */
    set : function (v)
    {
      this.rotate (v);
    },

    /**
     * @ignore
     * @type {float}
     */
    get : function ()
    {
      return this._rotation;
    }
  },

  'scaling': {

    /**
     * Scale the view
     * @name vs.ui.View#scaling
     * @type {float}
     */
    set : function (v)
    {
      this.scale (v);
    },

    /**
     * @ignore
     * @type {float}
     */
    get : function ()
    {
      return this._scaling;
    }
  },

  'minScale': {

    /**
     * Set the minimun scale value (default value is 0.5)
     * @name vs.ui.View#minScale
     * @type {float}
     */
    set : function (v)
    {
      if (!util.isNumber (v)) { return };
      this._min_scale = v;
      
      if (this._scaling < this._min_scale) { this.scale (this._min_scale); }
    },

    /**
     * @ignore
     * @type {float}
     */
    get : function ()
    {
      return this._min_scale;
    }
  },

  'maxScale': {

    /**
     * Set the maximum scale value (default value is 3)
     * @name vs.ui.View#maxScale
     * @type {float}
     */
    set : function (v)
    {
      if (!util.isNumber (v)) { return };
      this._max_scale = v;
      
      if (this._scaling > this._max_scale) { this.scale (this._max_scale); }
    },

    /**
     * @ignore
     * @type {float}
     */
    get : function ()
    {
      return this._max_scale;
    }
  },

  'transformOrigin': {

    /**
     * This property allows you to specify the origin of the 2D transformations.
     * Values are pourcentage of the view size.
     * <p>
     * The property is set by default to [50, 50], which is the center of
     * the view.
     * @name vs.ui.View#transformOrigin
     * @type Array.<number>
     */
    set : function (v)
    {
      if (!util.isArray (v) || v.length !== 2) { return; }
      if (!util.isNumber (v[0]) || !util.isNumber (v[1])) { return; }

      this._transform_origin [0] = v [0];
      this._transform_origin [1] = v [1];

//      var origin_str = this._transform_origin [0] + '% ';
//      origin_str += this._transform_origin [1] + '%';
//      this.view.style ['-webkit-transform-origin'] = origin_str;
    },

    /**
     * @ignore
     * @return {Array}
     */
    get : function ()
    {
      return this._transform_origin.slice ();
    }
  },

  'showAnimmation': {

    /**
     * Set the Animation when the view is shown
     * @name vs.ui.View#showAnimmation
     * @type {vs.fx.Animation}
     */
    set : function (v)
    {
      this.setShowAnimation (v);
    }
  },

  'hideAnimation': {

    /**
     * Set the Animation when the view is hidden
     * @name vs.ui.View#hideAnimation
     * @type {vs.fx.Animation}
     */
    set : function (v)
    {
      this.setHideAnimation (v);
    }
  },

  'layout': {

    /**
     * This property allows you to specify a layout for the children
     * <p>
     * <ul>
     *    <li /> vs.ui.View.DEFAULT_LAYOUT
     *    <li /> vs.ui.View.HORIZONTAL_LAYOUT
     *    <li /> vs.ui.View.VERTICAL_LAYOUT
     *    <li /> vs.ui.View.ABSOLUTE_LAYOUT
     *    <li /> vs.ui.View.FLOW_LAYOUT
     * </ul>
     * @name vs.ui.View#layout
     * @type String
     */
    set : function (v)
    {
      if (v !== View.HORIZONTAL_LAYOUT &&
          v !== View.DEFAULT_LAYOUT &&
          v !== View.ABSOLUTE_LAYOUT &&
          v !== View.VERTICAL_LAYOUT &&
          v !== View.FLOW_LAYOUT &&
          v !== View.LEGACY_HORIZONTAL_LAYOUT &&
          v !== View.LEGACY_ABSOLUTE_LAYOUT &&
          v !== View.LEGACY_VERTICAL_LAYOUT &&
          v !== View.LEGACY_FLOW_LAYOUT && v)
      {
        console.error ("Unsupported layout '" + v + "'!");
        return;
      }

      if (this._layout)
      {
        this.removeClassName (this._layout);
      }
      if (!v || v.indexOf ("_layout") !== -1) this._layout = v;
      else this._layout = v + "_layout";
      if (this._layout)
      {
        this.addClassName (this._layout);
      }
    },
  },

  'innerHTML': {

    /**
     * This property allows to define both the HTML code and the text
     * @name vs.ui.View#innerHTML
     * @type String
     */
    set : function (v)
    {
      if (!this.view) return;

      util.safeInnerHTML (this.view, v);
    },
  }
});

View._ref_template_reg = /(\w+)#(\w+)/;

function getDeviceCSSCode ()
{	
	var el = document.createElement('div'), val;
	el.className = 'device_test';
	document.body.appendChild (el);
	
	val = document.defaultView.getComputedStyle (el,null).getPropertyValue("margin-top");

	document.body.removeChild (el);

	return parseInt (val || 0, 10);
}

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.View = View;
View.getDeviceCSSCode = getDeviceCSSCode;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/** @preserve

  The code include code from :
  
  Copyright (c) 2009 Matteo Spinelli, http://cubiq.org/
  Released under MIT license
  http://cubiq.org/dropbox/mit-license.txt
  Version 3.4.5 - Last updated: 2010.07.04
*/

/**
 * @private
 * @name Scrollbar
 */
function Scrollbar (dir, wrapper, fade, shrink)
{
	this.dir = dir;
	this.fade = fade;
	this.shrink = shrink;
	this.id = core.createId ();

	// Create main scrollbar
	this.bar = document.createElement ('div');

	var size, ctx;
	this.bar.className = 'scrollbar ' + dir;

	// Create scrollbar wrapper
	this.wrapper = document.createElement ('div');
	this.wrapper.className = 'wrapper_scrollbar ' + dir;

	this.wrapper.style.position = 'absolute';
	this.wrapper.style ['-webkit-mask'] = '-webkit-canvas(' + this.id + ')';
	this.wrapper.style ['-webkit-transition-duration'] = fade ? '300ms' : '0';

	// Add scrollbar to the DOM
	this.wrapper.appendChild (this.bar);
	
	wrapper.appendChild (this.wrapper);
	
	if (this.dir === 'horizontal')
	{
		size = this.wrapper.offsetWidth;
		ctx = document.getCSSCanvasContext ("2d", this.id, size, 5);
		ctx.fillStyle = "rgb(0,0,0)";
		ctx.beginPath ();
		ctx.arc (2.5, 2.5, 2.5, Math.PI/2, -Math.PI/2, false);
		ctx.lineTo (size-2.5, 0);
		ctx.arc (size-2.5, 2.5, 2.5, -Math.PI/2, Math.PI/2, false);
		ctx.closePath ();
		ctx.fill ();
	} 
	else
	{
		size = this.wrapper.offsetHeight;
		ctx = document.getCSSCanvasContext ("2d", this.id, 5, size);
		ctx.fillStyle = "rgb(0,0,0)";
		ctx.beginPath();
		ctx.arc (2.5, 2.5, 2.5, Math.PI, 0, false);
		ctx.lineTo (5, size-2.5);
		ctx.arc (2.5, size-2.5, 2.5, 0, Math.PI, false);
		ctx.closePath();
		ctx.fill();
	}
}

Scrollbar.prototype = {

	init: function (scroll, size)
	{
		this.maxSize = this.dir === 'horizontal' ? this.wrapper.clientWidth : this.wrapper.clientHeight;
		this.size = Math.round(this.maxSize * this.maxSize / size);
		this.maxScroll = this.maxSize - this.size;
		this.toWrapperProp = this.maxScroll / (scroll - size);
		this.bar.style[this.dir === 'horizontal' ? 'width' : 'height'] = this.size + 'px';
	},
	
	setPosition: function (pos)
	{
		pos = this.toWrapperProp * pos;
		
		if (pos < 0)
		{
			pos = this.shrink ? pos + pos * 3 : 0;
			if (this.size + pos < 5)
			{
				pos = -this.size + 5;
			}
		}
		else if (pos > this.maxScroll)
		{
			pos = this.shrink ? pos + (pos-this.maxScroll)*3 : this.maxScroll;
			if (this.size + this.maxScroll - pos < 5) {
				pos = this.size + this.maxScroll - 5;
			}
		}

    if (SUPPORT_3D_TRANSFORM)
      pos = this.dir === 'horizontal' ? 'translate3d(' + Math.round(pos) + 'px,0,0)' : 'translate3d(0,' + Math.round(pos) + 'px,0)';
    else
      pos = this.dir === 'horizontal' ? 'translate(' + Math.round(pos) + 'px,0)' : 'translate(0,' + Math.round(pos) + 'px)';
		
    setElementTransform (this.bar, pos);
  },

	show: function ()
	{
		this.wrapper.style.webkitTransitionDelay = '0';
		this.wrapper.style.opacity = '1';
	},

	hide: function ()
	{
		this.wrapper.style.webkitTransitionDelay = '200ms';
		this.wrapper.style.opacity = '0';
	},
	
	remove: function ()
	{
		this.wrapper.parentNode.removeChild (this.wrapper);
		return null;
	}
};/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  All application inherit from Application class.<br/>
 *  This is the root component from which all other components (widgets, ...)
 *  are dependent on.
 *  @class
 *  All application inherit from Application class. <br/>
 *  This is the root component from which all other components (widgets, ...)
 *  are dependent on.
 *  <p>
 *  The class offers you a set of usefull method for laoding
 *  Javascript or CSS, know the current GUI orientation...
 *  <p>
 *  You should not create your own Application instante, because it is
 *  automatically generated by ViniSketch Designer.
 *
 *  @author David Thevenin
 *
 *  @extends vs.ui.View
 * @name vs.ui.Application
 *  @constructor
 *  Main constructor
 *
 * @param {string} type the event type [optional]
*/
var Application = function (config)
{
  this._layout = undefined;
  
  this.parent = View;
  this.parent (config);
  this.constructor = Application;
};

/**
 * @private
 * @const
 */
Application.CSS_DEFAULT = 0;

/**
 * @private
 * @const
 */
Application.CSS_IOS = 5;

/**
 * @private
 * @const
 */
Application.CSS_ANDROID = 9;

/**
 * @private
 * @const
 */
Application.CSS_MEEGO = 10;

/**
 * @private
 * @const
 */
Application.CSS_WP7 = 6;

/**
 * @private
 * @const
 */
Application.CSS_SYMBIAN = 8;

/**
 * @private
 * @const
 */
Application.CSS_BLACKBERRY = 7;

/**
 * @private
 * @const
 */
Application.CSS_PURE = 100;

/**
 * @private
 * @const
 */
Application.CSS_FLAT = 101;

/**
 * @private
 * @const
 */
Application.CSS_HOLO = 102;

/**
 * @private
 * @const
 */
Application.CSS_IOS7 = 103;

/**
 * @private
 */
var Application_applications = {};

var ORIENTATION_CHANGE_EVT =
  'onorientationchange' in window ? 'orientationchange' : 'resize';

vs.Application_applications = Application_applications;

Application.prototype = {
  
  /*****************************************************************
   *                Private members
   ****************************************************************/

  /**
   * @protected
   * @type {boolean}
   */
  _prevent_scroll : true,

  /*****************************************************************
   *
   ****************************************************************/
  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    Application_applications [this.id] = this;

    View.prototype.initComponent.call (this);
    this.preventScroll = true;

    if (this.view instanceof HTMLHtmlElement)
    {
      var html = this.view;
      html._comp_ = undefined;
    
      // by default select the body element
      this.view = html.querySelector ('body');
      if (!this.view)
      {
        console.error ("Invalid Application view");
        return;
      }
      this.view._comp_ = this;

      html.removeAttribute ('id');
      html.removeAttribute ('x-hag-ref');
      html.removeAttribute ('x-hag-comp');
    }
    this.view.setAttribute ('id', this.id);
    this.view.setAttribute ('x-hag-ref', this.id);
    this.view.setAttribute ('x-hag-comp', this.id);

    var self = this;
    window.addEventListener (ORIENTATION_CHANGE_EVT, function (e)
    {
      var orientation = window.orientation;
      if (!util.isNumber (orientation)) {
        if (window.outerWidth >= window.outerHeight) {
          orientation = 90; // LANDSCAPE
        }
        else {
          orientation = 0; // PORTRAIT
        }
      }
      
      var target_id =
        window.deviceConfiguration.setOrientation (orientation);
      if (target_id) {
        self.propagate ('deviceChanged', target_id, null, true);
      }
    });
  },
  
  /**
   * Exit and terminate the application.
   * @name vs.ui.Application#exit 
   * @function
   */
  exit : function ()
  {
    Application.exit ()
  },
  
  /**
   * @protected
   * @name vs.ui.Application#applicationStarted 
   * @function
   */
  applicationStarted : function ()
  { },
  
  /**
   * @protected
   * @function
   */
  _updateSizeAndPos: function ()
  {
    this.view.style.width = this._size[0] + 'px';;
    this.view.style.height = this._size[1] + 'px';;
    this.view.style.right = 'auto';
    this.view.style.bottom = 'auto';

    this.view.style.left = this._pos[0] + 'px';
    this.view.style.top = this._pos[1] + 'px';
    this.view.style.right = 'auto';
    this.view.style.bottom = 'auto';
  },
  
  /**
   * Sets the active stylesheet for the HTML document according to
   * the specified pid.
   *
   * @private
   *
   * @name vs.ui.Application#setActiveStyleSheet 
   * @function
   * @param {string} title
   */
  setActiveStyleSheet : function (pid)
  {
    Application.setActiveStyleSheet (pid);
    this.propagate ('deviceChanged', pid, null, true);
  },
  
  /**
   * @protected
   *
   * @name vs.ui.Application#orientationWillChange 
   * @function
   * @param {number} orientation = {0, 180, -90, 90}
   */
  orientationWillChange: function (orientation)
  { },
    
  /**
   *  @public
   *  Build the default dataflow associated to the application.
   *  If you have created your own dataflow (with new vs.core.Dataflow), you
   *  have to build it explicitly.
   *
   * @name vs.ui.Application#buildDataflow 
   * @function
   */
  buildDataflow: function ()
  {
    vs._default_df_.build ();
  },
    
  /**
   *  Dynamically load a script into your application.
   *  <p/>
   *  When the download is completed, the event 'scriptloaded' is fired. <br/>
   *  If a error occurs, nothing happend, then you have to manage by
   *  your own possible error load.
   *  <p/>
   *  The callback function will receive as parameter a event like that:<br/>
   *  {type: 'scriptloaded', data: path}
   *  <p/>
   *  @example
   *  myApp.bind ('scriptloaded', ...);
   *  myApp.loadScript ("resources/other.css");
   *
   * @name vs.ui.Application#loadScript 
   * @function
   * @param {string} path the script url [mandatory]
   */
  loadScript : function (path)
  {
    var self = this, endScriptLoad = function (path)
    {
      var i, l, data, ab_event;
      if (!path) { return; }
      
      self.propagate ('scriptloaded', path);
    };
    
    util.importFile (path, document, endScriptLoad, "js");
  },
  
  /**
   *  Dynamically load a CSS into your application.
   *
   *  When the download is completed, the event 'cssloaded' is fired <br/>
   *  If a error occurs, nothing happend, then you have to manage by
   *  your own possible error load.
   *  <p/>
   *  The callback function will receive as parameter a event like that:<br/>
   *  {type: 'cssloaded', data: path}
   *
   *  @example
   *  myApp.bind ('cssloaded', ...);
   *  myApp.loadCSS ("resources/other.css");
   *
   * @name vs.ui.Application#loadCSS 
   * @function
   *
   * @param {string} path the css url [mandatory]
   */
  loadCSS : function (path)
  {
    var self = this, endCssLoad = function (path)
    {
      var i, l, data, ab_event;
      if (!path) { return; }
      
      self.propagate ('cssloaded', path);
    };

    util.importFile (path, document, endCssLoad, "css");
  }  
};
util.extendClass (Application, View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (Application, {
  'size': {
    /** 
     * Getter|Setter for size.<br/>
     * Gives access to the size of the Application
     * @name vs.ui.Application#size 
     *
     * @type {Array.<number>}
     */ 
    set : function (v)
    {
      if (!v) { return; }
      if (!util.isArray (v) || v.length !== 2) { return; }
      if (!util.isNumber (v[0]) || !util.isNumber(v[1])) { return; }
      this._size [0] = v [0];
      this._size [1] = v [1];
      
      if (!this.view) { return; }
      this._updateSizeAndPos ();
      
      window.resizeTo (this._size [0], this._size [1]);
    },
    
    /**
     * @ignore
     * @type {Array.<number>}
     */
    get : function ()
    {
      if (this.view && this.view.parentNode)
      {
        this._size [0] = this.view.offsetWidth;
        this._size [1] = this.view.offsetHeight;
      }
      return this._size.slice ();
    }
  },
  'preventScroll': {
    /** 
     * Getter|Setter for page scrolling cancel.<br/>
     * Set to true to cancel scrolling behavior and false to have the
     * normal behavior.<br/>
     * By default, the property is set to true.
     * 
     * @name vs.ui.Application#preventScroll 
     *
     * @type {boolean}
     */ 
    set : function (pScroll)
    {
      if (pScroll)
      {
        this._prevent_scroll = true;
        document.preventScroll = pScroll;
      }
      else
      {
        this._prevent_scroll = false;
        document.preventScroll = pScroll;
      }
    },
  
    /**
     * @ignore
     * @type {boolean}
     */
    get : function ()
    {
      this._prevent_scroll = document.preventScroll;
      return this.__prevent_scroll;
    }
  }
});

/**
 * Exit and terminate the application.
 * @name vs.ui.Application.exit 
 */
Application.exit = function ()
{
  if (window.close)
  {
    window.close ();
  }
}

/**
 * @name vs.ui.Application.configureDevice 
 */
Application.configureDevice = function ()
{
  function setDeviceCSS () {

    var name = (window.target_css)?
      window.target_css [window.deviceConfiguration.targetId]:'';

    if (!name) name = "default";
  
    function importCSS (path, node) {
      var css_style = document.createElement ("link");
      css_style.setAttribute ("rel", "stylesheet");
      css_style.setAttribute ("type", "text/css");
      css_style.setAttribute ("href", path);
      css_style.setAttribute ("media", "screen");

      if (node)
        document.head.insertBefore (css_style, node);
      else
        document.head.appendChild (css_style);
    }
    
    var links = document.head.querySelectorAll ('link'), node;
    for (var i = 0; i < links.length; i++) {
      node = links.item (i);
      if (node.getAttribute ('href').indexOf ("vs_ui.css") !== -1) {
        node = node.nextElementSibling;
        break;
      }
      else node = null;
    }
  
    if (name == 'default') {
      switch (window.deviceConfiguration.os) {
        case DeviceConfiguration.OS_IOS:
          importCSS ("lib/css/vs_ui_ios.css", node);
        break;
   
        case DeviceConfiguration.OS_ANDROID:
          importCSS ("lib/css/vs_ui_android.css", node);
        break;
      }
    }
    else importCSS ("lib/css/vs_ui_" + name + ".css", node);
  }
  
  var did = window.deviceConfiguration.generateDeviceId (true), tid, size;
  window.deviceConfiguration.deviceId = did;
  window.deviceConfiguration.virtualScreenSize = null;
  
  if (window.target_device_ids) for (tid in window.target_device_ids) {
    var dids = window.target_device_ids [tid];
    if (dids.indexOf (did) !== -1) {
      window.deviceConfiguration.targetId = tid;
      window.deviceConfiguration.setOrientation (window.orientation || 0, true);

      setDeviceCSS ();
      return;
    }
  }

  if (deviceConfiguration.screenSize === DeviceConfiguration.SS_4_INCH)
    tid = "phone3_4";
  if (deviceConfiguration.screenSize === DeviceConfiguration.SS_7_INCH)
    tid = "tablet7";  
  if (deviceConfiguration.screenSize === DeviceConfiguration.SS_10_INCH)
    tid = "phone10";
  
  if (deviceConfiguration.orientation === 0 ||
      deviceConfiguration.orientation === 90)
    tid += "_p"; 

  if (deviceConfiguration.orientation === 180 ||
      deviceConfiguration.orientation === -180)
    tid += "_l";

  if (window.target_device_ids && window.target_device_ids [tid]) {
    window.deviceConfiguration.targetId = tid;
   
    window.deviceConfiguration.setOrientation (window.orientation || 0, true);

    setDeviceCSS ();
    return;
  }

  size = getScreenSize (DeviceConfiguration.SS_7_INCH);

  if (deviceConfiguration.screenSize === DeviceConfiguration.SS_10_INCH) {
    tid = "tablet7";
  }

  if (deviceConfiguration.orientation === 0 ||
      deviceConfiguration.orientation === 90)
    tid += "_p"; 

  if (deviceConfiguration.orientation === 180 ||
      deviceConfiguration.orientation === -180)
    tid += "_l";

  if (window.target_device_ids && window.target_device_ids [tid]) {
    window.deviceConfiguration.targetId = tid;
    window.deviceConfiguration.virtualScreenSize = size;
    window.deviceConfiguration.setOrientation (window.orientation || 0, true);

    setDeviceCSS ();
    return;
  }

  tid = "phone3_4";
  size = getScreenSize (DeviceConfiguration.SS_4_INCH)

  if (deviceConfiguration.orientation === 0 ||
      deviceConfiguration.orientation === 90)
    tid += "_p"; 

  if (deviceConfiguration.orientation === 180 ||
      deviceConfiguration.orientation === -180)
    tid += "_l";

  if (window.target_device_ids && window.target_device_ids [tid]) {
    window.deviceConfiguration.targetId = tid;
    window.deviceConfiguration.virtualScreenSize = size;
    window.deviceConfiguration.setOrientation (window.orientation || 0, true);

    setDeviceCSS ();
    return;
  }
}

function getScreenSize (screenDef) {

  function get7Inch () {
    if (devicePixelRatio <= 1.2) { // 1 pixel ratio
      return [600, 960];
    }
    else if (devicePixelRatio <= 1.4) { // 1.33 pixel ratio
      return [800, 1280];
    }
    else if (devicePixelRatio <= 1.7) { // 1.5 pixel ratio
      return [900, 1440];
    }
    return [1200, 1920]; // 2 pixel ratio
  }

  function get4Inch () {
    if (devicePixelRatio <= 1.2) { // 1 pixel ratio
      return [320, 540];
    }
    else if (devicePixelRatio <= 1.4) { // 1.33 pixel ratio
      return [427, 720];
    }
    else if (devicePixelRatio <= 1.7) { // 1.5 pixel ratio
      return [480, 800];
    }
    return [720, 1080]; // 2 pixel ratio
  }

  switch (screenDef) {
    case DeviceConfiguration.SS_7_INCH:
      return get7Inch ();
    break

    case DeviceConfiguration.SS_4_INCH:
      return get4Inch ();
    break
  }
}

/**
 * Returns the current GUI orientation.
 * <p/>
 * Be careful this API does not return the device orientation, which can be
 * deferent from the GUI orientation.
 * <p/>
 * Use the orientation module to have access to the device orientation.
 *
 * @name vs.ui.Application.getOrientation 
 * 
 * @return {integer} returns a integer include in [-90, 0, 90, 180];
 * @public
 */
Application.getOrientation = function ()
{
  return window.deviceConfiguration.getOrientation ();
};

/**
 * @potected
 */
Application.start = function ()
{
  var key, obj;
  for (key in Application_applications)
  {
    obj = Application_applications [key];
    obj.propertyChange ();
    obj.applicationStarted ();
    vs.scheduleAction (function () {obj.refresh ();});
  }
  vs.scheduleAction (function () {vs._default_df_.build ();});
};

/**
 * @protected
 */
Application.stop = function ()
{
  // un peu bourin pour le moment
  var key, obj;
  for (key in Application_applications)
  {
    obj = Application_applications [key];
    util.free (obj);
  }
  Application_applications = {};

  for (var key in vs.core.Object._obs)
  {
    var obj = vs.core.Object._obs [key];
    vs.util.free (obj);
  }
};

/**
 * @private
 * @depretacted
 */
Application.sendStart = function ()
{
  console.log ("Application.sendStart is deprecated. Please use Application.start");
  Application.start ();
};

/**
 * @potected
 */
Application.propagate = function (spec, data)
{
  var key, obj;
  for (key in Application_applications) {
    obj = Application_applications [key];
    if (obj) obj.propagate (spec, data);
  }
};

/**
 *  Preload an array of GUI HTML templates.
 *  <p>
 *  When the developer uses createAndAddComponent method, the system will
 *  load the HTML GUI template associated to the component to create.
 *  This process can take times.<br>
 *  In order to minimize the latency, this class method allows to preload all 
 *  data related to a component.<br>
 *  This method should ne call when the application start.
 * 
 *  @example
 *  app.preloadTemplates (['GUICompOne', 'GUICompTwo']);
 * 
 * 
 * @name vs.ui.Application.preloadTemplates 
 * @param {Array.<String>} templates array of components names   
 */
Application.preloadTemplates = function (templates)
{
  for (var i = 0; i < templates.length; i++)
  {
    util.preloadTemplate (templates[i]);
  }
};

/**
 * @private
 */
var ImagePreloader = function (images)
{
  // for each image, call preload()
  for (var i = 0; i < images.length; i++ )
  {
    this.preload (images[i]);
  }
}
window.ImagePreloader = ImagePreloader;

/**
 * @private
 */
ImagePreloader.__image_path = {};

/**
 * @private
 */
ImagePreloader.prototype.preload = function (image)
{
  if (ImagePreloader.__image_path [image]) { return; }
  (new Image ()).src = image;
  ImagePreloader.__image_path [image] = true;
};

function preventBehavior (e)
{
//  window.scrollTo (0, 0);

  if (e.type == "touchstart" &&
      (e.target.tagName == "INPUT" ||
       e.target.tagName == "input" ||
       e.target.tagName == "TEXTAREA" ||
       e.target.tagName == "textarea"))
  {
    // on android do not cancel event otherwise the keyboard does not appear
    return;
  }

  e.preventDefault (); 
  return false;
};

/**
 *
 *
 * @name vs.ui.Application#mainViewVisibility 
 */
Application.prototype.mainViewVisibility = function (v)
{
};

/**
 *
 * @name vs.ui.Application#setImageBackground 
 */
Application.prototype.setImageBackground = function (path, name, type)
{
}

/**
 *
 * @name vs.ui.Application#loadingStart 
 */
Application.prototype.loadingStart = function (text)
{
};

/**
 *
 * @name vs.ui.Application#loadingStop 
 */
Application.prototype.loadingStop = function (v)
{
};

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.Application = Application;
/*
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/


/**
 *  The vs.ui.SplitView class
 *
 *  @extends vs.ui.View
 *  @class
 *  vs.ui.SplitView presents two views. According the screen orientation
 *  the two views are renders vertically (landscape mode) or the views
 *  are splited to optimize screen size. In Portrait mode, the first view
 *  his hidden from the splitview and draws on a PopOver View.
 *
 *  <p>
 *  Delegates:
 *  <ul>
 *    <li/>willHideView : function (vs.ui.View the view, vs.ui.PopOver popOver)
 *    <li/>willShowView : function (vs.ui.View the view, vs.ui.PopOver popOver)
 *  </ul>
 *  <p>
 *  <p>
 *  @example
 *  var splitView = new vs.ui.SplitView ();
 *  splitView.init ();
 *
 *  splitView.delegate = this;
 *  splitView.createAndAddComponent ('ManuPanel');
 *  splitView.createAndAddComponent ('MainPanel');
 *
 *  ...
 *
 *  willShowView : function (view, popOver)
 *  {
 *    this._popOver = null;
 *    ...
 *  },
 *  
 *  willHideView : function (view, popOver)
 *  {
 *    this._popOver = popOver;
 *    ...
 *  }
 *  
 *  @author David Thevenin
 * @name vs.ui.SplitView
 *
 *  @constructor
 *   Creates a new vs.ui.SplitView.
 *
 * @param {Object} config the configuration structure [mandatory]
*/
var SplitView = vs.core.createClass ({

  parent: vs.ui.View,

  properties: {
    "delegate": {
      /** 
       * Set the delegate.
       * It should implements following methods
       *  <ul>
       *    <li/>viewWillStartZooming : function (vs.ui.ScrollView the view)
       *    <li/>viewDidEndZooming : function (vs.ui.ScrollView the view, number scale)
       *  </ul>
       * @name vs.ui.SplitView#delegate 
       * @type {Object}
       */ 
      set : function (v)
      {
        this._delegate = v;
      }
    },
  
    "mode": {
      /** 
       * Set/get the split view mode (MOBILE, TABLET)
       * @name vs.ui.SplitView#mode 
       * @type {String}
       */ 
      set : function (v)
      {
        if (v !== SplitView.TABLET_MODE && v !== SplitView.MOBILE_MODE)
          return;
      
        this.removeClassName (this._mode);
        this._mode = v;
        this.addClassName (this._mode);
        if (this._orientation === SplitView.VERTICAL) this._set_orientation (0);
        else this._set_orientation (90);
      },
      
      get : function ()
      {
        return this._mode;
      }
    },
  
    "hideMainPanelButton": {
      /** 
       * Set the XXX
       * @name vs.ui.SplitView#hideMainPanelButton 
       * @type {vs.ui.View}
       */ 
      set : function (v)
      {
        this._hide_main_panel_button = v;
        if (this._mode == SplitView.TABLET_MODE)
        {
          this._hide_main_panel_button.hide ();
        }
        this._hide_main_panel_button.bind ('select', this);
      }
    },
  
    "showPopOverButton": {
      /** 
       * Set the XXX
       * @name vs.ui.SplitView#showPopOverButton 
       * @type {vs.ui.View}
       */ 
      set : function (v)
      {
        this._show_pop_over_button = v;
        if (this._mode == SplitView.MOBILE_MODE)
        {
          this._show_pop_over_button.hide ();
        }
        this._show_pop_over_button.bind ('select', this);
      }
    },
  
    "secondPanelPosition": {
      /** 
       * Set the navigation panel position (LEFT, RIGHT, TOP, BOTTOM)
       * @name vs.ui.SplitView#secondPanelPosition 
       * @type {String}
       */ 
      set : function (v)
      {
        if (v !== SplitView.LEFT && v !== SplitView.RIGHT &&
            v !== SplitView.TOP && v !== SplitView.BOTTOM)
          return;
      
        this.removeClassName (this._second_panel_position);
        this._second_panel_position = v;
        this.addClassName (this._second_panel_position);
      }
    },
  
    "orientation": {
      /** 
       * Set/get the split view mode (MOBILE, TABLET)
       * @name vs.ui.SplitView#mode 
       * @type {String}
       */ 
      set : function (v)
      {
        if (v !== SplitView.VERTICAL && v !== SplitView.HORIZONTAL)
          return;
      
        this.removeClassName (this._orientation);
        this._orientation = v;
        this.addClassName (this._orientation);
        if (v === SplitView.VERTICAL) this._set_orientation (0);
        else this._set_orientation (90);
      },
      
      /**
       * @ignore
       */
      get : function (v)
      {
        return this._orientation;
      }
    },
  },

  /*****************************************************************
   *                Private members
   ****************************************************************/
   
   /**
   * @protected
   * @type {Object}
   */
  _delegate: null,

   /**
   * @protected
   * @type {String}
   */
  _mode: '',

   /**
   * @protected
   * @type {String}
   */
  _second_panel_position: '',

   /**
   * @protected
   * @type {String}
   */
  _orientation: '',

   /**
   * @private
   * @type {Array}
   */
  _split_views: null,
  
   /**
   * @private
   * @type {number}
   */
  _fisrt_view_width: 320,

   /**
   * @private
   * @type {number}
   */
  _pop_over_border_width: 8,
  
   /**
   * @private
   * @type {vs.ui.PopOver}
   */
  _pop_over: null,

  /*****************************************************************
   *
   ****************************************************************/

  /**
   * @protected
   * @function
   */
  constructor: function (config)
  {
    this._super (config);

    this._left_views = new Array ();
    this._pop_over = new PopOver ();
  },

  /**
   * @protected
   * @function
   */
  initComponent: function ()
  {
    this._super ();
    this._pop_over.init ();

    this._pop_over.hide ();
    document.body.appendChild (this._pop_over.view);

    if (this._mode) this.mode = this._mode;
    else this.mode = SplitView.TABLET_MODE;
    
    if (this._orientation) this.orientation = this._orientation;
    else
    {
      var orientation = window.deviceConfiguration.getOrientation ();

      if (orientation === 0 || orientation === 180)
        this.orientation = SplitView.VERTICAL;
      else
        this.orientation = SplitView.HORIZONTAL; 
    }
    
    if (this._second_panel_position) this.secondPanelPosition = this._second_panel_position;
    else this.secondPanelPosition = SplitView.LEFT;
  },

  /**
   * Add the child view to this component.
   * <p>
   * Only two views can be added.
   *
   * @name vs.ui.SplitView#add 
   * @function
   * @param {vs.ui.EventSource} child The component to be added.
   */
  add : function (child, hole)
  {
    if (hole === 'second_panel') this._left_views.push (child);
    else
    {
      this._super (child, 'main_panel');
      return;
    }
    
    if (this._mode === SplitView.MOBILE || this._orientation === SplitView.HORIZONTAL)
    {
      this._super (child, 'second_panel');
    }
    else
    {
      this._pop_over.add (child);
    }
  },
    
  /**
   * Remove all children components from this component and free them.
   * 
   * @name vs.ui.SplitView#removeAllChildren 
   * @param {Boolean} should_free free children
   * @return {Array} list of removed child if not should_free
   * @function
   * @example
   * myObject.removeAllChildren ();
   */
  removeAllChildren : function (should_free)
  {
    var key, a, child, children = [];
  
    for (key in this.__children)
    {
      a = this.__children [key];
      if (!a) { continue; }
      
      if (a instanceof Array)
      {
        while (a.length)
        {
          child = a [0];
          this.remove (child);
          if (should_free) util.free (child);
          else children.push (child);
        }
      }
      else
      {
        this.remove (a);
        if (should_free) util.free (a);
        else children.push (a);
      }
      delete (this.__children [key]);
    }
    this.__children = {};
    
    return (should_free)?undefined:children;
  },

  /**
   * @protected
   * @function
   */
  refresh : function ()
  {
    this._super ();
    if (this._pop_over.visible) this._pop_over.refresh ();
  },
  
  /**
   * @protected
   * @function
   */
  orientationWillChange : function (orientation)
  {
    if (orientation === 90 || orientation === -90)
      this.orientation = SplitView.HORIZONTAL;
    else
      this.orientation = SplitView.VERTICAL; 
  },
  
  /**
   * @protected
   * @function
   */
  _set_orientation : function (orientation)
  {
    var size = this.size, child, orientation;
    
    child = this._left_views [0];
    if (child)
    {
      if (this._mode === SplitView.MOBILE_MODE ||
          orientation === 90 || orientation === -90)
      {
        this._pop_over.hide ();
        if (this._pop_over.isChild (child))
        {
          this._pop_over.remove (child);
        }
        
        if (!this.isChild (child))
        {
          View.prototype.add.call (this, child, 'second_panel');
        }
        child.show (child.refresh);
        
        if (this._delegate && this._delegate.willShowView)
        {
          this._delegate.willShowView (child, this._pop_over);
        }
        if (this._show_pop_over_button) this._show_pop_over_button.hide ();
      }
      else
      {
        if (this.isChild (child))
        {
          View.prototype.remove.call (this, child);
        }
        if (!this._pop_over.isChild (child))
        {
          this._pop_over.add (child);
        }
        child.show ();
        this._pop_over.size =
          [this._fisrt_view_width + 2 * this._pop_over_border_width, 500];
        
         if (this._show_pop_over_button) this._show_pop_over_button.show ();
         
       if (this._delegate && this._delegate.willShowView)
        {
          this._delegate.willHideView (child, this._pop_over);
        }
      }
    }
  },
  
  /**
   * @protected
   * @function
   */
  orientationDidChange : function (orientation)
  {
    this.refresh ();
  },
  
  /**
   * @function
   */
  showPopOver : function (pos, direction)
  {
    if (this._mode !== SplitView.TABLET_MODE ||
        this._orientation !== SplitView.VERTICAL) return;

    this._pop_over.show (pos, direction);
    this._pop_over.refresh ();
  },
  
  /**
   * @function
   */
  hidePopOver : function ()
  {
    this._pop_over.hide ();
  },
  
  /**
   * @function
   */
  showMainView : function (instant)
  {
    var self = this;
    if (this._mode !== SplitView.MOBILE_MODE) return;

    if (this._hide_main_panel_button) this._hide_main_panel_button.show ();
    
    if (instant) {
      self.addClassName ('main_view_visible');
      return;
    }
    setTimeout (
      function () { self.addClassName ('main_view_visible'); },
      View.UNSELECT_DELAY
    );
  },
  
  /**
   * @function
   */
  hideMainView : function ()
  {
    if (this._mode !== SplitView.MOBILE_MODE) return;
    
    if (this._hide_main_panel_button) this._hide_main_panel_button.hide ();

    this.removeClassName ('main_view_visible');
  },
  
  notify : function (e) {
    var self = this;
    
    if (e.type == 'select' && e.src == this._hide_main_panel_button) {
      this.hideMainView ();
    }
    if (e.type == 'select' && e.src == this._show_pop_over_button) {
      this.showPopOver ([20, 20]);
    }
  }
});

/********************************************************************
                  Define class properties
********************************************************************/

SplitView.TABLET_MODE = 'tablet';
SplitView.MOBILE_MODE = 'mobile';
SplitView.VERTICAL = 'vertical';
SplitView.HORIZONTAL = 'horizontal';

SplitView.RIGHT = 'right';
SplitView.LEFT = 'left';
SplitView.BOTTOM = 'bottom';
SplitView.TOP = 'top';

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.SplitView = SplitView;
/*
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and
  contributors. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/


(function (exports){

  function scroll (view, mode) {
    this.view = view;
    this._mode = mode;
  
    // init recognizer support
    this.__pointer_recognizers = [];
  }
  
  scroll.prototype = {
    _enable: true,
    
     /**
     * @protected
     * @type {boolean}
     */
    _mode: false,

    /**
     * Translate value on x
     * @private
     * @type {number}
     */
    __view_t_x : 0,

    /**
     * Translate value on y
     * @private
     * @type {number}
     */
    __view_t_y : 0,

    /**
     * @protected
     * @type {vs.CSSMatrix}
     */
    _transforms_stack: null,

    /**
     * @protected
     * @function
     */
    initComponent : function ()
    {
      this._transforms_stack = new vs.CSSMatrix ();
    
      this.__recognizer = new DragRecognizer (this);
      this.addPointerRecognizer (this.__recognizer);
    },

    /**
     * @protected
     * @function
     */
    destructor: function ()
    {
      this.removePointerRecognizer (this.__recognizer);
      vs.util.free (this.__recognizer);
    
      core.Object.prototype.destructor.call (this);
    },

    didDragStart : function () {
      if (this.__chrono) {
        this.__chrono.stop ();
      }
    },
  
    didDrag : function (drag_info, event) {
      var
        dy = drag_info.dy,
        dx = drag_info.dx;
        
      if (this._mode === ScrollView.HORIZONTAL_SCROLL) { dy = 0; }
      if (this._mode === ScrollView.VERTICAL_SCROLL) { dx = 0; }
        
      this.__dist_y = dy - this.__view_t_y;
      this.__dist_x = dx - this.__view_t_x;

      this.__view_t_x = dx;
      this.__view_t_y = dy;
        
      var matrix = this._transforms_stack.translate (dx, dy, 0);

      // bounce top
      if (matrix.m41 > 0) {
        matrix.m41 = matrix.m41 / 2;
      }
      if (matrix.m42 > 0) {
        matrix.m42 = matrix.m42 / 2;
      }
    
      // bounce bottom without animation
      var
        w = this.view.offsetWidth - this.view.parentElement.offsetWidth,
        h = this.view.offsetHeight - this.view.parentElement.offsetHeight;
        
      if (matrix.m41 < -h) {
        matrix.m41 = (matrix.m41 - w) / 2;
      }
      if (matrix.m42 < -h) {
        matrix.m42 = (matrix.m42 - h) / 2;
      }

      setElementTransform (this.view, matrix.getMatrix3dStr ());
    },
  
    animate : function (traj_data, duration, pace) {
  
      var self = this;

      if (this.__chrono) {
        this.__chrono.stop ();
        this.__chrono.__trajectory.values = traj_data;
        this.__chrono.duration = duration || 150;
      
        vs.util.free (this.__chrono.__pace);
        this.__chrono.__pace = pace || vs.ext.fx.Pace.getLinearPace ();
      }
      else {
        this.__chrono =
          new vs.ext.fx.Chronometer ({duration: duration || 150}).init ();
        this.__chrono.__trajectory =
          new vs.ext.fx.Vector1D ({ values: traj_data }).init ();
        
        this.__chrono.__pace = pace || vs.ext.fx.Pace.getLinearPace ();


        this.__chrono.__clb = function (i) {
    
          var
            pace = this.__pace,
            traj = this.__trajectory;
  
          pace._tick_in = i;
          if (pace._timing) pace._tick_out = pace._timing (i);
          else pace._tick_out = i;
    
          traj._tick = pace._tick_out;
          if (traj.compute ()) {

            var matrix =
              self._transforms_stack.translate (0, traj._out, 0);

            setElementTransform (self.view, matrix.getMatrix3dStr ());
            if (i === 1) {
              self._transforms_stack = matrix;
            }
          }
        }
  
        this.__chrono.stop = function () {
          if (this._state === vs.core.Task.STOPPED) return;
      
          vs.ext.fx.Chronometer.prototype.stop.call (this);
          var matrix =
            self._transforms_stack.translate (0, this.__trajectory._out, 0);
        
          self._transforms_stack = matrix;
        }
      }
    
      this.__chrono.start ();
    },

    didDragEnd : function (event) {

      var matrix = this._transforms_stack.translate (0, this.__view_t_y, 0);
      // bounce top
      if (matrix.m42 > 0) {
        matrix.m42 = matrix.m42 / 2;
        this.animate ([matrix.m42, 0]);
        this.__view_t_y = 0;
        this._transforms_stack.m42 = 0;
        return;
      }
    
      // bounce bottom without animation
      var h = this.view.offsetHeight - this.view.parentElement.offsetHeight;
      if (matrix.m42 < -h) {
        matrix.m42 = (matrix.m42 - h) / 2;
        this.animate ([matrix.m42, -h]);
        this.__view_t_y = 0;
        this._transforms_stack.m42 = 0;
        return;
      }
    
      if (Math.abs (this.__dist_y) > 3) {
        var duration = this.__dist_y * this.__dist_y;
    
        var target = matrix.m42 + this.__dist_y * Math.abs (this.__dist_y);
        if (target > 0) target = 0;
        if (target < -h) target = -h;
      
        this.animate ([matrix.m42, target], duration, vs.ext.fx.Pace.getEaseOutPace ());
        this.__view_t_y = 0;
        this._transforms_stack.m42 = 0;
        this.__dist_y = 0;
        return;
      }
      this.__dist_y = 0;

      setElementTransform (this.view, matrix.getMatrix3dStr ());
    // save drag translation
      this._transforms_stack = matrix;
    },

    refresh : function () {
      console.log ("myScroll.refresh ");
    }
  }
  util.extend (scroll.prototype, RecognizerManager);
  util.extendClass (scroll, core.Object);
  
  exports.createScroll = function (view, mode) {
    return new scroll (view, mode).init ();
  }
}) (vs.ui);


/*!
 * iScroll v4.2.5 ~ Copyright (c) 2012 Matteo Spinelli, http://cubiq.org
 * Released under MIT license, http://cubiq.org/license
 */
(function(window, doc, vs){
var m = Math,
	vendor = vs.CSS_VENDOR,
	cssVendor = vs.CSS_VENDOR ? '-' + vs.CSS_VENDOR + '-' : '',

	// Style properties
	transform = prefixStyle('transform'),
	transitionProperty = prefixStyle('transitionProperty'),
	transitionDuration = vs.TRANSITION_DURATION,
	transformOrigin = vs.TRANSFORM_ORIGIN,
	transitionTimingFunction = vs.TRANSITION_TIMING_FUNC,
	transitionDelay = vs.TRANSITION_DELAY,

    // Browser capabilities
	isAndroid = (/android/gi).test(navigator.appVersion),
	isIDevice = (/iphone|ipad/gi).test(navigator.appVersion),
	isTouchPad = (/hp-tablet/gi).test(navigator.appVersion),

  has3d = vs.SUPPORT_3D_TRANSFORM,
  hasTouch = 'ontouchstart' in window,
  hasTransform = vs.SUPPORT_CSS_TRANSFORM,
  hasTransitionEnd = hasTransform,

	RESIZE_EV = 'onorientationchange' in window ? 'orientationchange' : 'resize',
	START_EV = vs.POINTER_START,
	MOVE_EV = vs.POINTER_MOVE,
	END_EV = vs.POINTER_END,
	CANCEL_EV = vs.POINTER_CANCEL,
	TRNEND_EV = vs.TRANSITION_END,

	nextFrame = vs.requestAnimationFrame,
	cancelFrame = vs.cancelRequestAnimationFrame,

	// Helpers
	translateZ = has3d ? ' translateZ(0)' : '',

	// Constructor
	iScroll = function (el, scroller, options) {
		var that = this,
			i;

		that.wrapper = typeof el == 'object' ? el : doc.getElementById(el);
		that.wrapper.style.overflow = 'hidden';
		that.scroller = scroller;

		// Default options
		that.options = {
			hScroll: true,
			vScroll: true,
			x: 0,
			y: 0,
			bounce: true,
			bounceLock: false,
			momentum: true,
			lockDirection: true,
			useTransform: true,
			useTransition: false,
			topOffset: 0,
			checkDOMChanges: false,		// Experimental
			handleClick: true,

			// Scrollbar
			hScrollbar: true,
			vScrollbar: true,
			fixedScrollbar: isAndroid,
			hideScrollbar: isIDevice,
			fadeScrollbar: isIDevice && has3d,
			scrollbarClass: '',

			// Zoom
			zoom: false,
			zoomMin: 1,
			zoomMax: 4,
			doubleTapZoom: 2,
			wheelAction: 'scroll',

			// Snap
			snap: false,
			snapThreshold: 1,

			// Events
			onRefresh: null,
			onBeforeScrollStart: function (e) { e.preventDefault(); },
			onScrollStart: null,
			onBeforeScrollMove: null,
			onScrollMove: null,
			onBeforeScrollEnd: null,
			onScrollEnd: null,
			onTouchEnd: null,
			onDestroy: null,
			onZoomStart: null,
			onZoom: null,
			onZoomEnd: null
		};

		// User defined options
		for (i in options) that.options[i] = options[i];
		
		// Set starting position
		that.x = that.options.x;
		that.y = that.options.y;

		// Normalize options
		that.options.useTransform = hasTransform && that.options.useTransform;
		that.options.hScrollbar = that.options.hScroll && that.options.hScrollbar;
		that.options.vScrollbar = that.options.vScroll && that.options.vScrollbar;
		that.options.zoom = that.options.useTransform && that.options.zoom;
		that.options.useTransition = hasTransitionEnd && that.options.useTransition;

		// Helpers FIX ANDROID BUG!
		// translate3d and scale doesn't work together!
		// Ignoring 3d ONLY WHEN YOU SET that.options.zoom
		if ( that.options.zoom && isAndroid ){
			translateZ = '';
		}
		
		// Set some default styles
		that.scroller.style[transitionProperty] = that.options.useTransform ? cssVendor + 'transform' : 'top left';
		that.scroller.style[transitionDuration] = '0';
		that.scroller.style[transformOrigin] = '0 0';
		if (that.options.useTransition) that.scroller.style[transitionTimingFunction] = 'cubic-bezier(0.33,0.66,0.66,1)';
		
		if (that.options.useTransform) that.scroller.style[transform] = 'translate(' + that.x + 'px,' + that.y + 'px)' + translateZ;
		else that.scroller.style.cssText += ';position:absolute;top:' + that.y + 'px;left:' + that.x + 'px';

		if (that.options.useTransition) that.options.fixedScrollbar = true;

		that.refresh();

		that._bind(RESIZE_EV, window);
		that._bind(START_EV);
		if (!hasTouch) {
			if (that.options.wheelAction != 'none') {
				that._bind('DOMMouseScroll');
				that._bind('mousewheel');
			}
		}

		if (that.options.checkDOMChanges) that.checkDOMTime = setInterval(function () {
			that._checkDOMChanges();
		}, 500);
	};

// Prototype
iScroll.prototype = {
	enabled: true,
	x: 0,
	y: 0,
	steps: [],
	scale: 1,
	currPageX: 0, currPageY: 0,
	pagesX: [], pagesY: [],
	aniTime: null,
	wheelZoomCount: 0,
	
	handleEvent: function (e) {
		var that = this;
		switch(e.type) {
			case START_EV:
				if (!hasTouch && e.button !== 0) return;
				that._start(e);
				break;
			case MOVE_EV: that._move(e); break;
			case END_EV:
			case CANCEL_EV: that._end(e); break;
			case RESIZE_EV: that._resize(); break;
			case 'DOMMouseScroll': case 'mousewheel': that._wheel(e); break;
			case TRNEND_EV: that._transitionEnd(e); break;
		}
	},
	
	_checkDOMChanges: function () {
		if (this.moved || this.zoomed || this.animating ||
			(this.scrollerW == this.scroller.offsetWidth * this.scale && this.scrollerH == this.scroller.offsetHeight * this.scale)) return;

		this.refresh();
	},
	
	_scrollbar: function (dir) {
		var that = this,
			bar;

		if (!that[dir + 'Scrollbar']) {
			if (that[dir + 'ScrollbarWrapper']) {
				if (hasTransform) that[dir + 'ScrollbarIndicator'].style[transform] = '';
				that[dir + 'ScrollbarWrapper'].parentNode.removeChild(that[dir + 'ScrollbarWrapper']);
				that[dir + 'ScrollbarWrapper'] = null;
				that[dir + 'ScrollbarIndicator'] = null;
			}

			return;
		}

		if (!that[dir + 'ScrollbarWrapper']) {
			// Create the scrollbar wrapper
			bar = doc.createElement('div');

			if (that.options.scrollbarClass) bar.className = that.options.scrollbarClass + dir.toUpperCase();
			else bar.style.cssText = 'position:absolute;z-index:100;' + (dir == 'h' ? 'height:7px;bottom:1px;left:2px;right:' + (that.vScrollbar ? '7' : '2') + 'px' : 'width:7px;bottom:' + (that.hScrollbar ? '7' : '2') + 'px;top:2px;right:1px');

			bar.style.cssText += ';pointer-events:none;' + cssVendor + 'transition-property:opacity;' + cssVendor + 'transition-duration:' + (that.options.fadeScrollbar ? '350ms' : '0') + ';overflow:hidden;opacity:' + (that.options.hideScrollbar ? '0' : '1');

			that.wrapper.appendChild(bar);
			that[dir + 'ScrollbarWrapper'] = bar;

			// Create the scrollbar indicator
			bar = doc.createElement('div');
			if (!that.options.scrollbarClass) {
				bar.style.cssText = 'position:absolute;z-index:100;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);' + cssVendor + 'background-clip:padding-box;' + cssVendor + 'box-sizing:border-box;' + (dir == 'h' ? 'height:100%' : 'width:100%') + ';' + cssVendor + 'border-radius:3px;border-radius:3px';
			}
			bar.style.cssText += ';pointer-events:none;' + cssVendor + 'transition-property:' + cssVendor + 'transform;' + cssVendor + 'transition-timing-function:cubic-bezier(0.33,0.66,0.66,1);' + cssVendor + 'transition-duration:0;' + cssVendor + 'transform: translate(0,0)' + translateZ;
			if (that.options.useTransition) bar.style.cssText += ';' + cssVendor + 'transition-timing-function:cubic-bezier(0.33,0.66,0.66,1)';

			that[dir + 'ScrollbarWrapper'].appendChild(bar);
			that[dir + 'ScrollbarIndicator'] = bar;
		}

		if (dir == 'h') {
			that.hScrollbarSize = that.hScrollbarWrapper.clientWidth;
			that.hScrollbarIndicatorSize = m.max(m.round(that.hScrollbarSize * that.hScrollbarSize / that.scrollerW), 8);
			that.hScrollbarIndicator.style.width = that.hScrollbarIndicatorSize + 'px';
			that.hScrollbarMaxScroll = that.hScrollbarSize - that.hScrollbarIndicatorSize;
			that.hScrollbarProp = that.hScrollbarMaxScroll / that.maxScrollX;
		} else {
			that.vScrollbarSize = that.vScrollbarWrapper.clientHeight;
			that.vScrollbarIndicatorSize = m.max(m.round(that.vScrollbarSize * that.vScrollbarSize / that.scrollerH), 8);
			that.vScrollbarIndicator.style.height = that.vScrollbarIndicatorSize + 'px';
			that.vScrollbarMaxScroll = that.vScrollbarSize - that.vScrollbarIndicatorSize;
			that.vScrollbarProp = that.vScrollbarMaxScroll / that.maxScrollY;
		}

		// Reset position
		that._scrollbarPos(dir, true);
	},
	
	_resize: function () {
		var that = this;
		setTimeout(function () { that.refresh(); }, isAndroid ? 200 : 0);
	},
	
	_pos: function (x, y) {
		if (this.zoomed) return;

		x = this.hScroll ? x : 0;
		y = this.vScroll ? y : 0;

		if (this.options.useTransform) {
			this.scroller.style[transform] = 'translate(' + x + 'px,' + y + 'px) scale(' + this.scale + ')' + translateZ;
		} else {
			x = m.round(x);
			y = m.round(y);
			this.scroller.style.left = x + 'px';
			this.scroller.style.top = y + 'px';
		}

		this.x = x;
		this.y = y;

		this._scrollbarPos('h');
		this._scrollbarPos('v');
	},

	_scrollbarPos: function (dir, hidden) {
		var that = this,
			pos = dir == 'h' ? that.x : that.y,
			size;

		if (!that[dir + 'Scrollbar']) return;

		pos = that[dir + 'ScrollbarProp'] * pos;

		if (pos < 0) {
			if (!that.options.fixedScrollbar) {
				size = that[dir + 'ScrollbarIndicatorSize'] + m.round(pos * 3);
				if (size < 8) size = 8;
				that[dir + 'ScrollbarIndicator'].style[dir == 'h' ? 'width' : 'height'] = size + 'px';
			}
			pos = 0;
		} else if (pos > that[dir + 'ScrollbarMaxScroll']) {
			if (!that.options.fixedScrollbar) {
				size = that[dir + 'ScrollbarIndicatorSize'] - m.round((pos - that[dir + 'ScrollbarMaxScroll']) * 3);
				if (size < 8) size = 8;
				that[dir + 'ScrollbarIndicator'].style[dir == 'h' ? 'width' : 'height'] = size + 'px';
				pos = that[dir + 'ScrollbarMaxScroll'] + (that[dir + 'ScrollbarIndicatorSize'] - size);
			} else {
				pos = that[dir + 'ScrollbarMaxScroll'];
			}
		}

		that[dir + 'ScrollbarWrapper'].style[transitionDelay] = '0';
		that[dir + 'ScrollbarWrapper'].style.opacity = hidden && that.options.hideScrollbar ? '0' : '1';
		that[dir + 'ScrollbarIndicator'].style[transform] = 'translate(' + (dir == 'h' ? pos + 'px,0)' : '0,' + pos + 'px)') + translateZ;
	},
	
	_start: function (e) {
		var that = this,
			point = e.pointerList[0],
			matrix, x, y,
			c1, c2;

		if (!that.enabled) return;

		if (that.options.onBeforeScrollStart) that.options.onBeforeScrollStart.call(that, e);

		if (that.options.useTransition || that.options.zoom) that._transitionTime(0);

		that.moved = false;
		that.animating = false;
		that.zoomed = false;
		that.distX = 0;
		that.distY = 0;
		that.absDistX = 0;
		that.absDistY = 0;
		that.dirX = 0;
		that.dirY = 0;

		// Gesture start
		if (that.options.zoom && e.nbPointers > 1) {
			c1 = m.abs(e.pointerList[0].pageX-e.pointerList[1].pageX);
			c2 = m.abs(e.pointerList[0].pageY-e.pointerList[1].pageY);
			that.touchesDistStart = m.sqrt(c1 * c1 + c2 * c2);

			that.originX = m.abs(e.pointerList[0].pageX + e.pointerList[1].pageX - that.wrapperOffsetLeft * 2) / 2 - that.x;
			that.originY = m.abs(e.pointerList[0].pageY + e.pointerList[1].pageY - that.wrapperOffsetTop * 2) / 2 - that.y;

			if (that.options.onZoomStart) that.options.onZoomStart.call(that, e);
		}

		if (that.options.momentum) {
			if (that.options.useTransform) {
				// Very lame general purpose alternative to CSSMatrix
				matrix = getComputedStyle(that.scroller, null)[transform].replace(/[^0-9\-.,]/g, '').split(',');
				x = +(matrix[12] || matrix[4]);
				y = +(matrix[13] || matrix[5]);
			} else {
				x = +getComputedStyle(that.scroller, null).left.replace(/[^0-9-]/g, '');
				y = +getComputedStyle(that.scroller, null).top.replace(/[^0-9-]/g, '');
			}
			
			if (x != that.x || y != that.y) {
				if (that.options.useTransition) that._unbind(TRNEND_EV);
				else cancelFrame(that.aniTime);
				that.steps = [];
				that._pos(x, y);
				if (that.options.onScrollEnd) that.options.onScrollEnd.call(that);
			}
		}

		that.absStartX = that.x;	// Needed by snap threshold
		that.absStartY = that.y;

		that.startX = that.x;
		that.startY = that.y;
		that.pointX = point.pageX;
		that.pointY = point.pageY;

		that.startTime = e.timeStamp || Date.now();

		if (that.options.onScrollStart) that.options.onScrollStart.call(that, e);

		that._bind(MOVE_EV, window);
		that._bind(END_EV, window);
		that._bind(CANCEL_EV, window);
	},
	
	_move: function (e) {
		var that = this,
			point = e.pointerList[0],
			deltaX = point.pageX - that.pointX,
			deltaY = point.pageY - that.pointY,
			newX = that.x + deltaX,
			newY = that.y + deltaY,
			c1, c2, scale,
			timestamp = e.timeStamp || Date.now();

		if (that.options.onBeforeScrollMove) that.options.onBeforeScrollMove.call(that, e);

		// Zoom
		if (that.options.zoom && e.nbPointers > 1) {
			c1 = m.abs(e.pointerList[0].pageX - e.pointerList[1].pageX);
			c2 = m.abs(e.pointerList[0].pageY - e.pointerList[1].pageY);
			that.touchesDist = m.sqrt(c1*c1+c2*c2);

			that.zoomed = true;

			scale = 1 / that.touchesDistStart * that.touchesDist * this.scale;

			if (scale < that.options.zoomMin) scale = 0.5 * that.options.zoomMin * Math.pow(2.0, scale / that.options.zoomMin);
			else if (scale > that.options.zoomMax) scale = 2.0 * that.options.zoomMax * Math.pow(0.5, that.options.zoomMax / scale);

			that.lastScale = scale / this.scale;

			newX = this.originX - this.originX * that.lastScale + this.x,
			newY = this.originY - this.originY * that.lastScale + this.y;

			this.scroller.style[transform] = 'translate(' + newX + 'px,' + newY + 'px) scale(' + scale + ')' + translateZ;

			if (that.options.onZoom) that.options.onZoom.call(that, e);
			return;
		}

		that.pointX = point.pageX;
		that.pointY = point.pageY;

		// Slow down if outside of the boundaries
		if (newX > 0 || newX < that.maxScrollX) {
			newX = that.options.bounce ? that.x + (deltaX / 2) : newX >= 0 || that.maxScrollX >= 0 ? 0 : that.maxScrollX;
		}
		if (newY > that.minScrollY || newY < that.maxScrollY) {
			newY = that.options.bounce ? that.y + (deltaY / 2) : newY >= that.minScrollY || that.maxScrollY >= 0 ? that.minScrollY : that.maxScrollY;
		}

		that.distX += deltaX;
		that.distY += deltaY;
		that.absDistX = m.abs(that.distX);
		that.absDistY = m.abs(that.distY);

		if (that.absDistX < 6 && that.absDistY < 6) {
			return;
		}

		// Lock direction
		if (that.options.lockDirection) {
			if (that.absDistX > that.absDistY + 5) {
				newY = that.y;
				deltaY = 0;
			} else if (that.absDistY > that.absDistX + 5) {
				newX = that.x;
				deltaX = 0;
			}
		}

		that.moved = true;
		that._pos(newX, newY);
		that.dirX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
		that.dirY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

		if (timestamp - that.startTime > 300) {
			that.startTime = timestamp;
			that.startX = that.x;
			that.startY = that.y;
		}
		
		if (that.options.onScrollMove) that.options.onScrollMove.call(that, e);
	},
	
	_end: function (e) {
		if (e.nbPointers !== 0) return;

		var that = this,
			point = e.changedPointerList [0],
			target, ev,
			momentumX = { dist:0, time:0 },
			momentumY = { dist:0, time:0 },
			duration = (e.timeStamp || Date.now()) - that.startTime,
			newPosX = that.x,
			newPosY = that.y,
			distX, distY,
			newDuration,
			snap,
			scale;

		that._unbind(MOVE_EV, window);
		that._unbind(END_EV, window);
		that._unbind(CANCEL_EV, window);

		if (that.options.onBeforeScrollEnd) that.options.onBeforeScrollEnd.call(that, e);

		if (that.zoomed) {
			scale = that.scale * that.lastScale;
			scale = Math.max(that.options.zoomMin, scale);
			scale = Math.min(that.options.zoomMax, scale);
			that.lastScale = scale / that.scale;
			that.scale = scale;

			that.x = that.originX - that.originX * that.lastScale + that.x;
			that.y = that.originY - that.originY * that.lastScale + that.y;
			
			that.scroller.style[transitionDuration] = '200ms';
			that.scroller.style[transform] = 'translate(' + that.x + 'px,' + that.y + 'px) scale(' + that.scale + ')' + translateZ;
			
			that.zoomed = false;
			that.refresh();

			if (that.options.onZoomEnd) that.options.onZoomEnd.call(that, e);
			return;
		}

		if (!that.moved) {
			if (hasTouch) {
				if (that.doubleTapTimer && that.options.zoom) {
					// Double tapped
					clearTimeout(that.doubleTapTimer);
					that.doubleTapTimer = null;
					if (that.options.onZoomStart) that.options.onZoomStart.call(that, e);
					that.zoom(that.pointX, that.pointY, that.scale == 1 ? that.options.doubleTapZoom : 1);
					if (that.options.onZoomEnd) {
						setTimeout(function() {
							that.options.onZoomEnd.call(that, e);
						}, 200); // 200 is default zoom duration
					}
				} else if (this.options.handleClick) {
					that.doubleTapTimer = setTimeout(function () {
						that.doubleTapTimer = null;

						// Find the last touched element
						target = point.target;
						while (target.nodeType != 1) target = target.parentNode;

						if (target.tagName != 'SELECT' && target.tagName != 'INPUT' && target.tagName != 'TEXTAREA') {
							ev = doc.createEvent('MouseEvents');
							ev.initMouseEvent('click', true, true, e.view, 1,
								point.screenX, point.screenY, point.clientX, point.clientY,
								e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,
								0, null);
							ev._fake = true;
							target.dispatchEvent(ev);
						}
					}, that.options.zoom ? 250 : 0);
				}
			}

			that._resetPos(400);

			if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
			return;
		}

		if (duration < 300 && that.options.momentum) {
			momentumX = newPosX ? that._momentum(newPosX - that.startX, duration, -that.x, that.scrollerW - that.wrapperW + that.x, that.options.bounce ? that.wrapperW : 0) : momentumX;
			momentumY = newPosY ? that._momentum(newPosY - that.startY, duration, -that.y, (that.maxScrollY < 0 ? that.scrollerH - that.wrapperH + that.y - that.minScrollY : 0), that.options.bounce ? that.wrapperH : 0) : momentumY;

			newPosX = that.x + momentumX.dist;
			newPosY = that.y + momentumY.dist;

			if ((that.x > 0 && newPosX > 0) || (that.x < that.maxScrollX && newPosX < that.maxScrollX)) momentumX = { dist:0, time:0 };
			if ((that.y > that.minScrollY && newPosY > that.minScrollY) || (that.y < that.maxScrollY && newPosY < that.maxScrollY)) momentumY = { dist:0, time:0 };
		}

		if (momentumX.dist || momentumY.dist) {
			newDuration = m.max(m.max(momentumX.time, momentumY.time), 10);

			// Do we need to snap?
			if (that.options.snap) {
				distX = newPosX - that.absStartX;
				distY = newPosY - that.absStartY;
				if (m.abs(distX) < that.options.snapThreshold && m.abs(distY) < that.options.snapThreshold) { that.scrollTo(that.absStartX, that.absStartY, 200); }
				else {
					snap = that._snap(newPosX, newPosY);
					newPosX = snap.x;
					newPosY = snap.y;
					newDuration = m.max(snap.time, newDuration);
				}
			}

			that.scrollTo(m.round(newPosX), m.round(newPosY), newDuration);

			if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
			return;
		}

		// Do we need to snap?
		if (that.options.snap) {
			distX = newPosX - that.absStartX;
			distY = newPosY - that.absStartY;
			if (m.abs(distX) < that.options.snapThreshold && m.abs(distY) < that.options.snapThreshold) that.scrollTo(that.absStartX, that.absStartY, 200);
			else {
				snap = that._snap(that.x, that.y);
				if (snap.x != that.x || snap.y != that.y) that.scrollTo(snap.x, snap.y, snap.time);
			}

			if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
			return;
		}

		that._resetPos(200);
		if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
	},
	
	_resetPos: function (time) {
		var that = this,
			resetX = that.x >= 0 ? 0 : that.x < that.maxScrollX ? that.maxScrollX : that.x,
			resetY = that.y >= that.minScrollY || that.maxScrollY > 0 ? that.minScrollY : that.y < that.maxScrollY ? that.maxScrollY : that.y;

		if (resetX == that.x && resetY == that.y) {
			if (that.moved) {
				that.moved = false;
				if (that.options.onScrollEnd) that.options.onScrollEnd.call(that);		// Execute custom code on scroll end
			}

			if (that.hScrollbar && that.options.hideScrollbar) {
				if (vendor == 'webkit') that.hScrollbarWrapper.style[transitionDelay] = '300ms';
				that.hScrollbarWrapper.style.opacity = '0';
			}
			if (that.vScrollbar && that.options.hideScrollbar) {
				if (vendor == 'webkit') that.vScrollbarWrapper.style[transitionDelay] = '300ms';
				that.vScrollbarWrapper.style.opacity = '0';
			}

			return;
		}

		that.scrollTo(resetX, resetY, time || 0);
	},

	_wheel: function (e) {
		var that = this,
			wheelDeltaX, wheelDeltaY,
			deltaX, deltaY,
			deltaScale;

		if ('wheelDeltaX' in e) {
			wheelDeltaX = e.wheelDeltaX / 12;
			wheelDeltaY = e.wheelDeltaY / 12;
		} else if('wheelDelta' in e) {
			wheelDeltaX = wheelDeltaY = e.wheelDelta / 12;
		} else if ('detail' in e) {
			wheelDeltaX = wheelDeltaY = -e.detail * 3;
		} else {
			return;
		}
		
		if (that.options.wheelAction == 'zoom') {
			deltaScale = that.scale * Math.pow(2, 1/3 * (wheelDeltaY ? wheelDeltaY / Math.abs(wheelDeltaY) : 0));
			if (deltaScale < that.options.zoomMin) deltaScale = that.options.zoomMin;
			if (deltaScale > that.options.zoomMax) deltaScale = that.options.zoomMax;
			
			if (deltaScale != that.scale) {
				if (!that.wheelZoomCount && that.options.onZoomStart) that.options.onZoomStart.call(that, e);
				that.wheelZoomCount++;
				
				that.zoom(e.pageX, e.pageY, deltaScale, 400);
				
				setTimeout(function() {
					that.wheelZoomCount--;
					if (!that.wheelZoomCount && that.options.onZoomEnd) that.options.onZoomEnd.call(that, e);
				}, 400);
			}
			
			return;
		}
		
		deltaX = that.x + wheelDeltaX;
		deltaY = that.y + wheelDeltaY;

		if (deltaX > 0) deltaX = 0;
		else if (deltaX < that.maxScrollX) deltaX = that.maxScrollX;

		if (deltaY > that.minScrollY) deltaY = that.minScrollY;
		else if (deltaY < that.maxScrollY) deltaY = that.maxScrollY;
    
		if (that.maxScrollY < 0) {
			that.scrollTo(deltaX, deltaY, 0);
		}
	},
	
	_transitionEnd: function (e) {
		var that = this;

		if (e.target != that.scroller) return;

		that._unbind(TRNEND_EV);
		
		that._startAni();
	},


	/**
	*
	* Utilities
	*
	*/
	_startAni: function () {
		var that = this,
			startX = that.x, startY = that.y,
			startTime = Date.now(),
			step, easeOut,
			animate;

		if (that.animating) return;
		
		if (!that.steps.length) {
			that._resetPos(400);
			return;
		}
		
		step = that.steps.shift();
		
		if (step.x == startX && step.y == startY) step.time = 0;

		that.animating = true;
		that.moved = true;
		
		if (that.options.useTransition) {
			that._transitionTime(step.time);
			that._pos(step.x, step.y);
			that.animating = false;
			if (step.time) that._bind(TRNEND_EV);
			else that._resetPos(0);
			return;
		}

		animate = function () {
			var now = Date.now(),
				newX, newY;

			if (now >= startTime + step.time) {
				that._pos(step.x, step.y);
				that.animating = false;
				if (that.options.onAnimationEnd) that.options.onAnimationEnd.call(that);			// Execute custom code on animation end
				that._startAni();
				return;
			}

			now = (now - startTime) / step.time - 1;
			easeOut = m.sqrt(1 - now * now);
			newX = (step.x - startX) * easeOut + startX;
			newY = (step.y - startY) * easeOut + startY;
			that._pos(newX, newY);
			if (that.animating) that.aniTime = nextFrame(animate);
		};

		animate();
	},

	_transitionTime: function (time) {
		time += 'ms';
		this.scroller.style[transitionDuration] = time;
		if (this.hScrollbar) this.hScrollbarIndicator.style[transitionDuration] = time;
		if (this.vScrollbar) this.vScrollbarIndicator.style[transitionDuration] = time;
	},

	_momentum: function (dist, time, maxDistUpper, maxDistLower, size) {
		var deceleration = 0.0006,
			speed = m.abs(dist) / time,
			newDist = (speed * speed) / (2 * deceleration),
			newTime = 0, outsideDist = 0;

		// Proportinally reduce speed if we are outside of the boundaries
		if (dist > 0 && newDist > maxDistUpper) {
			outsideDist = size / (6 / (newDist / speed * deceleration));
			maxDistUpper = maxDistUpper + outsideDist;
			speed = speed * maxDistUpper / newDist;
			newDist = maxDistUpper;
		} else if (dist < 0 && newDist > maxDistLower) {
			outsideDist = size / (6 / (newDist / speed * deceleration));
			maxDistLower = maxDistLower + outsideDist;
			speed = speed * maxDistLower / newDist;
			newDist = maxDistLower;
		}

		newDist = newDist * (dist < 0 ? -1 : 1);
		newTime = speed / deceleration;

		return { dist: newDist, time: m.round(newTime) };
	},

	_offset: function (el) {
		var left = -el.offsetLeft,
			top = -el.offsetTop;
			
		while (el = el.offsetParent) {
			left -= el.offsetLeft;
			top -= el.offsetTop;
		}
		
		if (el != this.wrapper) {
			left *= this.scale;
			top *= this.scale;
		}

		return { left: left, top: top };
	},

	_snap: function (x, y) {
		var that = this,
			i, l,
			page, time,
			sizeX, sizeY;

		// Check page X
		page = that.pagesX.length - 1;
		for (i=0, l=that.pagesX.length; i<l; i++) {
			if (x >= that.pagesX[i]) {
				page = i;
				break;
			}
		}
		if (page == that.currPageX && page > 0 && that.dirX < 0) page--;
		x = that.pagesX[page];
		sizeX = m.abs(x - that.pagesX[that.currPageX]);
		sizeX = sizeX ? m.abs(that.x - x) / sizeX * 500 : 0;
		that.currPageX = page;

		// Check page Y
		page = that.pagesY.length-1;
		for (i=0; i<page; i++) {
			if (y >= that.pagesY[i]) {
				page = i;
				break;
			}
		}
		if (page == that.currPageY && page > 0 && that.dirY < 0) page--;
		y = that.pagesY[page];
		sizeY = m.abs(y - that.pagesY[that.currPageY]);
		sizeY = sizeY ? m.abs(that.y - y) / sizeY * 500 : 0;
		that.currPageY = page;

		// Snap with constant speed (proportional duration)
		time = m.round(m.max(sizeX, sizeY)) || 200;

		return { x: x, y: y, time: time };
	},

	_bind: function (type, el, bubble) {
//		(el || this.scroller).addEventListener(type, this, !!bubble);
		vs.addPointerListener ((el || this.scroller), type, this, !!bubble);
	},

	_unbind: function (type, el, bubble) {
//		(el || this.scroller).removeEventListener(type, this, !!bubble);
		vs.removePointerListener ((el || this.scroller), type, this, !!bubble);
	},


	/**
	*
	* Public methods
	*
	*/
	destroy: function () {
		var that = this;

		that.scroller.style[transform] = '';

		// Remove the scrollbars
		that.hScrollbar = false;
		that.vScrollbar = false;
		that._scrollbar('h');
		that._scrollbar('v');

		// Remove the event listeners
		that._unbind(RESIZE_EV, window);
		that._unbind(START_EV);
		that._unbind(MOVE_EV, window);
		that._unbind(END_EV, window);
		that._unbind(CANCEL_EV, window);
		
		if (!that.options.hasTouch) {
			that._unbind('DOMMouseScroll');
			that._unbind('mousewheel');
		}
		
		if (that.options.useTransition) that._unbind(TRNEND_EV);
		
		if (that.options.checkDOMChanges) clearInterval(that.checkDOMTime);
		
		if (that.options.onDestroy) that.options.onDestroy.call(that);
	},

	refresh: function () {
		var that = this,
			offset,
			i, l,
			els,
			pos = 0,
			page = 0;

		if (that.scale < that.options.zoomMin) that.scale = that.options.zoomMin;
		that.wrapperW = that.wrapper.clientWidth || 1;
		that.wrapperH = that.wrapper.clientHeight || 1;

		that.minScrollY = -that.options.topOffset || 0;
		that.scrollerW = m.round(that.scroller.offsetWidth * that.scale);
		that.scrollerH = m.round((that.scroller.offsetHeight + that.minScrollY) * that.scale);
		that.maxScrollX = that.wrapperW - that.scrollerW;
		that.maxScrollY = that.wrapperH - that.scrollerH + that.minScrollY;
		that.dirX = 0;
		that.dirY = 0;

		if (that.options.onRefresh) that.options.onRefresh.call(that);

		that.hScroll = that.options.hScroll && that.maxScrollX < 0;
		that.vScroll = that.options.vScroll && (!that.options.bounceLock && !that.hScroll || that.scrollerH > that.wrapperH);

		that.hScrollbar = that.hScroll && that.options.hScrollbar;
		that.vScrollbar = that.vScroll && that.options.vScrollbar && that.scrollerH > that.wrapperH;

		offset = that._offset(that.wrapper);
		that.wrapperOffsetLeft = -offset.left;
		that.wrapperOffsetTop = -offset.top;

		// Prepare snap
		if (typeof that.options.snap == 'string') {
			that.pagesX = [];
			that.pagesY = [];
			els = that.scroller.querySelectorAll(that.options.snap);
			for (i=0, l=els.length; i<l; i++) {
				pos = that._offset(els[i]);
				pos.left += that.wrapperOffsetLeft;
				pos.top += that.wrapperOffsetTop;
				that.pagesX[i] = pos.left < that.maxScrollX ? that.maxScrollX : pos.left * that.scale;
				that.pagesY[i] = pos.top < that.maxScrollY ? that.maxScrollY : pos.top * that.scale;
			}
		} else if (that.options.snap) {
			that.pagesX = [];
			while (pos >= that.maxScrollX) {
				that.pagesX[page] = pos;
				pos = pos - that.wrapperW;
				page++;
			}
			if (that.maxScrollX%that.wrapperW) that.pagesX[that.pagesX.length] = that.maxScrollX - that.pagesX[that.pagesX.length-1] + that.pagesX[that.pagesX.length-1];

			pos = 0;
			page = 0;
			that.pagesY = [];
			while (pos >= that.maxScrollY) {
				that.pagesY[page] = pos;
				pos = pos - that.wrapperH;
				page++;
			}
			if (that.maxScrollY%that.wrapperH) that.pagesY[that.pagesY.length] = that.maxScrollY - that.pagesY[that.pagesY.length-1] + that.pagesY[that.pagesY.length-1];
		}

		// Prepare the scrollbars
		that._scrollbar('h');
		that._scrollbar('v');

		if (!that.zoomed) {
			that.scroller.style[transitionDuration] = '0';
			that._resetPos(400);
		}
	},

	scrollTo: function (x, y, time, relative) {
		var that = this,
			step = x,
			i, l;

		that.stop();

		if (!step.length) step = [{ x: x, y: y, time: time, relative: relative }];
		
		for (i=0, l=step.length; i<l; i++) {
			if (step[i].relative) { step[i].x = that.x - step[i].x; step[i].y = that.y - step[i].y; }
			that.steps.push({ x: step[i].x, y: step[i].y, time: step[i].time || 0 });
		}

		that._startAni();
	},

	scrollToElement: function (el, time) {
		var that = this, pos;
		el = el.nodeType ? el : that.scroller.querySelector(el);
		if (!el) return;

		pos = that._offset(el);
		pos.left += that.wrapperOffsetLeft;
		pos.top += that.wrapperOffsetTop;

		pos.left = pos.left > 0 ? 0 : pos.left < that.maxScrollX ? that.maxScrollX : pos.left;
		pos.top = pos.top > that.minScrollY ? that.minScrollY : pos.top < that.maxScrollY ? that.maxScrollY : pos.top;
		time = time === undefined ? m.max(m.abs(pos.left)*2, m.abs(pos.top)*2) : time;

		that.scrollTo(pos.left, pos.top, time);
	},

	scrollToPage: function (pageX, pageY, time) {
		var that = this, x, y;
		
		time = time === undefined ? 400 : time;

		if (that.options.onScrollStart) that.options.onScrollStart.call(that);

		if (that.options.snap) {
			pageX = pageX == 'next' ? that.currPageX+1 : pageX == 'prev' ? that.currPageX-1 : pageX;
			pageY = pageY == 'next' ? that.currPageY+1 : pageY == 'prev' ? that.currPageY-1 : pageY;

			pageX = pageX < 0 ? 0 : pageX > that.pagesX.length-1 ? that.pagesX.length-1 : pageX;
			pageY = pageY < 0 ? 0 : pageY > that.pagesY.length-1 ? that.pagesY.length-1 : pageY;

			that.currPageX = pageX;
			that.currPageY = pageY;
			x = that.pagesX[pageX];
			y = that.pagesY[pageY];
		} else {
			x = -that.wrapperW * pageX;
			y = -that.wrapperH * pageY;
			if (x < that.maxScrollX) x = that.maxScrollX;
			if (y < that.maxScrollY) y = that.maxScrollY;
		}

		that.scrollTo(x, y, time);
	},

	disable: function () {
		this.stop();
		this._resetPos(0);
		this.enabled = false;

		// If disabled after touchstart we make sure that there are no left over events
		this._unbind(MOVE_EV, window);
		this._unbind(END_EV, window);
		this._unbind(CANCEL_EV, window);
	},
	
	enable: function () {
		this.enabled = true;
	},
	
	stop: function () {
		if (this.options.useTransition) this._unbind(TRNEND_EV);
		else cancelFrame(this.aniTime);
		this.steps = [];
		this.moved = false;
		this.animating = false;
	},
	
	zoom: function (x, y, scale, time) {
		var that = this,
			relScale = scale / that.scale;

		if (!that.options.useTransform) return;

		that.zoomed = true;
		time = time === undefined ? 200 : time;
		x = x - that.wrapperOffsetLeft - that.x;
		y = y - that.wrapperOffsetTop - that.y;
		that.x = x - x * relScale + that.x;
		that.y = y - y * relScale + that.y;

		that.scale = scale;
		that.refresh();

		that.x = that.x > 0 ? 0 : that.x < that.maxScrollX ? that.maxScrollX : that.x;
		that.y = that.y > that.minScrollY ? that.minScrollY : that.y < that.maxScrollY ? that.maxScrollY : that.y;

		that.scroller.style[transitionDuration] = time + 'ms';
		that.scroller.style[transform] = 'translate(' + that.x + 'px,' + that.y + 'px) scale(' + scale + ')' + translateZ;
		that.zoomed = false;
	},
	
	isReady: function () {
		return !this.moved && !this.zoomed && !this.animating;
	}
};

function prefixStyle (style) {
	if ( vendor === '' ) return style;

	style = style.charAt(0).toUpperCase() + style.substr(1);
	return vendor + style;
}

if (typeof exports !== 'undefined') exports.iScroll = iScroll;
else window.iScroll = iScroll;

})(window, document, vs);/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.ui.ScrollView class
 *
 *  @extends vs.ui.View
 *  @class
 *  vs.ui.ScrollView defines the basic drawing, event-handling, of an application.
 *  The main different between vs.ui.ScrollView and vs.ui.View classes is vs.ui.ScrollView
 *  manages gesture events and scroll.
 *  <p>
 *  To allow pinch and scroll behavior, you need to set pinch and/or scroll
 *  properties. You can activate separately rotation, scale and scroll.
 *
 *  <p>
 * Delegates:
 *  <ul>
 *    <li/>viewWillStartZooming : function (vs.ui.ScrollView the view)
 *    <li/>viewDidEndZooming : function (vs.ui.ScrollView the view, number scale)
 *  </ul>
 *  <p>
 *  @example
 *  var myView = new vs.ui.ScrollView (config);
 *  myView.minScale = 1;
 *  myView.maxScale = 2;
 *  myView.pinch = vs.ui.ScrollView.SCALE; // activate pinch zoom
 *  myView.scroll = true; //
 *  
 *  @author David Thevenin
 * @name vs.ui.ScrollView
 *
 *  @constructor
 *   Creates a new vs.ui.ScrollView.
 *
 * @param {Object} config the configuration structure [mandatory]
 */
function ScrollView (config)
{
  this.parent = View;
  this.parent (config);
  this.constructor = ScrollView;
  
  this.__ab_view_t_o = [50, 50];
}

/********************************************************************
                    _scrolling constant
*********************************************************************/

/** 
 * Disable the scroll
 * @see vs.ui.ScrollView#scroll 
 * @name vs.ui.ScrollView.NO_SCROLL
 * @const
 */
ScrollView.NO_SCROLL = 0;

/** 
 * Activate the only vertical scroll
 * @see vs.ui.ScrollView#scroll 
 * @name vs.ui.ScrollView.VERTICAL_SCROLL
 * @const
 */
ScrollView.VERTICAL_SCROLL = 1;

/** 
 * Activate the horizontal scroll
 * @see vs.ui.ScrollView#scroll 
 * @name vs.ui.ScrollView.HORIZONTAL_SCROLL
 * @const
 */
ScrollView.HORIZONTAL_SCROLL = 2;

/** 
 * Activate the scroll
 * @see vs.ui.ScrollView#scroll 
 * @name vs.ui.ScrollView.SCROLL
 * @const
 */
ScrollView.SCROLL = 3;

/********************************************************************
                    Pinch / rotation / scale constant
*********************************************************************/

/** 
 * Disable the pinch
 * @see vs.ui.ScrollView#pinch 
 * @name vs.ui.ScrollView.NO_PINCH
 * @const
 */
ScrollView.NO_PINCH = 0;

/** 
 * Configures pinch rotation
 * @see vs.ui.ScrollView#pinch 
 * @name vs.ui.ScrollView.ROTATION
 * @const
 */
ScrollView.ROTATION = 1;

/** 
 * Configures pinch scale
 * @see ScrollView#pinch 
 * @name vs.ui.ScrollView.SCALE
 * @const
 */
ScrollView.SCALE = 2;

/** 
 * Configures pinch rotation and scale
 * @see vs.ui.ScrollView#pinch 
 * @name vs.ui.ScrollView.ROTATION_AND_SCALE
 * @const
 */
ScrollView.ROTATION_AND_SCALE = 3;

ScrollView.prototype = {

 /**********************************************************************
 
 *********************************************************************/
   /**
   * @protected
   * @type {Object}
   */
  _delegate: null,

   /**
   * @protected
   * @type {boolean}
   */
  _scroll: false,
      
   /**
   * @private
   * @type {boolean}
   */
  __scroll_activated: false,
      
   /**
   * @protected
   * @type {boolean}
   */
  _pinch: ScrollView.NO_PINCH,
  
  /**
   * Translate value on x
   * @private
   * @type {number}
   */
  _ab_view_t_x : 0,

  /**
   * Translate value on y
   * @private
   * @type {number}
   */
  _ab_view_t_y : 0,
  
  /**
   * Scale value of the inter view
   * @private
   * @type {number}
   */
  _ab_view_s : 1,

  /**
   * Rotation value of the inter view
   * @protected
   * @type {number}
   */
  _ab_view_r : 0,

  /*******   transformation member ****************/
  
  /**
   * Animation temporisation (in millisecond)
   * @private
   * @type {number}
   */
  _animation_duration : 0,
    
//   /** 
//    * This property allows you to specify the origin of the 2D transformations. 
//    * Values are pourcentage of the view size.
//    * <p>
//    * The property is set by default to [50, 50], which is the center of
//    * the view.
//    * @name vs.ui.View#transformOrigin 
//    * @type Array.<number>
//    */ 
//   set transformOrigin (v)
//   {
//     if (!util.isArray (v) || v.length !== 2) { return; }
//     if (!util.isNumber (v[0]) || !util.isNumber (v[1])) { return; }
// 
//     this._transform_origin [0] = v [0];
//     this._transform_origin [1] = v [1];
// 
//     var origin_str = this._transform_origin [0] + '% ';
//     origin_str += this._transform_origin [1] + '%';
//     this._sub_view.style ['-webkit-transform-origin'] = origin_str;
//   },
// 
//   /** 
//    * @return {Array}
//    */ 
//   get transformOrigin ()
//   {
//     return this._transform_origin.slice ();
//   },

  /*****************************************************************
   *
   ****************************************************************/
   
  /**
   * @protected
   * @function
   */
  refresh : function ()
  {
    var child, size = this.size, width = size[0], height = size[1], v,
      css = this._getComputedStyle (this.view), dx = 0, dy = 0;
    if (!this._sub_view) { return; }
    
    this._sub_view.style.height = '';
    this._sub_view.style.width = '';
    
    function endRefresh () {
      if (!this.__i__) return; // component was deleted!
      View.prototype.refresh.call (this);
 
      if (css)
      {
        v = css ['border-right-width'];
        dx += v?parseInt (v, 10):0;
        v = css ['border-left-width'];
        dx += v?parseInt (v, 10):0;
        v = css ['border-top-width'];
        dy += v?parseInt (v, 10):0;
        v = css ['borde-bottom-width'];
        dy += v?parseInt (v, 10):0;
      }

      width -= dx;
      height -= dy;
    
      child = this._sub_view.firstElementChild;
      while (child)
      {
        v = child.offsetHeight + child.offsetTop;
        if (v > height) { height = v; }
        v = child.offsetWidth + child.offsetLeft;
        if (v > width) { width = v; }
      
        child = child.nextElementSibling;
      }
    
      if (this._scroll === ScrollView.SCROLL)
      {
        this._sub_view.style.width = width + 'px';
        this._sub_view.style.height = height + 'px';
      }
      if (this._scroll === ScrollView.HORIZONTAL_SCROLL)
      {
        this._sub_view.style.width = width + 'px';
        this._sub_view.style.height = this.size [1] - dx + 'px';
      }
      if (this._scroll === ScrollView.VERTICAL_SCROLL)
      {
        this._sub_view.style.width = this.size [0] - dy + 'px';
        this._sub_view.style.height = height + 'px';
      }
    
      if (this._scroll === ScrollView.NO_SCROLL)
      {
        size = this.size;
        this._sub_view.style.width = size [0] + 'px';
        this._sub_view.style.height = size [1] + 'px'
      }

      if (this.__iscroll__) this.__iscroll__.refresh ();
    }
    
    vs.scheduleAction (endRefresh.bind (this));
  },
    
  /**
   * @protected
   * @function
   */
  destructor : function ()
  {
    if (this.__iscroll__)
    {
      this.__iscroll__.destroy ();
      this.__iscroll__ = undefined;
    }
    this._scroll = false;
    
    if (this._sub_view && this._sub_view.parentElement)
    {
      this._sub_view.parentElement.removeChild (this._sub_view);
    }
    View.prototype.destructor.call (this);
    delete (this._sub_view);
  },
  
  /**
   * Add the specified child component to this component.
   * <p>
   * The component can be a graphic component (vs.ui.View) or
   * a non graphic component (vs.core.EventSource).
   * In case of vs.ui.View its mandatory to set the extension.
   * <p>
   * The add is a lazy add! The child's view can be already in
   * the HTML DOM. In that case, the add methode do not modify the DOM.
   * <p>
   * @example
   *  var myButton = new Button (conf);
   *  myObject.add (myButton, 'children');
   *
   * @name vs.ui.ScrollView#add
   * @function
   * 
   * @param {vs.core.EventSource} child The component to be added.
   * @param {String} extension [optional] The hole into a vs.ui.View will be insert.
  */
  add : function (child, extension)
  {
    // manage Navigation bar and vs.ui.ToolBar specific positioning
    if (!child) { return; }
    if (child instanceof NavigationBar)
    { extension = 'top_bar'; }
    if (child instanceof ToolBar)
    { extension = 'bottom_bar'; }
    
    View.prototype.add.call (this, child, extension);
  },
  
  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    View.prototype.initComponent.call (this);
    
    this._sub_view = this.view.querySelector ('.content');
    
    this.pinch = this._pinch;
    this.scroll = this._scroll;
    this.layout = this._layout;
    this.animationDuration = this._animation_duration;
   
    this.refresh ();
//    this._applyInsideTransformation2D ();
  },
  
  /*****************************************************************
   *                Events Management
   ****************************************************************/
   
  /**
   * @private
   * @function
   */
//   handleEvent : function (e)
//   {
//     switch (e.type)
//     {
//       case core.POINTER_START:
//         this.pointerStart (e);
//         break;
//       case core.POINTER_MOVE:
//         this._scroll_pointer_move (e);
//         break;
//       case core.POINTER_CANCEL:
//       case core.POINTER_END:
//         this._scroll_pointer_end (e);
//         break;
//       case 'gesturestart':
//         this.gestureStart (e);
//         break;
//       case 'gesturechange':
//         this.gestureChange (e);
//         break;
//       case 'gestureend':
//       case 'gesturecancel':
//         this.gestureEnd (e);
//         break;
//       case 'webkitTransitionEnd':
//         this._scroll_transition_end ();
//         break;
//       case 'orientationchange':
//       case 'resize':
//         this.refresh ();
//         break;
//       case 'DOMSubtreeModified':
//         this.onDOMModified (e);
//         break;
//      }
//     return false;
//   },

  /**
   * @private
   * @function
   */
//   gestureStart : function (e)
//   {
//     e.preventDefault ();
//     e.stopPropagation ();
//     
//     this.animationDuration = 0;
// 
//     if (this._pinch & ScrollView.SCALE && this._delegate &&
//         this._delegate.viewWillStartZooming)
//     {
//       this._delegate.viewWillStartZooming (this);
//     }
// 
//     document.addEventListener ('gesturechange', this);
//     document.addEventListener ('gestureend', this);
//     document.addEventListener ('gesturecancel', this);
//     this.view.addEventListener ('gestureend', this);
//     this.view.addEventListener ('gesturecancel', this);
//     
//     this.__ab_view_s = this._ab_view_s;
//     this.__ab_view_r = this._ab_view_r;
// 
//     origin_str = '50% 50%';
//     this._sub_view.style ['-webkit-transform-origin'] = origin_str;
//   },

  /**
   * @private
   * @function
   */
//   gestureChange : function (e)
//   {
//     var scale = this.__ab_view_s * e.scale;
//     e.preventDefault ();
//     e.stopPropagation ();
// 
//     if (scale > this._max_scale) { scale = this._max_scale; }
//     if (scale < this._min_scale) { scale = this._min_scale; }
// 
//     if (this._pinch === ScrollView.ROTATION)
//     {
//       this._ab_view_r = this.__ab_view_r + e.rotation;
//     }
//     else if (this._pinch === ScrollView.SCALE)
//     {
//       this._ab_view_s = scale;
//     }
//     else if (this._pinch === ScrollView.ROTATION_AND_SCALE)
//     {
//       this._ab_view_r = this.__ab_view_r + e.rotation;
//       this._ab_view_s = scale;
//     }
//     this._applyInsideTransformation2D ();
//     
//     // refresh scroll views according scale and rotiation
// //    if (this._scroll) { this._scroll_refresh (this._pinch); }
//   },

  /**
   * @private
   * @function
   */
//   gestureEnd : function (e)
//   {
//     var self = this;
// 
//     e.preventDefault ();
//     e.stopPropagation ();
// 
//     document.removeEventListener ('gesturechange', this);
//     document.removeEventListener ('gestureend', this);
//     document.removeEventListener ('gesturecancel', this);
//     this.view.removeEventListener ('gestureend', this);
//     this.view.removeEventListener ('gesturecancel', this);
//     
// 		setTimeout(function () {
// 			self.refresh();
// 		}, 0);
// 
//     if (this._pinch & ScrollView.SCALE && this._delegate &&
//         this._delegate.viewDidEndZooming)
//     {
//       this._delegate.viewDidEndZooming (this, this._ab_view_s);
//     }
//   },

  /**
   * @protected
   * @function
   */
//   pointerStart: function (e)
//   {
//     var matrix, len, origin_str, bx = 0, by = 0;
//     
//     // manage multi touche events (pinch, ...)
//     if (e.changedTouches && e.changedTouches.length > 1)
//     {
//       len = e.changedTouches.length;
//       for (i = 0; i < len; i ++)
//       {
//         bx += e.changedTouches [i].pageX;
//         by += e.changedTouches [i].pageY;
//       }
//       bx = (bx / len) - this._pos [0];
//       by = (by / len) - this._pos [1];
//       origin_str = bx + 'px ' + by + 'px';
//       this._sub_view.style ['-webkit-transform-origin'] = origin_str;
//       return;
//     }
// 
// // manage one touch event (touch, slide, ...)
// //     if (!this.enabled || (!this.options.vScrollbar && !this.options.hScrollbar)) {
// //       this._propagateToParent (e);
// //       return;
// //     }
// //     if (!e._fake && e.currentTarget !== this._sub_view) { return; }
// 
//     this._scroll_pointer_start (e);
//   },
  
  /**
   * @protected
   * @function
   */
//   onDOMModified: function (e)
//   {
//     var self = this;
// 
//     // (Hopefully) execute onDOMModified only once
//     if (e.target.parentNode !== this._sub_view) { return; }
// 
// //    setTimeout (function () { self.refresh(); }, 0);
//     this.refresh();
// 
//     if (this.options.topOnDOMChanges && 
//        (this._ab_view_t_x !== 0 || this._ab_view_t_y !== 0))
//     { this.scrollTo (0,0,0); }
//   },

  /**
   * @protected
   * @function
   */
//   onScrollEnd: function ()
//   {},
  
  /*****************************************************************
   *                Transformation methods
   ****************************************************************/
   
  /**
   * Move the content in x, y.
   *
   * @name vs.ui.ScrollView#insideTranslate
   * @function
   * 
   * @param {int} x translation over the x axis
   * @param {int} y translation over the y axis
   * @param {function} clb Function call at the end of the transformation
   */
//   insideTranslate: function (x, y, clb)
//   {
//     if (this._ab_view_t_x === x && this._ab_view_t_y === y) { return; }
//     
//     this._ab_view_t_x = x;
//     this._ab_view_t_y = y;
//     
//     this._applyInsideTransformation2D (clb);
//   },

  /**
   * Rotate the content
   *
   * @name vs.ui.ScrollView#insideRotate
   * @function
   * 
   * @param r {int} rotation
   * @param y {int} translation over the y axis
   * @param {function} clb Function call at the end of the transformation
   */
//   insideRotate: function (r, clb)
//   {
//     if (this._ab_view_r === r) { return; }
//     
//     this._ab_view_r = r;
//     
//     this._applyInsideTransformation2D (clb);
//     
//     // refresh scroll views according scale and rotiation
//     if (this._scroll) { this._scroll_refresh (this._pinch); }
//   },
  
  /**
   * Scale the content
   * <p/>The scale is limited by a max and min scale value.
   * 
   * @name vs.ui.ScrollView#insideScale
   * @function
   * 
   * @param s {float} scale value
   * @param {function} clb Function call at the end of the transformation
   */
//   insideScale: function (s, clb)
//   {    
//     if (s > this._max_scale) { s = this._max_scale; }
//     if (s < this._min_scale) { s = this._min_scale; }
//     if (this._ab_view_s === s) { return; }
//  
//     this._ab_view_s = s;
//     
//     this._applyInsideTransformation2D (clb);
//     
//     // refresh scroll views according scale and rotiation
// //    if (this._scroll) { this._scroll_refresh (this._pinch); }
//   },
  
  /**
   * @protected
   * @function
   */
//   _applyInsideTransformation2D: function (clb)
//   {
//     var transform = '', callback, self = this;
//     
//     callback = function (event) 
//     {
//       // do nothing if that event just bubbled from our target's sub-tree
//       if (event.currentTarget !== self._sub_view) { return; }
// 
//       self._sub_view.removeEventListener
//         ('webkitTransitionEnd', callback, false);
//       
//       if (clb) { clb.call (self); }
//     }
// 
//     // apply translation, therefor a strange bug appear (flick)
//     if (SUPPORT_3D_TRANSFORM)
//       transform += 
//         "translate3d("+this._ab_view_t_x+"px,"+this._ab_view_t_y+"px,0)";
//     else
//       transform += 
//         "translate("+this._ab_view_t_x+"px,"+this._ab_view_t_y+"px)";
// 
//     if (this._ab_view_r)
//     {
//       transform += " rotate(" + this._ab_view_r + "deg)";
//     }
//     if (this._ab_view_s !== 1)
//     {
//       transform += " scale(" + this._ab_view_s + ")";
//     }
//     
//     if (clb)
//     {
//       this._sub_view.addEventListener ('webkitTransitionEnd', callback, false);
//     }
//     setElementTransform (this._sub_view, transform);
//   },
  
  /**
   * @protected
   * @function
   */
  _updateSize: function ()
  {
    View.prototype._updateSize.call (this);
    this.refresh ();
  },
  
  _setup_iscroll : function () {
    if (this.__iscroll__)
    {
      this.__iscroll__.destroy ();
      this.__iscroll__ = undefined;
    }
  
    if (this.view && this._sub_view)
    {
      var options = {};
      options.bubbling = false;
//      options.fadeScrollbar = true;
//      options.bounce = false;
//      options.momentum = false;
      options.hScroll = false;
      options.vScroll = false;
      if (this._scroll === 1)
      {
        options.vScroll = true;
      }
      else if (this._scroll === 2)
      {
        options.hScroll = true;
      }
      else if (this._scroll === 3)
      {
        options.hScroll = true;
        options.vScroll = true;
      }
      
      // For any case, do not show the scroll bar
       options.hScrollbar = false;
       options.vScrollbar = false;
 
      this.__iscroll__ = new iScroll (this.view, this._sub_view, options);

      this.refresh ();
    }
  }
};
util.extendClass (ScrollView, View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (ScrollView, {
'delegate': {
  /** 
   * Set the delegate.
   * It should implements following methods
   *  <ul>
   *    <li/>viewWillStartZooming : function (vs.ui.ScrollView the view)
   *    <li/>viewDidEndZooming : function (vs.ui.ScrollView the view, number scale)
   *  </ul>
   * @name vs.ui.ScrollView#delegate 
   * @type {Object}
   */ 
  set : function (v)
  {
    this._delegate = v;
  }
},
'scroll': {
  /** 
   * Allow to scroll the view.
   * By default it not allowed
   * @name vs.ui.ScrollView#scroll 
   * @type {boolean|number}
   */ 
  set : function (v)
  {
    if (v === this._scroll) return;
    if (!v)
    {
      if (this.__iscroll__)
      {
        this.__iscroll__.destroy ();
        this.__iscroll__ = undefined;
      }
      this._scroll = false;
    }
    else if (v === true || v === 1 || v === 2 || v === 3)
    {
      this._scroll = v;
      this._setup_iscroll ();
    }
  },
  
  /** 
   * @ignore
   * @type {boolean}
   */ 
  get : function ()
  {
    return this._scroll;
  }
},
'pinch': {  
  /** 
   * Configures the view pinch.
   * By default it not allowed (vs.ui.ScrollView.NO_PINCH)
   * @name vs.ui.ScrollView#pinch 
   * @type {number}
   * @see vs.ui.ScrollView.NO_PINCH
   * @see vs.ui.ScrollView.SCALE
   * @see vs.ui.ScrollView.ROTATION
   * @see vs.ui.ScrollView.ROTATION_AND_SCALE
   */ 
  set : function (v)
  {
    if (v !== ScrollView.NO_PINCH && v !== ScrollView.ROTATION  &&
        v !== ScrollView.SCALE  && v !== ScrollView.ROTATION_AND_SCALE)
    { return; }
    
    if (!this.view) { return; }

//     if (v === ScrollView.NO_PINCH && this._pinch !== ScrollView.NO_PINCH)
//     {
//       this.view.removeEventListener ('gesturestart', this);
//     }
//     else if (v !== ScrollView.NO_PINCH && this._pinch === ScrollView.NO_PINCH)
//     {
//       this.view.addEventListener ('gesturestart', this);
// //      this.view.addEventListener ('touchstart', this);
//     }
    this._pinch = v;
  }
},
'animationDuration': {
  /** 
   * Set the animation/transition temporisation (in millisecond)
   * @name vs.ui.ScrollView#animationDuration 
   * @type {number}
   */ 
  set : function (time)
  {
    if (!time) { time = 0; }
    if (!util.isNumber (time)) { return };
    
    this._animation_duration = time;
    
    if (!this._sub_view) { return; }
    
    this._sub_view.style.webkitTransitionDuration = time + 'ms';
    
    if (this.hScrollbar || this.vScrollbar)
    {
      this._scroll_transition_time (time);
    }
  }
},
'layout': {
  /** 
   * This property allows you to specify a layout for the children
   * <p>
   * <ul>
   *    <li /> vs.ui.View.DEFAULT_LAYOUT
   *    <li /> vs.ui.View.HORIZONTAL_LAYOUT
   *    <li /> vs.ui.View.VERTICAL_LAYOUT
   *    <li /> vs.ui.View.ABSOLUTE_LAYOUT
   *    <li /> vs.ui.View.FLOW_LAYOUT
   * </ul>
   * @name vs.ui.ScrollView#layout 
   * @type String
   */ 
  set : function (v)
  {
    if (v !== View.HORIZONTAL_LAYOUT &&
        v !== View.DEFAULT_LAYOUT &&
        v !== View.ABSOLUTE_LAYOUT &&
        v !== View.VERTICAL_LAYOUT &&
        v !== View.FLOW_LAYOUT &&
        v !== View.LEGACY_HORIZONTAL_LAYOUT &&
        v !== View.LEGACY_ABSOLUTE_LAYOUT &&
        v !== View.LEGACY_VERTICAL_LAYOUT &&
        v !== View.LEGACY_FLOW_LAYOUT && v)
    {
      console.error ("Unsupported layout '" + v + "'!");
      return;
    }

    if (v && v.indexOf ("_layout") === -1) v = v + "_layout";

    if (!this._sub_view)
    { 
      this._layout = v;
      return;
    }

    if (this._layout)
    {
      util.removeClassName (this._sub_view, this._layout);
    }
    this._layout = v;
    if (this._layout)
    {
      util.addClassName (this._sub_view, this._layout);
    }
  }
},

'innerHTML': {

  /**
   * This property allows to define both the HTML code and the text
   * @name vs.ui.ScrollView#innerHTML
   * @type String
   */
  set : function (v)
  {
    if (!this._sub_view) return;

    util.safeInnerHTML (this._sub_view, v);
  },
}
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.ScrollView = ScrollView;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.ui.ScrollImageView class
 *
 *  @extends vs.ui.ScrollView
 *  @class
 *  An vs.ui.ScrollImageView embeds an image in your application.
 *  It provides an efficient way to display images in a view while at the 
 *  same time supporting a number of image transformation to fit the image
 *  within the view space.
 *  <p>
 *  Events:
 *  <ul>
 *    <li/> load. Fired when the image is loaded.
 *  </ul>
 *
 *  @example
 *  var config = {}
 *  var config.id = 'myImg';
 *  var config.src = 'http://xxx/xxx/img.png;
 *
 *  var img = vs.ui.ScrollImageView (config);
 *  img.init ();
 * <p>
 *
 *  @author David Thevenin
 * @name vs.ui.ScrollImageView
 *
 *  @constructor
 *   Creates a new vs.ui.ScrollImageView.
 *
 * @param {Object} config the configuration structure [mandatory]
*/
function ScrollImageView (config)
{
  this.parent = ScrollView;
  this.parent (config);
  this.constructor = ScrollImageView;
}

/**
 * No stretch.<br/>
 * Image proportion is respected, but a part can be hidden if
 * its size is bigger than widget's size.
 * @name vs.ui.ScrollImageView.STRETCH_NONE
 * @const
 */
ScrollImageView.STRETCH_NONE = 0;

/**
 * Image is stretched to fit the widget width and height.<br/>
 * Image proportion could be not respected.
 * @name vs.ui.ScrollImageView.STRETCH_FILL
 * @const
 */
ScrollImageView.STRETCH_FILL = 1;

/**
 * Image is stretched to fit the widget width or height.<br/>
 * Image proportion is respected and the entire image is visible.
 * @name vs.ui.ScrollImageView.STRETCH_UNIFORM
 * @const
 */
ScrollImageView.STRETCH_UNIFORM = 2;

/**
 * Image is stretched to fit the widget width or height.<br/>
 * Image proportion is respected and a part of the image can be hidden.
 * @name vs.ui.ScrollImageView.STRETCH_UNIFORM_FILL
 * @const
 */
ScrollImageView.STRETCH_UNIFORM_FILL = 3;

ScrollImageView.prototype = {

  /**
   * @protected
   * @type {Image}
   */
  _image_data: null,

  /**
   * @protected
   * @type {number}
   */
  _image_width: 0,

  /**
   * @protected
   * @type {Image}
   */
  _image_height: 0,

  /**
   * @protected
   * @type {boolean}
   */
  _image_loaded: false,

  /**
   * The image url
   * @private
   * @type {string}
   */
  _src: null,

  /**
   * The image stretch to fit the view or not
   * @private
   * @type {number}
   */
  _stretch: ScrollImageView.STRETCH_FILL,

  /*****************************************************************
   *
   ****************************************************************/
   
  /**
   * @protected
   * @function
   */
  destructor : function ()
  {
    if (this._sub_view)
    {
      this._image_data.onload = null;
      delete (this._image_data);
      this._image_loaded = false;

      // force image free
      this._sub_view.src = 
        'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';
    }
    
    ScrollView.prototype.destructor.call (this);
  },
     
  /**
   * @ignore
   * @function
   */
  show: function ()
  {
    ScrollView.prototype.show.call (this);
    // reapply stretch mode
    this.stretch = this._stretch;
  },
  
  /**
   * @protected
   * @function
   */
  refresh : function ()
  {
    if (this._sub_view && this._image_loaded) {
    
      if (this._stretch === ScrollImageView.STRETCH_FILL)
      {
        this._sub_view.setAttribute ('width', "100%");
        this._sub_view.setAttribute ('height', "100%");
      }
      else if (this._stretch === ScrollImageView.STRETCH_NONE)
      {
        this._sub_view.removeAttribute ('width');
        this._sub_view.removeAttribute ('height');
      }
      else if (this._stretch === ScrollImageView.STRETCH_UNIFORM)
      {
        var r1 = this._size[0] / this._size[1],
          r2 = this._image_width / this._image_height,
          delta = 0, scale = 1;
      
        if (r1 < r2)
        {
          scale = this._image_width / this._size[0];
          delta = (this._size[1] - this._image_height / scale) / 2;
          this._sub_view.setAttribute ('width', "100%");
          this._sub_view.removeAttribute ('height');
          this._sub_view.style.left = "0px";
          this._sub_view.style.top = delta + "px";
        }
        else
        {
          scale = this._image_height / this._size[1];
          delta = (this._size[0] - this._image_width / scale) / 2;
          this._sub_view.removeAttribute ('width');
          this._sub_view.setAttribute ('height', "100%");
          this._sub_view.style.top = "0px";
          this._sub_view.style.left = delta + "px";
        }
      }
      else if (this._stretch === ScrollImageView.STRETCH_UNIFORM_FILL)
      {
        var r1 = this._size[0] / this._size[1],
          r2 = this._image_width / this._image_height;
      
        if (r1 > r2)
        {
          this._sub_view.setAttribute ('width', "100%");
          this._sub_view.removeAttribute ('height');
        }
        else
        {
          this._sub_view.removeAttribute ('width');
          this._sub_view.setAttribute ('height', "100%");
        }
      }
    }

    if (this.__scroll_activated) { this._scroll_refresh (this._pinch); }
    View.prototype.refresh.call (this);
  },

  /**
   * @protected
   * @function
   */
  _image_onload : function (event)
  { 
    this._image_loaded = true;
    this._image_width = this._image_data.width;
    this._image_height = this._image_data.height;
    
    if (this._sub_view)
    {
      this._sub_view.src = this._src;
    }
    this.stretch = this._stretch;
    this.propagate ('load');
    
    var self = this;
    vs.scheduleAction (function ()
    {
      self.refresh ();
//      self._applyInsideTransformation ();
    });
  },
  
  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    ScrollView.prototype.initComponent.call (this);

    var self = this, size;
    this._image_data = new Image ();
    this._image_data.onload = function (e) { self._image_onload (e); };
    
    this.pinch = this._pinch;
    this.pan = this._pan;

    // init default image src with the attribute node img.src
    // if it exists. Use getAttribute instead of direct property
    // in order to have a relative path (without base)
    if (this._sub_view && this._sub_view.src)
    {
      this._src = this._sub_view.getAttribute ('src');
      this._image_data.src = this._src;
      this._image_onload ();
    }

    if (this._sub_view)
    {
      this._sub_view.ondragstart =
        function (e) { e.preventDefault(); return false; }

      // reapply stretch mode
      this.stretch = this._stretch;
    }
    
    this.refresh ();
//    this._applyInsideTransformation ();
  }
};
util.extendClass (ScrollImageView, ScrollView);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (ScrollImageView, {

'src': {
  /**
   * Set the image url
   * @name vs.ui.ScrollImageView#src 
   * @type {string}
   */
  set : function (v)
  {
    if (!util.isString (v)) { return; }
    
    this._image_loaded = false;
    this._src = v;
    this._image_data.src = this._src;
  },

  /**
   * Get the image url
   * @ignore
   * @return {string}
   */
  get : function ()
  {
    return this._src;
  }
},
'stretch': {
  /**
   * Configure the image to fit the view or to keep its original size.
   * <p>The property can take four values : 
   * <ul>
   *   <li/>vs.ui.ScrollImageView.STRETCH_NONE;
   *   <li/>vs.ui.ScrollImageView.STRETCH_FILL;
   *   <li/>vs.ui.ScrollImageView.STRETCH_UNIFORM;
   *   <li/>vs.ui.ScrollImageView.STRETCH_UNIFORM_FILL.
   * </ul>
   * @name vs.ui.ScrollImageView#stretch 
   * @type {number}
   */
  set : function (v)
  {
    if (!util.isNumber (v)) { return; }
    if (v !== ScrollImageView.STRETCH_FILL &&
        v !== ScrollImageView.STRETCH_NONE &&
        v !== ScrollImageView.STRETCH_UNIFORM && 
        v !== ScrollImageView.STRETCH_UNIFORM_FILL)
    { return; }
    
    this._stretch = v;
    this.refresh ();
  },

  /**
   * Get the image stretch mode (vs.ui.ScrollImageView.STRETCH_FILL or 
   * vs.ui.ScrollImageView.STRETCH_NONE)
   * @ignore
   * @return {number}
   */
  get : function ()
  {
    return this._stretch;
  }
},
'size': {
  /**
   * Set the image size
   * @name vs.ui.ScrollImageView#size 
   *
   * @type {Array.<number>}
   */
  set : function (v)
  {
    if (!util.isArray (v) && v.length !== 2)
    {
      if (!util.isNumber (v[0]) || !util.isNumber(v[1])) { return; }
    }
    
    // reapply stretch mode
    this.stretch = this._stretch;
    
    this._size [0] = v [0];
    this._size [1] = v [1];
    this._updateSizeAndPos ();
  },

  /**
   * @ignore
   * @return {Array.<number>} v
   */
  get : function ()
  {
    if (this.view && this.view.parentNode)
    {
      this._size [0] = this.view.offsetWidth;
      this._size [1] = this.view.offsetHeight;
    }
    return this._size.slice ();
  }
}
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.ScrollImageView = ScrollImageView;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * The vs.ui.TextArea component defines a multi-line text input control.
 * A text area can hold an unlimited number of characters, and the text
 * renders in a fixed-width font.
 * 
 * @constructor
 * @name vs.ui.TextArea
 * @extends vs.ui.View
 * @class
 *  The vs.ui.TextArea component defines a multi-line text input control. A text area can hold an unlimited number of characters, and the text renders in a fixed-width font.
 *  <p>
 *  Events:
 *  <ul>
 *    <li/> continuous_change: data [text]; the current text
 *    <li/> change: data [text]: Data is the current text
 *  </ul>
 *  <p>
 */
function TextArea (config)
{
  this.parent = View;
  this.parent (config);
  this.constructor = TextArea;
}

TextArea.prototype = {
  
  /**
   * Translate value on x
   * @private
   * @type {number}
   */
  _ab_view_t_x : 0,

  /**
   * Translate value on y
   * @private
   * @type {number}
   */
  _ab_view_t_y : 0,

  /**
   * The text value
   * @protected
   * @type {string}
   */
  _value: "",

/*****************************************************************
 *
 ****************************************************************/

  /**
   * @protected
   * @function
   */
  destructor : function ()
  {
    this.view.removeEventListener ('change', this);
    this.view.removeEventListener ('focus', this);
    this.view.removeEventListener ('blur', this);
    this.view.removeEventListener ('textInput', this);

    View.prototype.destructor.call (this);
  },

  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    View.prototype.initComponent.call (this);
    
    if (!util.isString (this._value)) {return;}
    
    this.view.value = this._value;

    this.view.addEventListener ('textInput', this);
    this.view.addEventListener ('change', this);
    this.view.addEventListener ('focus', this);
    this.view.addEventListener ('blur', this);
  },
    
  /**
   *  Set the focus to your input
   *
   * @name vs.ui.TextArea#setFocus 
   * @function
   */
  setFocus : function ()
  {
    this.view.focus ();
  },

  /**
   *  Remove the focus to your input
   *
   * @name vs.ui.TextArea#setBlur 
   * @function
   */
  setBlur : function ()
  {
    this.view.blur ();
  },

  /*****************************************************************
   *                Events Management
   ****************************************************************/

  /**
   *  set pointer events
   *  @TODO a documenter un peu
   *
   * @name vs.ui.TextArea#setPointerEvents 
   * @function
   */
  setPointerEvents : function (v)
  {
    if (v)
    { this._text_field.style.pointerEvents = 'none'; }
    else
    { this._text_field.style.pointerEvents = 'auto'; }
  },

  /**
   * @protected
   * @function
   */
  handleEvent : function (event)
  {
    var self = this;
    function manageBlur (event)
    {
      if (event.src === self.view)
      { return; }
      
      vs.removePointerListener (document, core.POINTER_START, manageBlur, true);
      self.setBlur ();
    }
    
    switch (event.type)
    {
      case 'focus':
        vs.addPointerListener (document, core.POINTER_START, manageBlur, true);
      break;

      case 'blur':
      break;
      
      case 'change':
        this._value = this.view.value;
        this.outPropertyChange ();
        this.propagate ('change', this._value);
        break;
        
      case  'textInput':
        this._value = this.view.value;
        this.outPropertyChange ();
        this.propagate ('continuous_change', this._value);
        break;
    }
  }
};
util.extendClass (TextArea, View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperty (TextArea, "value", {
  /**
   * Set the text value
   * @param {string} v
   */
  set : function (v)
  {
    if (v === null || typeof (v) === "undefined") { v = ''; }
    else if (util.isNumber (v)) { v = '' + v; }
    else if (!util.isString (v))
    {
      if (!v.toString) { return; }
      v = v.toString ();
    }
    this._value = v;
    
    this.view.value = v;
  },

  /**
   * get the text value
   * @ignore
   * @type {string}
   */
  get : function ()
  {
    return this._value;
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.TextArea = TextArea;
/*
  COPYRIGHT NOTICE
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/


/**
 *  The vs.ui.Button class
 *
 *  @extends vs.ui.View
 *  @class
 *  The Button class is a subclass of vs.ui.View that intercepts pointer-down
 *  events and sends an 'select' event to a target object when it’s clicked
 *  or pressed.
 *
 *  Events:
 *  <ul>
 *    <li /> select: Fired after the button is clicked or pressed.
 *  </ul>
 *  <p>
 *  @example
 *  // Simple example: (the button will have the platform skin)
 *  var config = {}
 *  var config.id = 'mybutton';
 *  var config.text = 'Hello';
 *
 *  var myButton = Button (config);
 *  myButton.init ();
 *
 *  @example
 *  // Button with our own style
 *  var config = {}
 *  var config.id = 'mybutton';
 *  var config.text = 'Hello';
 *
 *  var myButton = vs.ui.Button (config);
 *  myButton.init ();
 *
 * <p>
 *
 *  @author David Thevenin
 * @name vs.ui.Button
 *
 *  @constructor
 *   Creates a new vs.ui.Button.
 *
 * @param {Object} config the configuration structure [mandatory]
*/
function Button (config)
{
  this.parent = View;
  this.parent (config);
  this.constructor = Button;
}

/**
 * default button
 * @name vs.ui.Button.DEFAULT_TYPE
 * @const
 */
Button.DEFAULT_TYPE = 'default';

/**
 * default style button
 * @name vs.ui.Button.DEFAULT_STYLE
 * @const
 */
Button.DEFAULT_STYLE = 'default_style';

/**
 * default style button
 * @name vs.ui.Button.GREEN_STYLE
 * @const
 */
Button.GREEN_STYLE = 'green';

/**
 * default style button
 * @name vs.ui.Button.RED_STYLE
 * @const
 */
Button.RED_STYLE = 'red';

/**
 * default style button
 * @name vs.ui.Button.GREY_STYLE
 * @const
 */
Button.GREY_STYLE = 'grey';

/**
 * Navigation button
 * @name vs.ui.Button.NAVIGATION_TYPE
 * @const
 */
Button.NAVIGATION_TYPE = 'nav';

/**
 * back button
 * @name vs.ui.Button.NAVIGATION_BACK_TYPE
 * @const
 */
Button.NAVIGATION_BACK_TYPE = 'nav_back';

/**
 * forward button
 * @name vs.ui.Button.NAVIGATION_FORWARD_TYPE
 * @const
 */
Button.NAVIGATION_FORWARD_TYPE = 'nav_forward';

/**
 * iPhone/iPad default style button
 * @name vs.ui.Button.BLUE_STYLE
 * @const
 */
Button.BLUE_STYLE = 'blue_style';

/**
 * iPhone/iPad black style button
 * @name vs.ui.Button.BLACK_STYLE
 * @const
 */
Button.BLACK_STYLE = 'black_style';

/**
 * iPhone/iPad silver style button
 * @name vs.ui.Button.SILVER_STYLE
 * @const
 */
Button.SILVER_STYLE = 'silver_style';

Button.prototype = {
  
  /*****************************************************************
   *               private/protected members
   ****************************************************************/
   
  /**
   *
   * @private
   * @type {PointerRecognizer}
   */
  __tap_recognizer: null,

  /**
   *
   * @protected
   * @type {number}
   */
  _style: Button.DEFAULT_STYLE,

  /**
   *
   * @protected
   * @type {number}
   */
  _type: Button.DEFAULT_TYPE,

  /**
   *
   * @protected
   * @type {boolean}
   */
  _selected: false,

  /**
   *
   * @protected
   * @type {string}
   */
  _text: "",

  /**
   *
   * @protected
   * @type {string}
   */
  _released_image: "",

  /**
   *
   * @protected
   * @type {string}
   */
  _selected_image: "",

  /**
   *
   * @protected
   * @type {string}
   */
  _disabled_image: "",

  /*****************************************************************
   *               General methods
   ****************************************************************/
    
  /**
   * @protected
   * @function
   */
  didTouch : function ()
  {
    this.addClassName ('pressed');
    this._selected = true;
  },
  
  /**
   * @protected
   * @function
   */
  didUntouch : function ()
  {
    this.removeClassName ('pressed');
    this._selected = false;
  },
  
  didTap : function ()
  {
    this.propagate ('select');
  },
  
  /**
   * @protected
   * @function
   */
  destructor : function ()
  {
    if (this.__tap_recognizer)
    {
      this.removePointerRecognizer (this.__tap_recognizer);
      this.__tap_recognizer = null;
    }
    View.prototype.destructor.call (this);
  },

  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    View.prototype.initComponent.call (this);
    
    this.text_view = this.view.firstElementChild;

    if (!this.__tap_recognizer)
    {
      this.__tap_recognizer = new TapRecognizer (this);
      this.addPointerRecognizer (this.__tap_recognizer);
    }

    if (this._text)
    {
      this.text = this._text;
    }
    else
    {
      this.text = "";
    }
    this.view.name = this.id;
    if (this._style) this.addClassName (this._style);
    if (this._type) this.addClassName (this._type);
  }
};
util.extendClass (Button, View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (Button, {
  'text': {
    /** 
     * Getter|Setter for text. Allow to get or change the text draw
     * by the button
     * @name vs.ui.Button#text 
     * @type String
     */ 
    set : function (v)
    {
      if (v === null || typeof (v) === "undefined") { v = ''; }
      else if (util.isNumber (v)) { v = '' + v; }
      else if (!util.isString (v))
      {
        if (!v.toString) { return; }
        v = v.toString ();
      }
  
      this._text = v;
      if (this.text_view)
      {
        util.setElementInnerText (this.text_view, this._text);
      }
    },
  
    /** 
     * @ignore
     * @return {string}
     */ 
    get : function ()
    {
      return this._text;
    }
  },
  'style': {
    /** 
     * Getter|Setter for the button style (for instance blue, sliver, ...)
     * @name vs.ui.Button#style 
     * @type {string}
     */ 
    set : function (v)
    {
      if (!util.isString (v)) { return; }
      
      // code to remove legacy spec
      v = v.replace ('_ios', '');
      
      if (this._style)
      {
        this.removeClassName (this._style);
      }
      this._style = v;
      this.addClassName (this._style);
    },
  
    /** 
     * @ignore
     * @return {string}
     */ 
    get : function ()
    {
      return this._style;
    }
  },
  'type': {
    /** 
     * Getter|Setter for the button type (DEFAULT_TYPE, NAVIGATION_TYPE,…)
     * @name vs.ui.Button#type 
     * @type {string}
     */ 
    set : function (v)
    {
      if (!util.isString (v)) { return; }
      if (this._type)
      {
        this.removeClassName (this._type);
      }
      this._type = v;
      this.addClassName (this._type);
    },
  
    /** 
     * @ignore
     * @return {string}
     */ 
    get : function ()
    {
      return this._type;
    }
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.Button = Button;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/


/**
 *  The vs.ui.AbstractList class
 *
 *  @extends vs.ui.ScrollView
 *  @class
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.ui.AbstractList.
 * @name vs.ui.AbstractList
 *
 * @param {Object} config the configuration structure [mandatory]
 */
function AbstractList (config)
{
  this.parent = ScrollView;
  this.parent (config);
  this.constructor = AbstractList;
}

AbstractList.prototype = {

 /**********************************************************************
                 General data for the list
  *********************************************************************/

  /**
   *
   * @private
   * @type {PointerRecognizer}
   */
  __tap_recognizer: null,
  __list_time_out: 0,

   /**
   * @protected
   * @type {boolean}
   */
  _items_selectable : true,
  
   /**
   * @protected
   * @type {boolean}
   */
  _scroll: 0,
  
  /**
   * @private
   * @type {vs.core.Array}
   */
  _model: null,
       
 /**********************************************************************
                  Data Used for managing scroll states
  *********************************************************************/
  
  /**
   *  @private
   */
   __elem : null,
     
  /**
   * @private
   * @type {int}
   */
  __scroll_start: 0,

 /**********************************************************************

  *********************************************************************/

  /**
   * @protected
   * @function
   */
  add : function () { },
  
  /**
   * @protected
   * @function
   */
  remove : function (child) {},
      
 /**********************************************************************

  *********************************************************************/
  
  /**
   * @protected
   * @function
   */
  destructor: function ()
  {
    ScrollView.prototype.destructor.call (this);
    
    if (this.__tap_recognizer)
    {
      this.removePointerRecognizer (this.__tap_recognizer);
      this.__tap_recognizer = null;
    }

    this._model.unbindChange (null, this, this._modelChanged);
    if (this._model_allocated) util.free (this._model);
    this._model_allocated = false;
  },
  
  /**
   * @protected
   * @function
   */
  initComponent: function ()
  {
    ScrollView.prototype.initComponent.call (this);
    
    this._model = new vs.core.Array ();
    this._model.init ();
    this._model_allocated = true;
    this._model.bindChange (null, this, this._modelChanged);
    
    // manage list template without x-hag-hole="item_children"
    if (!this._holes.item_children) {
      this._holes.item_children = this.view.querySelector ('ul');
    }
    
    this._list_items = this._sub_view = this._holes.item_children;

    if (!this.__tap_recognizer)
    {
      this.__tap_recognizer = new TapRecognizer (this);
      this.addPointerRecognizer (this.__tap_recognizer);
    }

    this.refresh ();
  },
    
  /**
   * @protected
   * @function
   */
  refresh : function ()
  {
    if (this.__iscroll__) this.__iscroll__.refresh ();
    ScrollView.prototype.refresh.call (this);
  },

  /**
   * @protected
   * @function
   */
  _modelChanged : function ()
  {
    // TODO   on peut mieux faire : au lieu de faire
    // un init skin qui vire tout et reconstruit tout, on pourrait
    // ne gerer que la difference
    this._renderData (this._items_selectable);
    this.refresh ();
  },
    
  /**
   * @protected
   * @function
   */
  propertiesDidChange: function () {
    this._modelChanged ();
    return true;
  },
  
  /**
   * @protected
   * @function
   */
  _renderData : function () {},
    
  /**
   * @protected
   * @function
   */
  _touchItemFeedback : function (item) {},
      
  /**
   * @protected
   * @function
   */
  _untouchItemFeedback : function (item) {},

  /**
   * @protected
   * @function
   */
  _updateSelectItem : function (item) {},

  /**
   * @protected
   * @function
   */
  didTouch : function (comp, target, e)
  {
    if (!this._items_selectable) { return false; }
    
    if (target === this._sub_view || target === this.view) {
      this.__elem = null;
      return;
    }
    
    this.__elem = target;
    if (this.__list_time_out) {
      clearTimeout (this.__list_time_out);
      this.__list_time_out = 0;
    }
    if (this.__elem_to_unselect)
    {
      this._untouchItemFeedback (this.__elem_to_unselect);
      this.__elem_to_unselect = null;
    }
    this.__elem_to_unselect = target;
    if (target) this._touchItemFeedback (target);
  },
  
  /**
   * @protected
   * @function
   */
  didUntouch : function (comp, e, target)
  {
    if (!this.__list_time_out && this.__elem_to_unselect)
    {
      this._untouchItemFeedback (this.__elem_to_unselect);
      this.__elem_to_unselect = null;
    }
    this.__elem = null;
  },
  
  didTap : function (nb_tap, comp, target, e)
  {
    var self = this;
    this.__elem_to_unselect = this.__elem;
    if (this.__elem) {
      this._updateSelectItem (this.__elem);

      this.__list_time_out = setTimeout (function () {
        if (self.__elem_to_unselect) {
          self._untouchItemFeedback (self.__elem_to_unselect);
        }
        self.__elem_to_unselect = null;
        self.__list_time_out = 0;
      }, View.UNSELECT_DELAY);
    }
  },

  /**
   * Scroll the list to the element at the set index
   * <p>
   * If to time is defined, the default time is set to 200ms.
   *
   * @name vs.ui.AbstractList#scrollToElementAt 
   * @function
   * @param {Number} index the element index
   * @param {Number} time [Optional] the scroll duration
   */
  scrollToElementAt: function (index, time)
  {
    if (!this.__iscroll__) { return; }
    if (!util.isNumber (time)) { time = 200; }
    var elem = this.__item_obs [index];
    if (!elem) { return; }

		var pos = this.__iscroll__._offset (elem.view);
		pos.top += this.__iscroll__.wrapperOffsetTop;

		pos.top = pos.top > this.__iscroll__.minScrollY ?
		  this.__iscroll__.minScrollY :
		  pos.top < this.__iscroll__.maxScrollY ?
		    this.__iscroll__.maxScrollY : pos.top;
		    
		this.__iscroll__.scrollTo (0, pos.top, 200);
  }
};
util.extendClass (AbstractList, ScrollView);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (AbstractList, {

  'scroll': {
    /** 
     * Allow to scroll the list items.
     * By default it not allowed
     * @name vs.ui.CheckBox#scroll 
     * @type {boolean}
     */ 
    set : function (v)
    {
      if (v)
      {
        this._scroll = ScrollView.VERTICAL_SCROLL;
        this._setup_iscroll ();
      }
      else
      {
        if (this.__iscroll__)
        {
          this.__iscroll__.destroy ();
          this.__iscroll__ = undefined;
        }
        this._scroll = false;
      }
    },
  
    /** 
     * @ignore
     * @type {boolean}
     */ 
    get : function ()
    {
      return this._scroll?true:false;
    }
  },
  
  'model': {
    /** 
     * Getter|Setter for data. Allow to get or change the vertical list
     * @name vs.ui.AbstractList#model 
     *
     * @type vs.core.Array
     */ 
    set : function (v)
    {
      if (!v) return;
      
      if (util.isArray (v))
      {
        this._model.removeAll ();
        this._model.add.apply (this._model, v);
      }
      else if (v.toJSON && v.propertyChange)
      {
        if (this._model_allocated)
        {
          this._model.unbindChange (null, this, this._modelChanged);
          util.free (this._model);
        }
        this._model_allocated = false;
        this._model = v;
        this._model.bindChange (null, this, this._modelChanged);
      }
    },
  
    /**
     * @ignore
     */
    get : function ()
    {
      return this._model;
    }
  },
  
  'data': {
    /** 
     * Getter|Setter for data. Allow to get or change the vertical list
     * @name vs.ui.AbstractList#data 
     *
     * @deprecated
     * @see vs.ui.AbstractList#model 
     * @type Array
     */ 
    set : function (v)
    {
      if (!util.isArray (v)) return;
      
      if (!this._model_allocated)
      {
        this._model = new vs.core.Array ();
        this._model.init ();
        this._model_allocated = true;
        this._model.bindChange (null, this, this._modelChanged);
      }
      else
      {
        this._model.removeAll ();
      }
      this._model.add.apply (this._model, v);

      this._modelChanged ();
    },
  
    /**
     * @ignore
     */
    get : function ()
    {
      return this._model._data.slice ();
    }
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.AbstractList = AbstractList;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @public
 * @name vs.ui.AbstractListItem
 */
var AbstractListItem = function (config)
{
  this.parent = View;
  this.parent (config);
  this.constructor = AbstractListItem;
}

AbstractListItem.prototype = {

  /**
   * @protected
   * @function
   */
  _index: 0,

  /**
   * @protected
   * @function
   */
  _pressed: false,
 
  /**
   * @protected
   * @function
   */
  _visible: true,
  
 /**********************************************************************
                 General method
  *********************************************************************/
  /**
   * This method should be implemented to manage item selection
   *
   * @name vs.ui.AbstractListItem#didSelect 
   * @function
   */
  didSelect : function () {}
};
util.extendClass (AbstractListItem, View);

util.defineClassProperties (AbstractListItem, {

  'pressed': {
    /** 
     * @name vs.ui.AbstractListItem#pressed 
     * @type {boolean}
     */ 
    set : function (v)
    {
      if (!this.view) { return; }
      
      if (v)
      {
        this.addClassName ('pressed');
        this._pressed = true;
      }
      else
      {
        this.removeClassName ('pressed');
        this._pressed = false;
      }
    },
  
    /** 
     * @ignore
     * @type {boolean}
     */ 
    get : function ()
    {
      return this._pressed;
    }
  },
  
  'index': {
    /** 
     * @name vs.ui.AbstractListItem#index 
     *
     * @type {number}
     */ 
    set : function (v)
    {
      this._index = v;
    },
  
    /**
     * @ignore
     */
    get : function ()
    {
      return this._index;
    }
  }
});

/**
 * @name vs.ui.DefaultListItem
 * @private
 */
function DefaultListItem ()
{
  this.parent = AbstractListItem;
  this.parent ();
  this.constructor = AbstractListItem;
}

DefaultListItem.prototype = {

  _title: "",
  _label: "",

 /**********************************************************************
                  In/Out properties declarations 
  *********************************************************************/

  /** 
   * @name vs.ui.DefaultListItem#title
   */ 
  set title (v)
  {
    if (v === null || typeof (v) === "undefined") { v = ''; }
    else if (util.isNumber (v)) { v = '' + v; }
    else if (!util.isString (v))
    {
      if (!v.toString) { return; }
      v = v.toString ();
    }
    
    this._title = v;
    if (this.view)
    {
      util.setElementInnerText (this.view, this._title);
      this.view.appendChild (this._label_view);
    }
  },

  /**
   * @ignore
   */ 
  set label (v)
  {
    if (v === null || typeof (v) === "undefined") { v = ''; }
    else if (util.isNumber (v)) { v = '' + v; }
    else if (!util.isString (v))
    {
      if (!v.toString) { return; }
      v = v.toString ();
    }
    
    this._label = v;
    if (this.view)
    {
      util.setElementInnerText (this._label_view, this._label);
    }
    if (this._label && !this._label_view.parentNode)
      this.view.appendChild (this._label_view);
    if (!this._label && this._label_view.parentNode)
      this.view.removeChild (this._label_view);
  },
  
  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    if (!this.__config__) this.__config__ = {};
    this.__config__.id = this.id;

    if (!this.__config__.node)
      this.__config__.node = document.createElement ('li');
      
    AbstractListItem.prototype.initComponent.call (this);

    this._label_view = document.createElement ('span');
  }
};
util.extendClass (DefaultListItem, AbstractListItem);

/**
 * @name vs.ui.SimpleListItem
 * @private
 */
function SimpleListItem (config)
{
  this.parent = View;
  this.parent (config);
  this.constructor = SimpleListItem;
}

SimpleListItem.prototype = {

  _title: "",

 /**********************************************************************
                  In/Out properties declarations 
  *********************************************************************/
  /** 
   * @name vs.ui.SimpleListItem#title
   */ 
  set title (v)
  {
    if (v === null || typeof (v) === "undefined") { v = ''; }
    else if (util.isNumber (v)) { v = '' + v; }
    else if (!util.isString (v))
    {
      if (!v.toString) { return; }
      v = v.toString ();
    }
    
    this._title = v;
    if (this.view)
    {
      util.setElementInnerText (this.title_view, this._title);
    }
  },

 /**********************************************************************

  *********************************************************************/
  
  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    if (!this.__config__) this.__config__ = {};
    this.__config__.id = this.id;

    if (!this.__config__.node)
    {
      this.__config__.node = document.createElement ('div');
      this.__config__.node.className = 'simplelist_item';
      
      var div = document.createElement ('div');
      div.className = 'title';
      this.__config__.node.appendChild (div);
    }
      
    AbstractListItem.prototype.initComponent.call (this);

    this._label_view = document.createElement ('span');

    this.title_view = this.view.querySelector ('.title');
  }
};
util.extendClass (SimpleListItem, View);

/**********************************************************************
 
           Block List and Tab List section

*********************************************************************/

/**
 * @private
 */
function buildSection (list, title, index, itemsSelectable)
{
  var section = document.createElement ('li'), 
    title_view = document.createElement ('div'), 
    content = document.createElement ('ul'), 
    cells, item, obj, data = list._model, listItem;

  while (index < data.length)
  {
    item = data.item (index);
    if (util.isString (item)) { break; }
    
    item = data.item (index);
    if (list.__template_class)
    {
      listItem = new list.__template_class () .init ();
    }
    else if (list.__template_obj)
    {
      listItem = list.__template_obj.clone ();
    }
    else
    {
      listItem = new DefaultListItem ().init ();
    }
    // model update management
    if (item instanceof core.Model)
    {
      listItem.link (item);
    }
    else
    {
      listItem.configure (item)
    }
    listItem.index = index;

    if (itemsSelectable)
    {
      vs.addPointerListener (listItem.view, core.POINTER_START, list);
    }
    content.appendChild (listItem.view);
    list.__item_obs.push (listItem);
    listItem.__parent = list;
    index ++;
  }
  if (title)
  {
    
    var os_device = window.deviceConfiguration.os;
    if (os_device == DeviceConfiguration.OS_MEEGO ||
        os_device == DeviceConfiguration.OS_SYMBIAN)
    {
      title_view.appendChild (document.createElement ('div'));
      var tmp_title = document.createElement ('div');
      tmp_title.appendChild (document.createTextNode (title));
      title_view.appendChild (tmp_title);
    }
    else
    {
      util.setElementInnerText (title_view, title);
    }
    section.appendChild (title_view);
  }
  if (content.childElementCount > 0)
  {
    section.appendChild (content);
  }
  return [section, index];
};

/**
 * @private
 */
function blockListRenderData (itemsSelectable)
{
  if (!this._model) { return; }
     
  var _list_items = this._list_items, index, item, title,
    s, width, titles, i, items;
  if (!_list_items) { return; }
   
// remove all children
  this._freeListItems ();
  
  util.removeAllElementChild (_list_items);

  if (SUPPORT_3D_TRANSFORM)
    setElementTransform (_list_items, 'translate3d(0,0,0)');
  else
    setElementTransform (_list_items, 'translate(0,0)');

  var parentElement = _list_items.parentElement;
  parentElement.removeChild (_list_items);
  
  index = 0;
  util.setElementVisibility (_list_items, false);
  
  while (index < this._model.length)
  {
    item = this._model.item (index);
    title = null;
    if (util.isString (item))
    {
      title = item; index ++;
    }

    s = buildSection (this, title, index, itemsSelectable);
    _list_items.appendChild (s[0]);
    index = s[1];
  }
  parentElement.appendChild (_list_items);
  {
    _list_items.style.width = 'auto';
  }
  util.setElementVisibility (_list_items, true);
};

/**
 * @private
 */
function tabListRenderData (itemsSelectable)
{
  if (!this._model) { return; }
     
  var _list_items = this._list_items, _direct_access = this._direct_access,
    index, item, title,
    s, width, titles, i, items;
  if (!_list_items) { return; }
   
// remove all children
  this._freeListItems ();
  this.__direct_access_letters = [];
  
  util.removeAllElementChild (_list_items);
  if (_direct_access) util.removeAllElementChild (_direct_access);

  if (SUPPORT_3D_TRANSFORM)
    util.setElementTransform (_list_items, 'translate3d(0,0,0)');
  else
    util.setElementTransform (_list_items, 'translate(0,0)');

  var parentElement = _list_items.parentElement;
  parentElement.removeChild (_list_items);
  if (_direct_access) this.view.removeChild (_direct_access);
  
  index = 0;
  util.setElementVisibility (_list_items, false);
  var title_index = 0;
  while (index < this._model.length)
  {
    item = this._model.item (index);
    title = null;
    if (util.isString (item))
    {
      title = item; index ++;
      var elem = document.createElement ('div'),
        letter = title [0];
      util.setElementInnerText (elem, letter);
      this.__direct_access_letters.push (letter);
      elem._index_ = title_index++;
      if (_direct_access) _direct_access.appendChild (elem);
    }

    s = buildSection (this, title, index, itemsSelectable);
    _list_items.appendChild (s[0]);
    index = s[1];
  }
  parentElement.appendChild (_list_items);
  if (_direct_access) this.view.appendChild (_direct_access);
  _list_items.style.width = 'auto';
  util.setElementVisibility (_list_items, true);
};

/**********************************************************************
        
        
*********************************************************************/

/**
 * @private
 */
function defaultListRenderData (itemsSelectable)
{
  if (!this._model) { return; }
     
  var _list_items = this._list_items, index, item, title,
    s, width, titles, i, items, listItem;
  if (!_list_items) { return; }
   
  // remove all children
  this._freeListItems ();
  
  util.removeAllElementChild (_list_items);
  
  if (SUPPORT_3D_TRANSFORM)
    setElementTransform (_list_items, 'translate3d(0,0,0)');
  else
    setElementTransform (_list_items, 'translate(0,0)');

  var parentElement = _list_items.parentElement;
  parentElement.removeChild (_list_items);
  
  index = 0;
  util.setElementVisibility (_list_items, false);
        
  while (index < this._model.length)
  {
    item = this._model.item (index);
    if (this.__template_class)
    {
      listItem = new this.__template_class () .init ();
    }
    else if (this.__template_obj)
    {
      listItem = this.__template_obj.clone ();
    }
    else
    {
      listItem = new DefaultListItem ().init ();
    }
    // model update management
    if (item instanceof core.Model)
    {
      listItem.link (item);
    }
    else
    {
      listItem.configure (item);
    }
    listItem.index = index;

    if (itemsSelectable)
    {
      vs.addPointerListener (listItem.view, core.POINTER_START, this);
    }
    _list_items.appendChild (listItem.view);
    this.__item_obs.push (listItem);
    listItem.__parent = this;
    index ++;
  }
  parentElement.appendChild (_list_items);
  _list_items.style.width = 'auto';

  util.setElementVisibility (_list_items, true);
};

/**********************************************************************
        
        
*********************************************************************/

/**
 *  The vs.ui.List class
 *
 *  @extends vs.ui.AbstractList
 *  @class
 *  The vs.ui.List class draw a list of ListItem and allows the user to 
 *  select one object from it.
 *  <p>
 *  Events:
 *  <ul>
 *    <li />itemselect, fired when a item is selected.
 *          Event Data = {index, item data}
 *  </ul>
 *  <p>
 *  To reduce performance issues, you can deactivate events handling
 *  for the list, using vs.ui.List#itemsSelectable property.
 *
 * Data can be filtered. The filter he array contains the member to filters
 * and filter:
 * @ex:
 *   list.filters = [{
 *      property:'title',
 *      value:'o',
 *      matching:vs.ui.List.FILTER_CONTAINS,
 *      strict:true
 *   }];
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.ui.List.
 * @name vs.ui.List
 *
 * @param {Object} config the configuration structure [mandatory]
 */
function List (config)
{
  this.parent = AbstractList;
  this.parent (config);
  this.constructor = List;

  this.__item_obs = new Array ();
}

/**
 * @const 
 * @name vs.ui.List.FILTER_EXACTS
 */
List.FILTER_EXACTS = 0;

/**
 * @const 
 * @name vs.ui.List.FILTER_CONTAINS
 */
List.FILTER_CONTAINS = 1;

/**
 * @const 
 * @name vs.ui.List.FILTER_STARTS_WITH
 */
List.FILTER_STARTS_WITH = 2;

/**
 * @const 
 * @name vs.ui.List.BLOCK_LIST
 */
List.BLOCK_LIST = 'BlockList';

/**
 * @const 
 * @name vs.ui.List.TAB_LIST
 */
List.TAB_LIST = 'TabList';

/**
 * @const 
 * @name vs.ui.List.DEFAULT_LIST
 */
List.DEFAULT_LIST = 'DefaultList';

List.prototype = {

  _type: List.DEFAULT_LIST,
  
 /**********************************************************************
                 General data for the list
  *********************************************************************/
  
  /**
   * @private
   * @type {number}
   */
  _selected_index: 0,
  
  /**
   * @private
   * @type {number}
   */
  _selected_item: 0,
  
  /**
   * @private
   * @type {Array}
   */
  _filters: null,
  
  /**
   *  @protected
   *  @type {boolean}
   */
  _has_arrow : true,
     
 /**********************************************************************
                  Data Used for managing scroll states
  *********************************************************************/

  /**
   *  @private
   */
   __item_obs : null,
  
  /**
   *  @private
   */
   __elem : null,
     
  /**
   * @private
   * @type {vs.core.Object}
   */
  __template_obj: null,
  __template_class: null,

 /**********************************************************************

  *********************************************************************/

  /**
   * @protected
   * @function
   */
  add : function (child, extension)
  {
    this.setItemTemplate (child);
  },
  
  /**
   *  Set the template object will be used for list item
   *  <p>
   *  The object will be automatically cloned according list data.
   *  <p>
   *  The template must have the same properties than data. For instance :
   *  @example
   *    data = [{text: "title1", nb: 5}, {text: "title2", nb: 2}];
   *    template objet must have properties named "text" and "nb"
   *
   * @name vs.ui.List#setItemTemplate 
   * @function
   * @param {vs.ui.View | Class} obj the template object;
   */
  setItemTemplate : function (obj)
  {
    if (!obj) return;
    
    if (util.isFunction (obj)) {
      this.__template_obj = null
      this.__template_class = obj;
    }
    else if (obj.constructor) {
      this.__template_obj = obj;
      this.__template_class = null
    }
  },

  /**
   *  Set the template object will be used for list item
   *  <p>
   *  The object will be automatically cloned according list data.
   *  <p>
   *  The template must have the same properties than data. For instance :
   *  @example
   *    data = [{text: "title1", nb: 5}, {text: "title2", nb: 2}];
   *    template objet must have properties named "text" and "nb"
   *
   * @name vs.ui.List#setItemTemplateName 
   * @function
   * @param {string} name the component name
   * @return {vs.ui.View} the template object or null if an error occured
   */
  setItemTemplateName : function (name)
  {
    return this.createAndAddComponent (name, {}, 'item_children');
  },

  /**
   * @protected
   * @function
   */
  remove : function (child)
  {},
       
 /**********************************************************************

  *********************************************************************/

  /**
   * @protected
   * @function
   */
  destructor : function ()
  {
    this._freeListItems ();
    AbstractList.prototype.destructor.call (this);
  },

  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    AbstractList.prototype.initComponent.call (this);
    
    this.addClassName (this._type);  
    this.refresh ();
  },
  
  /**
   * Return the list of items in the vs.ui.List
   *
   * @name vs.ui.List#getItems 
   * @function
   * @return {Array} the items
   */
  getItems : function ()
  {
    if (this.__item_obs)
    {
      return this.__item_obs.slice ();
    }
    return [];
  },
  
  
  /**
   * @protected
   * @function
   */
  applyFilters : function ()
  {
    if (!this._filters || !this.__item_obs) { return; }
    
    var i, obj, item;
    
    for (i = 0; i < this.__item_obs.length; i++)
    {
      obj = this.__item_obs [i];
      item = this._model.item (obj.index);
      this.appyFiltersOnObj (obj, item);
    }
  },
  
  /**
   * @protected
   * @function
   */
  appyFiltersOnObj : function  (obj, item)
  {
    if (!this._filters || !obj || !item) { return; }
    
    var i, filter, toHide, vSrc, vTrg, l = this._filters.length;
    
    if (l === 0)
    {
      obj.show ();
      return;
    }
    for (i = 0; i < l; i++)
    {
      filter = this._filters [i];
      if (!filter.property || !filter.value)
      {
        obj.show ();
        continue;
      }
      
      toHide = false;
      vSrc = item[filter.property];
      vTrg = filter.value;
      
      if (filter.strict === false)
      {
        vSrc = vSrc.toLowerCase ();
        vTrg = vTrg.toLowerCase ();
      }
      
      switch (filter.matching)
      {
        case undefined:
        case null:
        case List.FILTER_EXACTS:
          if (vSrc !== vTrg)
          { toHide = true; }
        break;
        
        case List.FILTER_STARTS_WITH:
          if (vSrc.indexOf (vTrg) !== 0)
          { toHide = true; }
        break;
        
        case List.FILTER_CONTAINS:
          if (vSrc.indexOf (vTrg) === -1)
          { toHide = true; }
        break;
      }

      if (toHide)
      { obj.hide (); }
      else
      { obj.show (); }
    }
  },
  
  /**
   * @protected
   * @function
   */
  _freeListItems : function ()
  {
    var i, obj;
    for (i = 0 ; i < this.__item_obs.length; i ++)
    {
      obj = this.__item_obs [i];
      obj.__parent = undefined;
      util.free (obj);
    }
    
    this.__item_obs = [];
  },
  
  /**
   * @protected
   * @function
   */
  _renderData : defaultListRenderData,
  
  /**
   * @protected
   * @function
   */
  _modelChanged : function (event)
  {
    // TODO   on peut mieux faire : au lieu de faire
    // un init skin qui vire tout et reconstruit tout, on pourrait
    // ne gerer que la difference
    this._renderData (this._items_selectable);
    this.refresh ();
  },

  /**
   * @protected
   * @function
   */
  _touchItemFeedback : function (item)
  {
    item._comp_.pressed = true;
  },
  
  /**
   * @private
   * @function
   */
  _untouchItemFeedback : function (item)
  {
    item._comp_.pressed = false;
  },
      
  /**
   * @protected
   * @function
   */
  _updateSelectItem : function (item)
  {
    this._selected_index = item._comp_.index;
    this._selected_item = this._model.item (this._selected_index);
    if (item._comp_ && item._comp_.didSelect) item._comp_.didSelect ();
    
    this.outPropertyChange ();
                
    this.propagate ('itemselect',
    {
      index: this._selected_index,
      item: this._selected_item
    });
  },
  
 /**********************************************************************
      General function for the direct access bar within Tab list
  *********************************************************************/

  init_directAccessBar : function ()
  {
    this._direct_access = document.createElement ('div');
    this._direct_access.className = 'direct_access';
    this.view.appendChild (this._direct_access);
    
    this._direct_access_value = document.createElement ('div');
    this._direct_access_value.className = 'direct_access_value';
    this.view.appendChild (this._direct_access_value)

    this._acces_index = 0;
    
    var self = this;
    var bar_dim, bar_pos;
    
    function getIndex (y) {
      if (!bar_dim || !bar_pos) return 0;
      var dy = y - bar_pos.y;
      if (dy < 0) dy = 0;
      else if (dy > bar_dim.height) dy = bar_dim.height - 1;
      
      var nb_elem = self._direct_access.childElementCount;
      return Math.floor (dy * nb_elem / bar_dim.height);
    };
    
    function accessBarStart (e) {
      // do not manage event for other targets
      if (e.targetPointerList.length === 0) { return; }
      
      e.stopPropagation ();
      e.preventDefault ();
      
      util.setElementTransform (self._list_items, '');
      self.__max_scroll = self.size [1] - self._list_items.offsetHeight;
      
      vs.addPointerListener (document, core.POINTER_MOVE, accessBarMove, false);
      vs.addPointerListener (document, core.POINTER_END, accessBarEnd, false);
      
      var _acces_index = e.targetPointerList[0].target._index_;
      if (!util.isNumber (_acces_index)) return;
     
      if (self._acces_index === _acces_index) return;
      self._acces_index = _acces_index;
      
      if (self.__iscroll__) {
        var item = self.getTitleItem (_acces_index);
        self.__iscroll__.scrollToElement (item, 0);
      }
      else {
        var newPos = -self.getTitlePosition (_acces_index);     
        if (newPos < self.__max_scroll) newPos = self.__max_scroll;

        self.__scroll_start = newPos;

        if (SUPPORT_3D_TRANSFORM) {
          util.setElementTransform
            (self._list_items, 'translate3d(0,' + newPos + 'px,0)');
        }
        else {
          util.setElementTransform
            (self._list_items, 'translate(0,' + newPos + 'px)');
        }
      }

      bar_dim = util.getElementDimensions (self._direct_access);
      bar_dim.height -= 10;
      bar_pos = util.getElementAbsolutePosition (self._direct_access);
      bar_pos.y += 5;

      var letter = self.__direct_access_letters [_acces_index];
      self._direct_access_value.style.opacity = 1;
      self._direct_access_value.innerHTML = letter;

      if (self._startScrolling) self._startScrolling ();
    };
    
    this.__access_bar_start = accessBarStart;
    
    var accessBarMove = function (e) {
      e.stopPropagation ();
      e.preventDefault ();
      
      var _acces_index = getIndex (e.pageY);
      if (!util.isNumber (_acces_index)) return;
      
      if (self._acces_index === _acces_index) return;
      self._acces_index = _acces_index;

      if (self.__iscroll__) {
        var item = self.getTitleItem (_acces_index);
        self.__iscroll__.scrollToElement (item, 0);
      }
      else {
        var newPos = -self.getTitlePosition (_acces_index);
        if (newPos < self.__max_scroll) newPos = self.__max_scroll;

        self.__scroll_start = newPos;

        if (SUPPORT_3D_TRANSFORM)
          util.setElementTransform
            (self._list_items, 'translate3d(0,' + newPos + 'px,0)');
        else
          util.setElementTransform
            (self._list_items, 'translate(0,' + newPos + 'px)');
      }
      
      var letter = self.__direct_access_letters [_acces_index];
      self._direct_access_value.innerHTML = letter;
    };
    
    var accessBarEnd = function (e) {
      vs.removePointerListener (document, core.POINTER_MOVE, accessBarMove);
      vs.removePointerListener (document, core.POINTER_END, accessBarEnd);

      self._direct_access_value.style.opacity = 0;
    };

    vs.addPointerListener
      (this._direct_access, core.POINTER_START, accessBarStart, false);
  },
  
  remove_directAccessBar : function ()
  {
    vs.removePointerListener
      (this._direct_access, core.POINTER_START, this.__access_bar_start, false);

    this.view.removeChild (this._direct_access);
    this._direct_access = undefined;
    
    this.view.removeChild (this._direct_access_value)
    this._direct_access_value = undefined;
  },
  
  getTitlePosition : function (index)
  {
    var item = this.getTitleItem (index);
    return (item)?item.offsetTop:0;
  },
  
  getTitleItem : function (index)
  {
    var titleItems = this.view.querySelectorAll ('ul > li > div');
    var item = titleItems.item (index);
    if (!item) return;
    return item.parentElement;
  }
};
util.extendClass (List, AbstractList);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (List, {
  'itemsSelectable': {
    /** 
     * Allow deactivate the list item selection.
     * <p>
     * This is use full to set this property to false, if you do not listen
     * the event 'itemselect'. It will prevent unnecessary inter event 
     * management
     * which uses processing time.
     * By default its set to true
     * @name vs.ui.List#itemsSelectable 
     * @type {boolean}
     */ 
    set : function (v)
    {
      if (v && this._items_selectable) { return; }
      if (!v && !this._items_selectable) { return; }
      
      if (v)
      {
        this._items_selectable = true;
        for (i = 0; i < this.__item_obs.length; i++)
        {
          obj = this.__item_obs [i];
          vs.addPointerListener (obj.view, core.POINTER_START, this, true);
        }
      }
      else
      {
        this._items_selectable = false;
        for (i = 0; i < this.__item_obs.length; i++)
        {
          obj = this.__item_obs [i];
          vs.removePointerListener (obj.view, core.POINTER_START, this, true);
        }
      }
    }
  },
  
  'selectedIndex': {
    /** 
     * Getter for selectedIndex.
     * @name vs.ui.List#selectedIndex 
     * @type {number}
     */ 
    get : function ()
    {
      return this._selected_index;
    }
  },
  
  
  'selectedItem': {
    /** 
     * Getter for selectedItem.
     * @name vs.ui.List#selectedItem 
     * @type {Object}
     */ 
    get : function ()
    {
      return this._selected_item;
    }
  },
  
  'type': {
    /** 
     * This properties allow to change the style of the List
     * Possible values ar :
     * <ul>
     *   <li/> vs.ui.List.BLOCK_LIST
     *   <li/> vs.ui.List.TAB_LIST
     *   <li/> vs.ui.List.DEFAULT_LIST
     * </ul>
     * @name vs.ui.List#type 
     * @type {string}
     */ 
    set : function (v)
    {
      if (!util.isString (v)) { return; }
      if (v !== List.BLOCK_LIST &&
          v !== List.TAB_LIST && 
          v !== List.DEFAULT_LIST) { return; }
      
      this.removeClassName (this._type);
      this._type = v;
      this.addClassName (this._type);
      
      if (this._type === List.BLOCK_LIST)
      {
        this._renderData = blockListRenderData;
        if (this._direct_access)
        {
          this.remove_directAccessBar ();
        }
      }
      if (this._type === List.TAB_LIST)
      {
        this._renderData = tabListRenderData
        if (!this._direct_access) this.init_directAccessBar ();
      }
      if (this._type === List.DEFAULT_LIST)
      {
        this._renderData = defaultListRenderData
        if (this._direct_access)
        {
          this.remove_directAccessBar ();
        }
      }
      
      this._renderData (this._items_selectable);
    }
  },
  
  'hasArrow': {
    /** 
     * Show an arrow for each list item or not
     * @name vs.ui.List#hasArrow 
     *
     * @type boolean
     */ 
    set : function (v)
    {
      if (v)
      {
        this._has_arrow = true;
        this.addClassName ('arrow');
      }
      else
      {
        this._has_arrow = false;
        this.removeClassName ('arrow');
      }
    }
  },
  
  'filters': {
    /** 
     * Getter|Setter for filters. Allow to filter item data.
     * @ex:
     *   list.filters = [
     *     {
     *       property:'title',
     *       value:'o',
     *       matching:vs.ui.List.FILTER_CONTAINS,
     *       strict:true
     *     }];
     *
     * @name vs.ui.List#filters 
     *
     * @type Array
     */ 
    set : function (v)
    {
      if (!util.isArray (v)) { return; }
      this._filters = v;
      
      // TODO   on peut mieux faire : au lieu de faire
      // un init skin qui vire tout et reconstruit tout, on pourrait
      // ne gerer que la difference
      this.applyFilters ();
      this.refresh ();
    },
  
    /**
     * @ignore
     */
    get : function ()
    {
      return this._filters;
    }
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.List = List;
/** @private */
ui.AbstractListItem = AbstractListItem;
/** @private */
ui.DefaultListItem = DefaultListItem;
/** @private */
ui.SimpleListItem = SimpleListItem;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.ui.ComboBox class
 *
 *  @extends vs.ui.View
 *  @class
 *  An implementation of a combo box. The user can select a value from the
 *  drop-down list.
 *
 *  <p>
 *  @example
 *  var config = {}
 *  config.data = ['item1, 'item2', 'item3'];
 *  config.id = vs.core.createId ();
 *
 *  var object = vs.ui.ComboBox (config);
 *  object.init ();
 *
 *  @author David Thevenin
 * @name vs.ui.ComboBox
 *
 *  @constructor
 *   Creates a new vs.ui.ComboBox.
 *
 * @param {Object} config the configuration structure [mandatory]
*/
function ComboBox (config)
{
  this._data = new Array ();
  this._items = {};

  this.parent = View;
  this.parent (config);
  this.constructor = ComboBox;
}

/** @private */
ComboBox.NORMAL_MODE = 1;
ComboBox.NATIVE_MODE = 2;

ComboBox.prototype = {
    
  /**
   * @private
   * @type {Array.<string>}
   */
  _mode: ComboBox.NORMAL_MODE,

  /**
   * @private
   * @type {Array.<string>}
   */
  _data: null,

  /**
   * @private
   * @type {string}
   */
  _selected_item: null,

  /**
   * @private
   * @type {Object.<string, HTMLOptionElement>}
   */
  _items: null,

  /*****************************************************************
   *      Init
   ****************************************************************/
  
  /**
   * @protected
   * @function
   */
  destructor: function ()
  {
    if (this._mode === ComboBox.NATIVE_MODE)
    {
      vs.removePointerListener (this.view, core.POINTER_START, this);
      vs.removePointerListener (this.view, core.POINTER_END, this);
    }
    else
    {
      this.nodeUnbind (this._select, 'change');
      this.nodeUnbind (this._select, 'blur');
    }

    View.prototype.destructor.call (this);
  },

  /**
   * @private
   * @function
   */
  update_gui_combo_box : function ()
  {
    if (!util.isArray (this._data)) { return; }
    
    if (this._mode === ComboBox.NORMAL_MODE)
    {
      util.removeAllElementChild (this._select);
        
      this._items = {};
  
      var i, option;
      
      for (i = 0; i < this._data.length; i++)
      {
        option = document.createElement ('option');
  
        option.appendChild (document.createTextNode (this._data [i]));
        this._items [this._data [i]] = option;
        
        this._select.appendChild (option);
      }
  
      if (this._selected_item)
      {
        this._select.value = this._selected_item;
      }
      else
      {
        this._select.selectedIndex = 0;
      }
    }
    else
    {
      util.setElementInnerText (this._select, this._selected_item);
    }
  },
  
  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    View.prototype.initComponent.call (this);
    
    // PG Native GUI
    if (window.cordova && (
          window.deviceConfiguration.os === DeviceConfiguration.OS_IOS ||
          window.deviceConfiguration.os === DeviceConfiguration.OS_ANDROID)
        && window.plugins.combo_picker)
    {
      this._mode = ComboBox.NATIVE_MODE;

      this._select = document.createElement ('div');
      this.view.appendChild (this._select);

      vs.addPointerListener (this.view, core.POINTER_START, this);
      vs.addPointerListener (this.view, core.POINTER_END, this);
    }
    // Normal GUI
    else
    {
      this._mode = ComboBox.NORMAL_MODE;

      this._select = document.createElement ('select');
      this.view.appendChild (this._select);

      this.nodeBind (this._select, 'change');
      this.nodeBind (this._select, 'blur');
    }

    this.update_gui_combo_box ();
  },
  
  /**
   * @protected
   * @function
   */
  handleEvent : function (e)
  {
    e.preventDefault ();
    e.stopPropagation ();
    if (e.type === core.POINTER_START)
    {
      this.setFocus ();
      window.plugins.combo_picker.show (this, this._data, this._selected_item);
    }
  },
  
  /**
   * Set the focus to your input
   * @name vs.ui.ComboBox#setFocus 
   * @function
   */
  setFocus : function ()
  {
    if (this._mode === ComboBox.NATIVE_MODE)
    {
      this.addClassName ('focus');
    }
    else
    {
      this._select.focus ();
    }
  },
  
  /**
   * Remove the focus to your input
   * @name vs.ui.ComboBox#setBlur 
   * @function
   */
  setBlur : function ()
  {
    if (this._mode === ComboBox.NATIVE_MODE)
    {
      this.removeClassName ('focus');
    }
    else
    {
      this._select.blur ();
    }
  },
  
  /**
   * @protected
   * @function
   */
  notify : function (event)
  {
    if (event.type === 'change')
    {
      this._selected_item = this._select.value;
      this.outPropertyChange ();
      this.propagate ('change', this._selected_item);
    }
    else if (event.type === 'blur')
    {
      window.scrollTo (0, 0);
    }
  }
};
util.extendClass (ComboBox, View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (ComboBox, {
  'selectedItem': {
    /** 
     * Getter|Setter for an item. Allow to select or get one item
     * @name vs.ui.ComboBox#selectedItem 
     *
     * @type {String}
     */ 
    set : function (v)
    {
      if (!util.isString (v)) { return; }
      
      this._selected_item = v;
      
      if (this._mode === ComboBox.NORMAL_MODE)
      {
        if (this._selected_item)
        {
          this._select.value = this._selected_item;
        }
        else
        {
          this._select.selectedIndex = 0;
        }
      }
      else
      {
        util.setElementInnerText (this._select, this._selected_item);
      }
    },
  
    /** 
     * @ignore
     * @type {String}
     */ 
    get : function ()
    {
      return this._selected_item;
    }
  },
  'data': {
    /** 
     * Getter|Setter for data. Allow to get or change the combo box items
     * @name vs.ui.ComboBox#data 
     *
     * @type {Array.<string>}
     */ 
    set : function (v)
    {
      if (!util.isArray (v)) { return; }
  
      this._data = v.slice ();
      
      this.update_gui_combo_box ();
    }
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.ComboBox = ComboBox;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * A vs.ui.RadioButton.
 *  @class
 *  The vs.ui.RadioButton class creates a vertical radio button list which allow
 *  to select one - and just one - option from a set of alternatives.
 *  <p>
 *  If more options are to be allowed at the same time you should use 
 *  vs.ui.CheckBox instead
 *  <p>
 *  Events:
 *  <ul>
 *    <li />change, fired when a item is selected.
 *          Event Data = {index, item}
 *  <ul>
 *  <p>
 *
 *  @author David Thevenin
 *
 *  @extends vs.ui.AbstractList
 *  @constructor
 *   Creates a new vs.ui.RadioButton.
 *
 * @name vs.ui.RadioButton
 *  @example
 *  var config = {}
 *  config.data = ['item1, 'item2', 'item3'];
 *  config.id = vs.core.createId ();
 *
 *  var object = vs.ui.RadioButton (config);
 *  object.init ();
 */
function RadioButton (config)
{
  this.__inputs = [];
  this.__labels = [];

  this.parent = AbstractList;
  this.parent (config);
  this.constructor = RadioButton;
}

RadioButton.prototype = {

  /**
   * @private
   * @type {int}
   */
  _selected_index: -1,

  /**
   * @private
   * @type {Array.<HTMLInputElement>}
   */
  __inputs: null,
  
  /**
   * @private
   * @type {Array.<HTMLabelElement>}
   */
  __labels: null,
  
  /*****************************************************************
   *
   ****************************************************************/
      
  /**
   * @protected
   * @function
   */
  clean_gui : function ()
  {
    var input;
    
    this.__scroll_start = 0;
  
    // removes all items;
    util.removeAllElementChild (this._list_items);
  
    while (this.__inputs.length)
    {
      input = this.__inputs [0];
      
      vs.removePointerListener (input, core.POINTER_START, this);
      input.removeEventListener ('click', this);
      this.__inputs.remove (0);
      this.__labels.remove (0);
    }
  },

  /**
   * @protected
   * @function
   */
  _renderData : function ()
  {
    if (!this._model) { return; }
    
    var i, input, item, l, label;
    
    if (!this._list_items)
    {
      console.error ('vs.ui.RadioButton uncorrectly initialized.');
      return;
    }

    this.clean_gui ();
    this._selected_index = -1;
    var os_device = window.deviceConfiguration.os;
    
    for (i = 0, l = this._model.length; i < l; i++)
    {
      item = this._model.item (i);
      input = document.createElement ('input');
      input.type = 'radio';
      input.name = this._id;
      input.value = i;
      input.id = this._id + "_l" + i;
      
      this._list_items.appendChild (input);
      this.__inputs [i] = input;
      vs.addPointerListener (input, core.POINTER_START, this);
      input.addEventListener ('click', this);
      
      label = document.createElement ('label');
      label.value = i;
      label.setAttribute ("for", this._id + "_l" + i);
      vs.addPointerListener (label, core.POINTER_START, this);
      label.addEventListener ('click', this);
      util.setElementInnerText (label, item);
      this._list_items.appendChild (label);
      this.__labels [i] = label;
    }
    this.refresh ();
  },
  
  /**
   * @protected
   * @function
   */
  _touchItemFeedback : function (item)
  {
    var
      index = item.value,
      label = this.__inputs [index],
      input = this.__labels [index];
    
    util.addClassName (label, 'pressed');
    util.addClassName (input, 'pressed');
  },
  
  /**
   * @private
   * @function
   */
  _untouchItemFeedback : function (item)
  {
    var
      index = item.value,
      label = this.__inputs [index],
      input = this.__labels [index];
    
    util.removeClassName (label, 'pressed');
    util.removeClassName (input, 'pressed');
  },
      
  /**
   * @protected
   * @function
   */
  _updateSelectItem : function (item)
  {
    var index = parseInt (item.value);
    if (item._comp_ && item._comp_.didSelect) item._comp_.didSelect ();
    
    if (index >= 0 || index < this.__inputs.length) 
    {
      this.selectedIndex = index;
      this.outPropertyChange ();
      this.propagate ('change',
      {
        index: this._selected_index,
        item: this._model.item (this._selected_index)
      });
    }
  }
};
util.extendClass (RadioButton, AbstractList);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperty (RadioButton, "selectedIndex", {
  /** 
   * Set the vs.ui.RadioButton selectedIndex
   *
   * @name vs.ui.RadioButton#selectedIndex 
   * @type {int}
   */ 
  set : function (v)
  {
    if (!util.isNumber (v))
    {
      v = parseInt (v);
    }
    
    if (isNaN (v)) { return; }
    if (v < 0 || v > this.__inputs.length - 1) { return; }

    if (this.__inputs [v])
    {
      var item = this.__inputs [v];
      if (item)
      {
        item.checked = true;
      }
      this._selected_index = v;
    }
  },

  /** 
   * Get the vs.ui.RadioButton selectedIndex
   * @ignore
   * @type {int}
   */ 
  get : function ()
  {
    return this._selected_index;
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.RadioButton = RadioButton;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  A vs.ui.CheckBox.
 *  @class
 *  The vs.ui.CheckBox class creates a vertical checkbox list which allow to 
 *  select one or more options from a set of alternatives.
 *  <p>
 *  If only one option is to be selected at a time you should use vs.ui.RadioButton
 *  instead
 *  <p>
 *  Events:
 *  <ul>
 *    <li />change, fired when a item is selected.
 *          Event Data = index
 *  <ul>
 *  <p>
 *
 *  @author David Thevenin
 * @name vs.ui.CheckBox
 *
 *  @extends vs.ui.AbstractList
 *  @constructor
 *   Creates a new vs.ui.CheckBox.
 *
 *  @example
 *  var config = {}
 *  config.data = ['item1, 'item2', 'item3'];
 *  config.id = vs.core.createId ();
 *
 *  var object = vs.ui.CheckBox (config);
 *  object.init ();
 *
 * @param {Object} config the configuration structure [mandatory]
 */
function CheckBox (config)
{
  this.__inputs = [];
  this.__labels = [];

  this.parent = AbstractList;
  this.parent (config);
  this.constructor = CheckBox;
  
  this._selected_indexes = new Array ();
}

CheckBox.prototype = {

  /**
   * @private
   * @type Array.<int>
   */
  _selected_indexes: null,

  /**
   * @private
   * @type {Array.<HTMLImputElement>}
   */
  __inputs: null,

  /**
   * @private
   * @type {Array.<HTMLLabelElement>}
   */
  __labels: null,

  /*****************************************************************
   *
   ****************************************************************/
   
  /**
   * This method select on unselect a item
   *
   * @name vs.ui.CheckBox#selectItem
   * @function
   * @param {int} index the item index to select/unselect
   */
  selectItem : function (index)
  {
    if (!util.isNumber (index)) { return; }
    if (index < 0 || index >= this.__inputs.length) { return; }
    
    var item = this.__inputs [index];
    if (!item) { return; }
    
    for (var i = 0; i < this._selected_indexes.length; i++)
    {
      if (this._selected_indexes [i] === index)
      {
        this._selected_indexes.remove (i);
        item.checked = false;
        return;
      }
    }
    
    // the item is not selected. Selected it.
    this._selected_indexes.push (index);
    item.checked = true;
  },
    
  /*****************************************************************
   *
   ****************************************************************/
    
  /**
   * @protected
   * @function
   */
  clean_gui : function ()
  {
    var input;
    
    this.__scroll_start = 0;
  
    // removes all items;
    util.removeAllElementChild (this._list_items);
  
    while (this.__inputs.length)
    {
      input = this.__inputs [0];
      
      vs.removePointerListener (input, core.POINTER_START, this);
      input.removeEventListener ('click', this);
      this.__inputs.remove (0);
      this.__labels.remove (0);
    }
  },
  
  /**
   * @protected
   * @function
   */
  _renderData : function ()
  {
    if (!this._model) { return; }
    
    var i, l, div, title, button, item, label, input;
    if (!this._list_items)
    {
      console.error ('vs.ui.CheckBox uncorrectly initialized.');
      return;
    }
   
    this._selected_indexes = [];
    this.clean_gui ();
    var os_device = window.deviceConfiguration.os;
    
    for (i = 0, l = this._model.length; i < l; i++)
    {
      item = this._model.item (i);
      input = document.createElement ('input');
      input.type = 'checkbox';
      input.name = this._id;
      input.id = this._id + "_l" + i;
      input.value = i;

      this._list_items.appendChild (input);
      this.__inputs [i] = input;
      
      vs.addPointerListener (input, core.POINTER_START, this);
      input.addEventListener ('click', this);

      label = document.createElement ('label');
      label.value = i;
      label.setAttribute ("for", this._id + "_l" + i);
      vs.addPointerListener (label, core.POINTER_START, this);
      label.addEventListener ('click', this);
      util.setElementInnerText (label, item);
      this._list_items.appendChild (label);
      this.__labels [i] = label;
    }
    
    // select items
    this.selectedItem = this._selected_indexes;
  },
  
  /**
   * @protected
   * @function
   */
  _touchItemFeedback : function (item)
  {
    var
      index = item.value,
      label = this.__inputs [index],
      input = this.__labels [index];
    
    util.addClassName (label, 'pressed');
    util.addClassName (input, 'pressed');
  },
  
  /**
  * @private
  */
  _untouchItemFeedback : function (item)
  {
    var
      index = item.value,
      label = this.__inputs [index],
      input = this.__labels [index];
    
    util.removeClassName (label, 'pressed');
    util.removeClassName (input, 'pressed');
  },
      
  /**
   * @protected
   * @function
   */
  _updateSelectItem : function (item)
  {
    var index = parseInt (item.value);
    if (item._comp_ && item._comp_.didSelect) item._comp_.didSelect ();
    
    if (index >= 0 || index < this.__inputs.length) 
    {
      this.selectItem (index);
      this.outPropertyChange ();
      
      items = new Array ();
      for (i = 0, l = this._selected_indexes.length; i < l; i ++)
      {
        items.push (this._model.item (this._selected_indexes [i]));
      }
      
      this.propagate ('change',
      {
        indexes: this._selected_indexes.slice (),
        items: items
      });
    }
  }
};
util.extendClass (CheckBox, AbstractList);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperty (CheckBox, "selectedIndexes", {
  /** 
   * Getter|Setter for items. Allow to select or get one or more items
   * @name vs.ui.CheckBox#selectedIndexes
   *
   * @type {Array.<int>}
   */ 
  set : function (v)
  {
    if (!util.isArray (v)) { return; }
    
    var index, len, i, item;
    
    this._selected_indexes = [];
    for (i = 0; i < v.length; i++)
    {
      index = v [i];
      if (!util.isNumber (index)) { continue; }
      
      this._selected_indexes.push (index);
    }
    
    for (i = 0; i < this.__inputs.length; i ++)
    {
      var item = this.__inputs [i];
      if (item)
      {
        item.checked = false;
      }
    }
    
    len = this._selected_indexes.length;
    for (i = 0; i < len; i++)
    {
      var item = this.__inputs [this._selected_indexes[i]];
      if (item)
      {
        item.checked = true;
      }
    }
  },
  
  /**
   * @ignore
   * @type {Array.<int>}
   */
  get : function ()
  {
    return this._selected_indexes.slice ();
  }
});
/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.CheckBox = CheckBox;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.ui.NavivationBar class implements a view for controlling navigation
 *  on content views.
 *
 *  @extends vs.ui.View
 *  @class
 *  This bar is displayed at the top of the parent view,
 *  Typically it includes navigation buttons, or a title.
 *  But it can contains any custom widgets.
 *  <p>
 *
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.ui.NavigationBar.
 * @name vs.ui.NavigationBar
 *
 * @param {Object} config the configuration structure [mandatory]
 */
function NavigationBar (config)
{
  this.parent = View;
  this.parent (config);
  this.constructor = NavigationBar;
  
  this._states = {};
}

/**
 * Blue style tab bar (defaut)
 * @name vs.ui.NavigationBar.DEFAULT_STYLE
 * @const
 */
NavigationBar.DEFAULT_STYLE = 'blue_style';

/**
 * Black translucide style tab bar
 * @name vs.ui.NavigationBar.BLACK_TRANSLUCIDE_STYLE
 * @const
 */
NavigationBar.BLACK_TRANSLUCIDE_STYLE = 'black_translucide_style';

/**
 * Black style tab bar
 * @name vs.ui.NavigationBar.BLACK_STYLE
 * @const
 */
NavigationBar.BLACK_STYLE = 'black_style';

NavigationBar.prototype = {
  
/********************************************************************
                  protected members declarations
********************************************************************/

  /**
   *  @protected
   *  @const
   *  @type vs.fx.Animation
   */
  _hide_animation: null,
  
  /**
   *  @protected
   *  @const
   *  @type vs.fx.Animation
   */
  _show_animation: null,

  /**
   *
   * @protected
   * @type {number}
   */
  _style: NavigationBar.DEFAULT_STYLE,

  /**
   * States configuration.
   * For a given state name, give the list of visible widgets in the navigation
   * bar.
   *
   * @protected
   * @type {Object}
   */
  _states : null,

  /**
   * The current state name.
   * @protected
   * @type {string}
   */
  _current_state : null,
  
/********************************************************************
                general initialisation declarations
********************************************************************/
  
  /**
   * @protected
   * @function
   */
  destructor: function ()
  {
    View.prototype.destructor.call (this);
  },
    
  /**
   * @protected
   * @function
   */
  initComponent: function ()
  {
    View.prototype.initComponent.call (this);

    var os_device = window.deviceConfiguration.os;
    if (os_device == DeviceConfiguration.OS_SYMBIAN)
    {
      this._hide_animation = new vs.fx.Animation (['translateY', '-50px']);
    }
    else
    {
      this._hide_animation = new vs.fx.Animation (['translateY', '-44px']);
    }
    this._show_animation = new vs.fx.Animation (['translateY', '0px']);

    this.style = this._style;
  },
  
/********************************************************************
                    States definitions
********************************************************************/
  
  /**
   *  Set a list of visible widgets per a state name.
   *
   *  Widgets view will be automatically added to the navigation bar view
   *  if its need.
   *
   * @name vs.ui.NavigationBar#setStateItems
   * @function
   *
   * @param {String} state The state name  
   * @param {Array} items The list of widget (pointers on widget)  
   */
  setStateItems : function (state, items)
  {
    var i;
    
    if (!state || !util.isString (state)) { return; }
    if (!items || !util.isArray (items)) { return; }
    
    this._states [state] = items.slice ();
    
    if (this._current_state === state)
    {
      // hide all children except those have to be shown
      for (key in this.__children)
      {
        children = this.__children [key];
        if (util.isArray (children))
        {
          for (i = 0; i < children.length; i++)
          {
            obj = children [i];
            if (items.findItem (obj) >= 0) { continue; }
            
            if (obj && obj.hide) { obj.hide (); }
          }
        }
        else
        { if (children.hide) { children.hide (); } }
      }
  
      for (i = 0; i < items.length; i++)
      {
        obj = items [i];
        if (!this.isChild (obj))
        {
          this.add (obj, 'children');
        }
        obj.show ();
      }
    }
    else
    {
      for (i = 0; i < items.length; i++)
      {
        obj = items [i];
        if (!this.isChild (obj))
        {
          this.add (obj, 'children');
        }
      }
    }
  },
  
  /**
   *  Return the list of visible widgets for a state name.
   *  Return undefined if the state is undefined.
   *
   * @name vs.ui.NavigationBar#getStateItems
   * @function
   *
   * @param {String} state The state name  
   * @return {Array} items The list of widget (pointers on widget)  
   */
  getStateItems : function (state, items)
  {
    if (!state || !util.isString (state)) { return undefined; }
    
    if (this._states [state])
    {
      return this._states [state].slice ();
    }
    else
    {
      return undefined;
    }
  },
  
  /**
   *  Apply a state to the Navigatio Bar.
   *  Only widgets associated to the state will be showed.
   *
   * @name vs.ui.NavigationBar#changeState
   * @function
   *
   * @param {String} state The state name  
   * @param {Object} conf Optional configuration parameters 
   *     Structure have to follow : {comp_id: {prop: value}}
   */
  changeState : function (state, conf)
  {
    if (!state) { return; }
    var i = 0, length, children, objs_to_show, obj, key, data;
    
    this._current_state = state;
    objs_to_show = this._states [this._current_state];
    if (!objs_to_show)
    { objs_to_show = []; }
    length = objs_to_show.length;
    
    // hide all children except those have to be shown
    for (key in this.__children)
    {
      children = this.__children [key];
      if (util.isArray (children))
      {
        for (i = 0; i < children.length; i++)
        {
          obj = children [i];
          if (objs_to_show.findItem (obj) >= 0) { continue; }
          
          if (obj && obj.hide) { obj.hide (); }
        }
      }
      else
      { if (children.hide) { children.hide (); } }
    }
    
    // show all children associate to this state and configure them if needs
    for (i = 0; i < length; i++)
    {
      obj = objs_to_show [i];
      if (conf && conf [obj.id])
      {
        data = conf [obj.id];
        for (key in data)
        {
          if (key)
          {
            obj [key] = data [key];
          }
        }
      }
      if (obj) { obj.show (); }
    }
  },

/********************************************************************
                  events management
********************************************************************/

  /**
   * @protected
   * @function
   */
  handleEvent : function (event)
  {
    var self = event.currentTarget;
    
    switch (event.type)
    {
      case core.POINTER_START:
        util.addClassName (self, 'active');
        vs.addPointerListener (event.currentTarget, core.POINTER_END, this, true);
        vs.addPointerListener (event.currentTarget, core.POINTER_MOVE, this, true);
      break;

      case core.POINTER_END:
        vs.removePointerListener (event.currentTarget, core.POINTER_END, this);
        vs.removePointerListener (event.currentTarget, core.POINTER_MOVE, this);        
        
        setTimeout (function () 
          { util.removeClassName (self, 'active'); }, 200);
        this.propagate ('buttonselect', event.currentTarget.spec);
      break;

      case core.POINTER_MOVE:
        event.preventDefault ();
        setTimeout (function () 
          { util.removeClassName (self, 'active'); }, 200);
        vs.removePointerListener (event.currentTarget, core.POINTER_END, this);
        vs.removePointerListener (event.currentTarget, core.POINTER_MOVE, this);
      break;
    }
  },
  
/********************************************************************
                  add / remove buttons
********************************************************************/

  /**
   *  Remove the specified child component from this component.
   * 
   *  @example
   *  myObject.remove (myButton);
   *
   * @name vs.ui.NavigationBar#remove
   * @function
   *
   * @param {vs.ui.EventSource} child The component to be removed.
   */
  remove : function (child)
  {
    var state, items;
    
    View.prototype.remove.call (this, child);
    
    for (state in this._states)
    {
      items = this._states [state];
      if (items.indexOf (child) !== -1)
      {
        items.remove (child);
      }
    }
  }
};
util.extendClass (NavigationBar, View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (NavigationBar, {
  'style': {
    /** 
     * Getter|Setter for the tab bar style
     * @name vs.ui.NavigationBar#style 
     * @type String
     */ 
    set : function (v)
    {
      if (!util.isString (v)) { return; }
      if (this._style)
      {
        this.removeClassName (this._style);
      }
      this._style = v;
      this.addClassName (this._style);
    },
  
    /** 
     * @ignore
     * @return {String}
     */ 
    get : function ()
    {
      return this._style;
    }
  },
  
  'position': {
    /**
     * @ignore
     * @private
     */
    set : function (v) {},
    
    /**
     * @ignore
     * @private
     */
    get : function ()
    {
      return [this.view.offsetLeft, this.view.offsetTop];
    }
  },
  
  'size': {
    /**
     * @ignore
     * @private
     */
    set : function (v) {},
  
    /**
     * @ignore
     * @private
     */
    get : function ()
    {
      return [this.view.offsetWidth, this.view.offsetHeight];
    }
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.NavigationBar = NavigationBar;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/


/**
 *  The vs.ui.ToolBar class
 *
 *  @extends vs.ui.View
 *  @class
 *  The vs.ui.ToolBar class implements a control for selecting buttons.
 *  The vs.ui.ToolBar class provides the ability for the user to customize the tab bar
 *  by reordering, removing, and adding items to the bar.
 *  <p>
 *  When a tabbar button is selected the tabbar send an event named
 *  'itemselect'.
 *  The event data contains the id of the selected button.
 *
 *  @example
 *  // Simple example: (the button will have the platform skin)
 *  var bar = vs.ui.ToolBar ({id: "bar"}).init ();
 *
 *  bar.addButton (
 *    "right", 
 *    vs.ui.ToolBar.BUTTON_ARROW_RIGHT,
 *    "Right panel");
 *
 *  bar.addButton ("attach", vs.ui.ToolBar.BUTTON_ATTACH);
 *
 *  bar.addButton (
 *    "left",
 *    vs.ui.ToolBar.BUTTON_ARROW_LEFT,
 *    "Left panel");
 *
 *  bar.bind ("itemselect", this);
 *
 *  @author David Thevenin
 *
 * @name vs.ui.ToolBar
 *
 *  @constructor
 *   Creates a new vs.ui.ToolBar.
 *
 * @param {Object} config the configuration structure [mandatory]
*/
function ToolBar (config)
{
  this.parent = View;
  this.parent (config);
  this.constructor = ToolBar;
  
  this._items = {};
}

/**
 * Black style tab bar (defaut)
 * @name vs.ui.ToolBar.DEFAULT_STYLE
 * @const
 */
ToolBar.DEFAULT_STYLE = 'black_style';

/**
 * Black translucide style tab bar
 * @name vs.ui.ToolBar.BLACK_TRANSLUCIDE_STYLE
 * @const
 */
ToolBar.BLACK_TRANSLUCIDE_STYLE = 'black_translucide_style';

/**
 * Blue style tab bar
 * @name vs.ui.ToolBar.BLUE_STYLE
 * @const
 */
ToolBar.BLUE_STYLE = 'blue_style';

ToolBar.prototype = {
  
/********************************************************************
                  protected members declarations
********************************************************************/

  /**
   *  @protected
   *  @const
   *  @type vs.fx.Animation
   */
  _hide_animation: null,
  
  /**
   *  @protected
   *  @const
   *  @type vs.fx.Animation
   */
  _show_animation: null,
  
  /**
   *
   * @protected
   * @type {number}
   */
  _style: ToolBar.DEFAULT_STYLE,

  /**
   * The configuration of the tab bar (list of button, type)
   * @private
   * @type {Array.<Array>}
   */
  _configuration: [],

  /**
   * The reference array on tabbar's items
   * @private
   * @type {object.<string>}
   */
  _items: null,
  
  /**
   *
   * @protected
   * @type {number}
   */
  _is_toggle_buttons: true,

  /**
   *
   * @private
   * @type {View}
   */
  __select_item: null,
  __active_item: null,

/********************************************************************
                general initialisation declarations
********************************************************************/
    
  /**
   * @protected
   * @function
   */
  destructor: function ()
  {
    util.free (this._show_animation);
    util.free (this._hide_animation);

    this.removePointerRecognizer (this.recognizer);
    util.free (this.recognizer);

    View.prototype.destructor.call (this);
  },

  /**
   * @protected
   * @function
   */
  initComponent: function ()
  {
    View.prototype.initComponent.call (this);

    this._hide_animation = new vs.fx.Animation (['translateY', '44px']);
    this._show_animation = new vs.fx.Animation (['translateY', '0px']);

    this.style = this._style;

    this.recognizer = new TapRecognizer (this);
    this.addPointerRecognizer (this.recognizer);
  },
  
/********************************************************************
                  events management
********************************************************************/

  didTouch : function (comp, elem, e) {
    var item = e.target._comp_;
    if (!item) return;
    
    if (item === this.__select_item) return;
    
    this.__active_item = item;
    this.__active_item.addClassName ("active");
  },
  
  didUntouch : function (comp, elem, e) {
    if (!this.__active_item) return;
    
    this.__active_item.removeClassName ("active");
    this.__active_item = null;
  },
  
  didTap : function (nb_tap, comp, elem, e) {
    var item = e.target._comp_;
    if (!item) return;
    
    this.selectedId = item.id;
    this.outPropertyChange ();
  },
  
/********************************************************************
                  add / remove buttons
********************************************************************/

  /**
   *  Add a button to the ToolBar
   *
   * @name vs.ui.ToolBar#addButton
   * @function
   *
   * @param {string} id An unique identifier for the button. This id will be
   *                 send as event data if the button is pressed.
   * @param {string} name The identifier of the button to add.
   * @param {string} label An optional text to put under the button
   * @return {vs.ui.ToolBar.Button}
   */
  addButton : function (id, name, label)
  {
    if (this._items [id]) { return; }
    
    var button = new ToolBar.Button ({id: id});
    button.init ();
    if (label) { button.label = label; }
    button.name = name;
    
    this.add (button, 'children')
    
    this._items [id] = button;
    return button;
  },
  
  /**
   *  Add a generic vs.ui.ToolBar item to the ToolBar
   *
   * @name vs.ui.ToolBar#addItem
   * @function
   *
   * @param {vs.ui.ToolBar.item} obj the item to add.
   */
  addItem : function (item)
  {
    if (!item || this._items [item.id]) { return; }
    
    this.add (item, 'children')
    
    this._items [item.id] = item;
  },

  /**
   *  Remove an item from the ToolBar
   *
   * @name vs.ui.ToolBar#removeItem
   * @function
   *
   * @param {string} id the identifier for the item to remove.
   */
  removeItem : function (id)
  {
    var item = this._items [id];
    if (!item) { return; }
    
    try { this.remove (item); } catch (e) {if (e.stack) console.log (e.stack);}
    
    delete (this._items [id]);
  }
};
util.extendClass (ToolBar, View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (ToolBar, {
  'style': {
    /** 
     * Getter|Setter for the tab bar style
     * @name vs.ui.ToolBar#style 
     * @type String
     */ 
    set : function (v)
    {
      if (!util.isString (v)) { return; }
      if (this._style)
      {
        this.removeClassName (this._style);
      }
      this._style = v;
      this.addClassName (this._style);
    },
  
    /** 
     * @ignore
     * @return {String}
     */ 
    get : function ()
    {
      return this._style;
    }
  }, 
  'configuration': {
    /**
     * Set a vs.ui.ToolBar configuration
     * <p>
     * A configuration is an array of button specification.<br/>
     * Q button specification is a array of 2 or 3 values:
     * <ol>
     *   <li>The button id (a String)
     *   <li>The button type (a String).
     *       <br/>Ex: vs.ui.ToolBar.BUTTON_BLOG, vs.ui.ToolBar.BUTTON_ARROW_RIGHT
     *   <li> A optional label.
     * </ol>   
     * @name vs.ui.ToolBar#configuration 
     *
     * @type {Array.<Array>}
     */
    set : function (v)
    {
      if (!util.isArray (v)) { return; }
      
      var id, i, spec;
      
      this._configuration = v;
      
      // 1) remove all previous buttons
      for (id in this._items)
      {
        this.removeItem (id);
      }    
  
      // 2) add new buttons
      for (i = 0; i < v.length; i++)
      {
        spec = v [i];
        this.addButton (spec[0], spec[1], spec[2]);
      }    
    }
  },
  'isToggleButtons': {
    /** 
     * Getter|Setter to configure the buttons as toggle buttons or not.
     * By default ToolBar are toggle buttons
     * @name vs.ui.ToolBar#isToggleButtons 
     * @type {boolean}
     */ 
    set : function (v)
    {
      if (v) this._is_toggle_buttons = true;
      else this._is_toggle_buttons = false;
    },
  
    /** 
     * @ignore
     * @return {string}
     */ 
    get : function ()
    {
      return this._is_toggle_buttons;
    }
  },
  'selectedId': {
    /** 
     * Getter|Setter for select one of button
     * @name vs.ui.ToolBar#selectedId 
     * @type number
     */ 
    set : function (v)
    {
      var
        item = this._items [v],
        self = this;
        
      if (!item) return;
      
      if (this.__select_item === item) return;

      if (this.__remove_time_out) {
        clearTimeout (this.__remove_time_out);
        this.__remove_time_out = 0;
      }
      if (this.__select_item) {
        this.__select_item.removeClassName ("select");
      }
      this.__select_item = item;
      item.addClassName ("select");
      
      if (!this._is_toggle_buttons)
      {
        this.__remove_time_out = setTimeout (function () {
            self.__select_item.removeClassName ("select");
            self.__select_item = null;
            self.__remove_time_out = 0;
          },View.UNSELECT_DELAY
        );
      }
     
      this.propagate ("itemselect", v);
      
      this._selected_id = v;
    },
  
    /** 
     * @ignore
     * @return {number}
     */ 
    get : function ()
    {
      return this._selected_id;
    }
  }
});

/**
 *  The vs.ui.ToolBar.Text class
 *
 *  @extends vs.ui.View
 *  @class
 *  The vs.ui.ToolBar.Text class implements a text control for the vs.ui.ToolBar.
 *  It provides the ability for the user to customize the tab bar with the
 *  you own text which is selectable.
 *
 *  @example
 *  // Simple example: (the button will have the platform skin)
 *  var config = {}
 *  var config.id = 'bar';
 *
 *  var bar = vs.ui.ToolBar (config);
 *  bar.init ();
 *
 *  var label = vs.ui.ToolBar.Text ({id:"info"});
 *  label.init ();
 *  label.text = "Information";
 *  bar.addItem (label);
 *
 *
 *  bar.bind ('itemselect', this);
 *
 *  @author David Thevenin
 *
 * @name vs.ui.ToolBar.Text 
 *
 *  @constructor
 *   Creates a new vs.ui.ToolBar.Text.
 *
 * @param {Object} config the configuration structure [mandatory]
*/
ToolBar.Text = function (config)
{
  this.parent = View;
  this.parent (config);
  this.constructor = ToolBar.Text;
}

ToolBar.Text.prototype = {
  
  /*****************************************************************
   *               private/protected members
   ****************************************************************/

  /**
   *
   * @private
   * @type {String}
   */
  _text: "",
  
  /*****************************************************************
  *               init methods
  ****************************************************************/

  /**
   * Object default init. <p>
   * Must be call after the new.
   * @ignore
   * @name vs.ui.ToolBar.Text#initComponent
   */
  initComponent : function ()
  {
    if (!this.__config__) { this.__config__ = {}; }
    this.__config__.id = this.id;
    if (!this.__config__.node)
    {
      this.__config__.node = document.createElement ('div');
      this.__config__.node.className = 'vs_ui_toolbar_text';
    }

    View.prototype.initComponent.call (this);

    this._text_view = document.createElement ('div');
    this._text_view.className = "text_view";
    this.view.appendChild (this._text_view);
  }
};
util.extendClass (ToolBar.Text, View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperty (ToolBar.Text, "text", {

  /** 
   * The text of the item
   * @name vs.ui.ToolBar.Text#text 
   * @type String
   */ 
  set : function (v)
  {
    if (v === null || typeof (v) === "undefined") { v = ''; }
    else if (util.isNumber (v)) { v = '' + v; }
    else if (!util.isString (v))
    {
      if (!v.toString) { return; }
      v = v.toString ();
    }
    
    this._text = v;
    if (this._text_view)
    {
      util.setElementInnerText (this._text_view, this._text);
    }
  },

  /** 
   * @ignore
   * @return {string}
   */ 
  get : function ()
  {
    return this._text;
  }
});

/**
 *  The vs.ui.ToolBar.Button class
 *
 *  @extends vs.ui.View
 *  @class
 *  The vs.ui.ToolBar.Button class implements a button control for the vs.ui.ToolBar.
 *  It provides the ability for the user to customize the tab bar with the
 *  you own button image.
 *
 *  @example
 *  // Simple example: (the button will have the platform skin)
 *  var config = {}
 *  var config.id = 'bar';
 *
 *  var bar = vs.ui.ToolBar (config);
 *  bar.init ();
 *
 *  var button = vs.ui.ToolBar.Button ({id:"back"});
 *  button.init ();
 *  button.setImage ("resources/images/back_icon.png);
 *  bar.addItem (button);
 *
 *
 *  bar.bind ('itemselect', this);
 *
 *  @author David Thevenin
 *
 * @name vs.ui.ToolBar.Button
 *
 *  @constructor
 *   Creates a new vs.ui.ToolBar.Button.
 *
 * @param {Object} config the configuration structure [mandatory]
*/
ToolBar.Button = function (config)
{
  this.parent = View;
  this.parent (config);
  this.constructor = ToolBar.Button;
}

ToolBar.Button.prototype = {
  
  /*****************************************************************
   *               private/protected members
   ****************************************************************/

  /**
   *
   * @protected
   * @type {String}
   */
  _name: "",
  
  /**
   *
   * @protected
   * @type {String}
   */
  _label: "",
  
  /*****************************************************************
   *               General methods
   ****************************************************************/
   
  /**
   * Object default init. <p>
   * Must be call after the new.
   * @ignore
   * @function
   * @name vs.ui.ToolBar.Text#initComponent
   */
  initComponent : function ()
  {
    if (!this.__config__) { this.__config__ = {}; }
    this.__config__.id = this.id;
    if (!this.__config__.node)
    {
      this.__config__.node = document.createElement ('div');
      this.__config__.node.className = 'vs_ui_toolbar_button';
    }

    View.prototype.initComponent.call (this);
  },
  
  /**
   * Allows to set a background image for the ToolBar button
   *
   * @name vs.ui.ToolBar.Button#setImage
   * @function
   *
   * @param {String} button image path
   */
  setImage : function (path)
  {
    this.view.style.backgroundImage = 'url(' + path + ')';
  }
};
util.extendClass (ToolBar.Button, View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (ToolBar.Button, {
  "name": {
    /** 
     * The name of the button from the list (vs.ui.ToolBar.BUTTON_ADD,...)
     * If you want use you own button with your own image, you can set it
     * using "setImage" method.
     *
     * @name vs.ui.ToolBar.Button#name 
     *
     * @type String
     */ 
    set : function (v)
    {
      if (!util.isString (v)) { return; }

      this._name = v;
      this.addClassName (this._name);
    },

    /** 
     * @ignore
     * @return {string}
     */ 
    get : function ()
    {
      return this._name;
    }
  },

  "label": {
    /** 
     * @name vs.ui.ToolBar.Button#label 
     *
     * @type String
     */ 
    set : function (v)
    {
      if (!util.isString (v)) { return; }

      this._label = v;
      
      util.setElementInnerText (this.view, v);
      if (v) {
        this.setStyle ("background-position", "center 0px");
      }
      else {
        this.setStyle ("background-position", "center");
      }
    },

    /** 
     * @ignore
     * @return {string}
     */ 
    get : function ()
    {
      return this._label;
    }
  }
});


/** @name vs.ui.ToolBar.BUTTON_ADD */
ToolBar.BUTTON_ADD = 'add';
/** @name vs.ui.ToolBar.BUTTON_ARROW_DOWN */
ToolBar.BUTTON_ARROW_DOWN = 'arrow_down';
/** @name vs.ui.ToolBar.BUTTON_ARROW_LEFT */
ToolBar.BUTTON_ARROW_LEFT = 'arrow_left';
/** @name vs.ui.ToolBar.BUTTON_ARROW_RIGHT */
ToolBar.BUTTON_ARROW_RIGHT = 'arrow_right';
/** @name vs.ui.ToolBar.BUTTON_ARROW_UP */
ToolBar.BUTTON_ARROW_UP = 'arrow_up';
/** @name vs.ui.ToolBar.BUTTON_ATTACH */
ToolBar.BUTTON_ATTACH = 'attach';
/** @name vs.ui.ToolBar.BUTTON_AUCTION */
ToolBar.BUTTON_AUCTION = 'auction';
/** @name vs.ui.ToolBar.BUTTON_BELL_OFF */
ToolBar.BUTTON_BELL_OFF = 'bell_off';
/** @name vs.ui.ToolBar.BUTTON_BELL */
ToolBar.BUTTON_BELL = 'bell';
/** @name vs.ui.ToolBar.BUTTON_BLOG */
ToolBar.BUTTON_BLOG = 'blog';
/** @name vs.ui.ToolBar.BUTTON_BOOK_MARKED */
ToolBar.BUTTON_BOOK_MARKED = 'book_marked';
/** @name vs.ui.ToolBar.BUTTON_BOOK */
ToolBar.BUTTON_BOOK = 'book';
/** @name vs.ui.ToolBar.BUTTON_BOOKMARK_ADD */
ToolBar.BUTTON_BOOKMARK_ADD = 'bookmark_add';
/** @name vs.ui.ToolBar.BUTTON_BOORMARK */
ToolBar.BUTTON_BOORMARK = 'bookmark';
/** @name vs.ui.ToolBar.BUTTON_BOX_FULL */
ToolBar.BUTTON_BOX_FULL = 'box_full';
/** @name vs.ui.ToolBar.BUTTON_BOX_MAIL */
ToolBar.BUTTON_BOX_MAIL = 'box_mail';
/** @name vs.ui.ToolBar.BUTTON_BOX */
ToolBar.BUTTON_BOX = 'box';
/** @name vs.ui.ToolBar.BUTTON_BRIGHTNESS */
ToolBar.BUTTON_BRIGHTNESS = 'brightness';
/** @name vs.ui.ToolBar.BUTTON_BRUSH */
ToolBar.BUTTON_BRUSH = 'brush';
/** @name vs.ui.ToolBar.BUTTON_BULB_OFF */
ToolBar.BUTTON_BULB_OFF = 'bulb_off';
/** @name vs.ui.ToolBar.BUTTON_BULB_ON */
ToolBar.BUTTON_BULB_ON = 'bulb_on';
/** @name vs.ui.ToolBar.BUTTON_BUZZER */
ToolBar.BUTTON_BUZZER = 'buzzer';
/** @name vs.ui.ToolBar.BUTTON_CALCULATOR */
ToolBar.BUTTON_CALCULATOR = 'calculator';
/** @name vs.ui.ToolBar.BUTTON_CALENDAR */
ToolBar.BUTTON_CALENDAR = 'calendar';
/** @name vs.ui.ToolBar.BUTTON_CALL */
ToolBar.BUTTON_CALL = 'call';
/** @name vs.ui.ToolBar.BUTTON_CANCEL */
ToolBar.BUTTON_CANCEL = 'cancel';
/** @name vs.ui.ToolBar.BUTTON_CASE */
ToolBar.BUTTON_CASE = 'case';
/** @name vs.ui.ToolBar.BUTTON_CHECKMARK */
ToolBar.BUTTON_CHECKMARK = 'checkmark';
/** @name vs.ui.ToolBar.BUTTON_CIRCLE_ARROW_LEFT */
ToolBar.BUTTON_CIRCLE_ARROW_LEFT = 'circle_arrow_left';
/** @name vs.ui.ToolBar.BUTTON_CIRCLE_ARROW_RIGHT */
ToolBar.BUTTON_CIRCLE_ARROW_RIGHT = 'circle_arrow_right';
/** @name vs.ui.ToolBar.BUTTON_COMMAND_LINE */
ToolBar.BUTTON_COMMAND_LINE = 'command_line';
/** @name vs.ui.ToolBar.BUTTON_COMMENT_ADD */
ToolBar.BUTTON_COMMENT_ADD = 'command_add';
/** @name vs.ui.ToolBar.BUTTON_COMMENT_DELETE */
ToolBar.BUTTON_COMMENT_DELETE = 'command_delete';
/** @name vs.ui.ToolBar.BUTTON_COMMENT_OK */
ToolBar.BUTTON_COMMENT_OK = 'command_ok';
/** @name vs.ui.ToolBar.BUTTON_COMPUTER_OFF */
ToolBar.BUTTON_COMPUTER_OFF = 'computer_off';
/** @name vs.ui.ToolBar.BUTTON_COMPUTER_ON */
ToolBar.BUTTON_COMPUTER_ON = 'computer_on';
/** @name vs.ui.ToolBar.BUTTON_CONSTRAST */
ToolBar.BUTTON_CONSTRAST = 'contrast';
/** @name vs.ui.ToolBar.BUTTON_CONTROL_1 */
ToolBar.BUTTON_CONTROL_1 = 'controls_1';
/** @name vs.ui.ToolBar.BUTTON_CONTROL_2 */
ToolBar.BUTTON_CONTROL_2 = 'controls_2';
/** @name vs.ui.ToolBar.BUTTON_CONTROL_3 */
ToolBar.BUTTON_CONTROL_3 = 'controls_3';
/** @name vs.ui.ToolBar.BUTTON_CONTROL_4 */
ToolBar.BUTTON_CONTROL_4 = 'controls_4';
/** @name vs.ui.ToolBar.BUTTON_CONTROL_5 */
ToolBar.BUTTON_CONTROL_5 = 'controls_5';
/** @name vs.ui.ToolBar.BUTTON_CONTROL_6 */
ToolBar.BUTTON_CONTROL_6 = 'controls_6';
/** @name vs.ui.ToolBar.BUTTON_CONTROL_7 */
ToolBar.BUTTON_CONTROL_7 = 'controls_7';
/** @name vs.ui.ToolBar.BUTTON_CONTROL_8 */
ToolBar.BUTTON_CONTROL_8 = 'controls_8';
/** @name vs.ui.ToolBar.BUTTON_COPY */
ToolBar.BUTTON_COPY = 'copy';
/** @name vs.ui.ToolBar.BUTTON_COURT */
ToolBar.BUTTON_COURT = 'court';
/** @name vs.ui.ToolBar.BUTTON_CREDIT_CARD */
ToolBar.BUTTON_CREDIT_CARD = 'credit_card';
/** @name vs.ui.ToolBar.BUTTON_CUT */
ToolBar.BUTTON_CUT = 'cut';
/** @name vs.ui.ToolBar.BUTTON_DANGER */
ToolBar.BUTTON_DANGER = 'danger';
/** @name vs.ui.ToolBar.BUTTON_DELETE */
ToolBar.BUTTON_DELETE = 'delete';
/** @name vs.ui.ToolBar.BUTTON_DISK */
ToolBar.BUTTON_DISK = 'disk';
/** @name vs.ui.ToolBar.BUTTON_DOCUMENT_BLANK */
ToolBar.BUTTON_DOCUMENT_BLANK = 'document_blank';
/** @name vs.ui.ToolBar.BUTTON_DOCUMENT */
ToolBar.BUTTON_DOCUMENT = 'document';
/** @name vs.ui.ToolBar.BUTTON_DOLLAR */
ToolBar.BUTTON_DOLLAR = 'dollar';
/** @name vs.ui.ToolBar.BUTTON_DOWNLAOD */
ToolBar.BUTTON_DOWNLAOD = 'download';
/** @name vs.ui.ToolBar.BUTTON_ERROR */
ToolBar.BUTTON_ERROR = 'error';
/** @name vs.ui.ToolBar.BUTTON_FAVORITIES_ADD */
ToolBar.BUTTON_FAVORITIES_ADD = 'favorities_add';
/** @name vs.ui.ToolBar.BUTTON_FAVORITIES_REMOVE */
ToolBar.BUTTON_FAVORITIES_REMOVE = 'favorities_remove';
/** @name vs.ui.ToolBar.BUTTON_FAVORITIES */
ToolBar.BUTTON_FAVORITIES = 'favorities';
/** @name vs.ui.ToolBar.BUTTON_FILM */
ToolBar.BUTTON_FILM = 'film';
/** @name vs.ui.ToolBar.BUTTON_FILMING */
ToolBar.BUTTON_FILMING = 'filming';
/** @name vs.ui.ToolBar.BUTTON_FIRST_AID */
ToolBar.BUTTON_FIRST_AID = 'first_aid';
/** @name vs.ui.ToolBar.BUTTON_FLAG_BIS */
ToolBar.BUTTON_FLAG_BIS = 'flag_1';
/** @name vs.ui.ToolBar.BUTTON_FLAG */
ToolBar.BUTTON_FLAG = 'flag';
/** @name vs.ui.ToolBar.BUTTON_FLASH_ARROW */
ToolBar.BUTTON_FLASH_ARROW = 'flash_arrow';
/** @name vs.ui.ToolBar.BUTTON_FLASH */
ToolBar.BUTTON_FLASH = 'flash';
/** @name vs.ui.ToolBar.BUTTON_FOLDER_BOOKMARCK */
ToolBar.BUTTON_FOLDER_BOOKMARCK = 'folder_bookmark';
/** @name vs.ui.ToolBar.BUTTON_FOLDER_GOTO */
ToolBar.BUTTON_FOLDER_GOTO = 'folder_goto';
/** @name vs.ui.ToolBar.BUTTON_FOLDER */
ToolBar.BUTTON_FOLDER = 'folder';
/** @name vs.ui.ToolBar.BUTTON_FONT_CAPITAL */
ToolBar.BUTTON_FONT_CAPITAL = 'font_capital';
/** @name vs.ui.ToolBar.BUTTON_FONT_ITALIC */
ToolBar.BUTTON_FONT_ITALIC = 'font_italic';
/** @name vs.ui.ToolBar.BUTTON_FONT_REGULAR */
ToolBar.BUTTON_FONT_REGULAR = 'font_regular';
/** @name vs.ui.ToolBar.BUTTON_FONT_UNDERLINE */
ToolBar.BUTTON_FONT_UNDERLINE = 'font_undeline';
/** @name vs.ui.ToolBar.BUTTON_FONT */
ToolBar.BUTTON_FONT = 'font';
/** @name vs.ui.ToolBar.BUTTON_FONTS */
ToolBar.BUTTON_FONTS = 'fonts';
/** @name vs.ui.ToolBar.BUTTON_FORUM */
ToolBar.BUTTON_FORUM = 'forum';
/** @name vs.ui.ToolBar.BUTTON_FRAME */
ToolBar.BUTTON_FRAME = 'frame';
/** @name vs.ui.ToolBar.BUTTON_GRAPH_AREAS */
ToolBar.BUTTON_GRAPH_AREAS = 'graph_areas';
/** @name vs.ui.ToolBar.BUTTON_GRAPH_BARS_DOWN */
ToolBar.BUTTON_GRAPH_BARS_DOWN = 'graph_bars_down';
/** @name vs.ui.ToolBar.BUTTON_GRAPH_BARS_UP */
ToolBar.BUTTON_GRAPH_BARS_UP = 'graph_bars_up';
/** @name vs.ui.ToolBar.BUTTON_GRAPH_BARS */
ToolBar.BUTTON_GRAPH_BARS = 'graph_bars';
/** @name vs.ui.ToolBar.BUTTON_GRAPH_DOWN */
ToolBar.BUTTON_GRAPH_DOWN = 'graph_down';
/** @name vs.ui.ToolBar.BUTTON_GRAPH_LINES */
ToolBar.BUTTON_GRAPH_LINES = 'graph_lines';
/** @name vs.ui.ToolBar.BUTTON_GRAPH_UP */
ToolBar.BUTTON_GRAPH_UP = 'graph_up';
/** @name vs.ui.ToolBar.BUTTON_HAT */
ToolBar.BUTTON_HAT = 'hat';
/** @name vs.ui.ToolBar.BUTTON_HELP */
ToolBar.BUTTON_HELP = 'help';
/** @name vs.ui.ToolBar.BUTTON_HOME */
ToolBar.BUTTON_HOME = 'home';
/** @name vs.ui.ToolBar.BUTTON_INFORMATION */
ToolBar.BUTTON_INFORMATION = 'information';
/** @name vs.ui.ToolBar.BUTTON_KEY */
ToolBar.BUTTON_KEY = 'key';
/** @name vs.ui.ToolBar.BUTTON_KEYBOARD */
ToolBar.BUTTON_KEYBOARD = 'keyboard';
/** @name vs.ui.ToolBar.BUTTON_LAPTOP */
ToolBar.BUTTON_LAPTOP = 'laptop';
/** @name vs.ui.ToolBar.BUTTON_LINK */
ToolBar.BUTTON_LINK = 'links';
/** @name vs.ui.ToolBar.BUTTON_LIST_BULLETS */
ToolBar.BUTTON_LIST_BULLETS = 'bullets';
/** @name vs.ui.ToolBar.BUTTON_LIST_NUMBERS */
ToolBar.BUTTON_LIST_NUMBERS = 'list_numbers';
/** @name vs.ui.ToolBar.BUTTON_LOCK */
ToolBar.BUTTON_LOCK = 'lock';
/** @name vs.ui.ToolBar.BUTTON_MAGNIFY_GLASS */
ToolBar.BUTTON_MAGNIFY_GLASS = 'magnify_glass';
/** @name vs.ui.ToolBar.BUTTON_MAIL */
ToolBar.BUTTON_MAIL = 'mail';
/** @name vs.ui.ToolBar.BUTTON_MANAGE */
ToolBar.BUTTON_MANAGE = 'manage';
/** @name vs.ui.ToolBar.BUTTON_MEASURE */
ToolBar.BUTTON_MEASURE = 'measure';
/** @name vs.ui.ToolBar.BUTTON_MEASURES */
ToolBar.BUTTON_MEASURES = 'measures';
/** @name vs.ui.ToolBar.BUTTON_MIC_BIS */
ToolBar.BUTTON_MIC_BIS = 'mic_bis';
/** @name vs.ui.ToolBar.BUTTON_MIC */
ToolBar.BUTTON_MIC = 'mic';
/** @name vs.ui.ToolBar.BUTTON_MINUS */
ToolBar.BUTTON_MINUS = 'minus';
/** @name vs.ui.ToolBar.BUTTON_MUTE */
ToolBar.BUTTON_MUTE = 'mute';
/** @name vs.ui.ToolBar.BUTTON_PAINT */
ToolBar.BUTTON_PAINT = 'pain';
/** @name vs.ui.ToolBar.BUTTON_PAPER_PLANE */
ToolBar.BUTTON_PAPER_PLANE = 'paper_plane';
/** @name vs.ui.ToolBar.BUTTON_PAPER_TRASH */
ToolBar.BUTTON_PAPER_TRASH = 'paper_trash';
/** @name vs.ui.ToolBar.BUTTON_PAPERCLIO */
ToolBar.BUTTON_PAPERCLIO = 'paperclio';
/** @name vs.ui.ToolBar.BUTTON_PARAGRAPH */
ToolBar.BUTTON_PARAGRAPH = 'paragraph';
/** @name vs.ui.ToolBar.BUTTON_PENCIL */
ToolBar.BUTTON_PENCIL = 'pencil';
/** @name vs.ui.ToolBar.BUTTON_PHOTO */
ToolBar.BUTTON_PHOTO = 'photo';
/** @name vs.ui.ToolBar.BUTTON_PIECHART */
ToolBar.BUTTON_PIECHART = '113';
/** @name vs.ui.ToolBar.BUTTON_POST */
ToolBar.BUTTON_POST = 'post';
/** @name vs.ui.ToolBar.BUTTON_PROFILE */
ToolBar.BUTTON_PROFILE = 'profile';
/** @name vs.ui.ToolBar.BUTTON_REFRESH */
ToolBar.BUTTON_REFRESH = 'refresh';
/** @name vs.ui.ToolBar.BUTTON_RESIZE */
ToolBar.BUTTON_RESIZE = 'resize';
/** @name vs.ui.ToolBar.BUTTON_RSS  */
ToolBar.BUTTON_RSS = 'rss';
/** @name vs.ui.ToolBar.BUTTON_SAD_FACE */
ToolBar.BUTTON_SAD_FACE = 'sade_face';
/** @name vs.ui.ToolBar.BUTTON_SAFE */
ToolBar.BUTTON_SAFE = 'safe';
/** @name vs.ui.ToolBar.BUTTON_SAVE */
ToolBar.BUTTON_SAVE = 'save';
/** @name vs.ui.ToolBar.BUTTON_SETTINGS */
ToolBar.BUTTON_SETTINGS = 'settings';
/** @name vs.ui.ToolBar.SHOPPING_BAG */
ToolBar.SHOPPING_BAG = 'shopping_bag';
/** @name vs.ui.ToolBar.SHOPPING_CART */
ToolBar.SHOPPING_CART = 'shopping_cart';
/** @name vs.ui.ToolBar.SHOPPING_HEAVY */
ToolBar.SHOPPING_HEAVY = 'shopping_heavy';
/** @name vs.ui.ToolBar.SIM */
ToolBar.SIM = 'sim';
/** @name vs.ui.ToolBar.SMILE_FACE */
ToolBar.SMILE_FACE = 'smile_face';
/** @name vs.ui.ToolBar.SORT_AZ */
ToolBar.SORT_AZ = 'sort_az';
/** @name vs.ui.ToolBar.SORT_ZA */
ToolBar.SORT_ZA = 'sort_za';
/** @name vs.ui.ToolBar.STAR */
ToolBar.STAR = 'star';
/** @name vs.ui.ToolBar.STORAGE */
ToolBar.STORAGE = 'storage';
/** @name vs.ui.ToolBar.SWITCH */
ToolBar.SWITCH = 'switch';
/** @name vs.ui.ToolBar.TAG_ADD */
ToolBar.TAG_ADD = 'tag_add';
/** @name vs.ui.ToolBar.TAG_CANCEL */
ToolBar.TAG_CANCEL = 'tag_cancel';
/** @name vs.ui.ToolBar.TAG_DELETE */
ToolBar.TAG_DELETE = 'tag_delete';
/** @name vs.ui.ToolBar.TAG */
ToolBar.TAG = 'tag';
/** @name vs.ui.ToolBar.TEXT_ALIGN_CENTER */
ToolBar.TEXT_ALIGN_CENTER = 'text_align_center';
/** @name vs.ui.ToolBar.TEXT_ALIGN_JUSTIFY */
ToolBar.TEXT_ALIGN_JUSTIFY = 'text_align_justify';
/** @name vs.ui.ToolBar.TEXT_ALIGN_LEFT */
ToolBar.TEXT_ALIGN_LEFT = 'text_align_left';
/** @name vs.ui.ToolBar.TEXT_ALIGN_RIGHT */
ToolBar.TEXT_ALIGN_RIGHT = 'text_align_right';
/** @name vs.ui.ToolBar.TIME */
ToolBar.TIME = 'time';
/** @name vs.ui.ToolBar.TIMER */
ToolBar.TIMER = 'timer';
/** @name vs.ui.ToolBar.TRASH */
ToolBar.TRASH = 'trash';
/** @name vs.ui.ToolBar.TWG */
ToolBar.TWG = 'twg';
/** @name vs.ui.ToolBar.UNLOCK */
ToolBar.UNLOCK = 'unlock';
/** @name vs.ui.ToolBar.UPLOAD */
ToolBar.UPLOAD = 'upload';
/** @name vs.ui.ToolBar.USER */
ToolBar.USER = 'user';
/** @name vs.ui.ToolBar.USERS */
ToolBar.USERS = 'users';
/** @name vs.ui.ToolBar.VOLUME_DOWN */
ToolBar.VOLUME_DOWN = 'volume_down';
/** @name vs.ui.ToolBar.VOLUME_UP */
ToolBar.VOLUME_UP = 'volume_up';
/** @name vs.ui.ToolBar.VOLUME */
ToolBar.VOLUME = 'volume';
/** @name vs.ui.ToolBar.WALLET */
ToolBar.WALLET = 'wallet';
/** @name vs.ui.ToolBar.WARNING */
ToolBar.WARNING = 'warning';
/** @name vs.ui.ToolBar.WIFI */
ToolBar.WIFI = 'wifi';
/** @name vs.ui.ToolBar.WINDOW_ERROR */
ToolBar.WINDOW_ERROR = 'window_error';
/** @name vs.ui.ToolBar.WINDOW_GLOBE */
ToolBar.WINDOW_GLOBE = 'window_globe';
/** @name vs.ui.ToolBar.WINDOW_LOCK */
ToolBar.WINDOW_LOCK = 'window_lock';
/** @name vs.ui.ToolBar.WINDOW */
ToolBar.WINDOW = 'window';
/** @name vs.ui.ToolBar.ZOOM_IN */
ToolBar.ZOOM_IN = 'zoom_in';
/** @name vs.ui.ToolBar.ZOMM_OUT */
ToolBar.ZOMM_OUT = 'zoom_out';

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.ToolBar = ToolBar;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * A ui.vs.TextLabel.
 *
 * @class
 * A ui.vs.TextLabel component displays a unselectable text.
 *
 @constructor
 * @extends vs.ui.View
 * @name vs.ui.TextLabel
 */
function TextLabel (config)
{
  this.parent = View;
  this.parent (config);
  this.constructor = TextLabel;
}

TextLabel.prototype = {
  
  /**
   * The text value
   * @protected
   * @type {string}
   */
  _text: "",

  /*****************************************************************
   *
   ****************************************************************/

  /**
   * @protected
   * @function
   */
  destructor: function ()
  {
    View.prototype.destructor.call (this);
  },

  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    View.prototype.initComponent.call (this);
    
    if (!this._text) { return; }
    
    util.setElementInnerText (this.view, this._text);
  }
};
util.extendClass (TextLabel, View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperty (TextLabel, "text", {

  /**
   * Set the text value
   * @name vs.ui.TextLabel#name
   * @param {string} v
   */
  set : function (v)
  {
    if (v === null || typeof (v) === "undefined") { v = ''; }
    else if (util.isNumber (v)) { v = '' + v; }
    else if (!util.isString (v))
    {
      if (!v.toString) { return; }
      v = v.toString ();
    }
    
    this._text = v;
    if (this.view)
    {
      util.setElementInnerText (this.view, this._text);
    }
  },

  /**
   * get the text value
   * @ignore
   * @type {string}
   */
  get : function ()
  {
    return this._text;
  }
});


/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.TextLabel = TextLabel;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
 
 Use code from Canto.js Copyright 2010 David Flanagan
*/

/**
 *  The vs.ui.Canvas class
 *
 *  @extends vs.ui.View
 *  @class
 *  The vs.ui.Canvas class is a subclass of vs.ui.View that allows you to easily draw
 *  arbitrary content within your HTML content.
 *  <p>
 *  When you instantiate the vs.ui.Canvas class you should reimpletement the draw method.
 *
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.ui.Canvas.
 * @name vs.ui.Canvas
 *
 *  @example
 *  var myCanvas = new vs.ui.Canvas (config);
 *  myCanvas.init ();
 *
 *  myCanvas.draw = function (x, y, width, height)
 *  {
 *    this.canvas_ctx.clearRect (x, y, width, height)
 *    // <=> this.c_clearRect (x, y, width, height)
 *      
 *    this.canvas_ctx.fillStyle = "rgb(200,0,0)";
 *    // <=> this.c_fillRect (10, 10, 55, 50);
 *   
 *    this.canvas_ctx.fillStyle = "rgba(0, 0, 200, 0.5)";
 *    // <=> this.c_fillRect (30, 30, 55, 50);
 *
 *    ...
 *    
 *  };
 *
 *  // other way to use vs.ui.Canvas
 *  myCanvas.moveTo(100,100).lineTo(200,200,100,200).closePath().stroke();
 *
 * @param {Object} config The configuration structure [mandatory]
*/
function Canvas (config)
{
  this.parent = View;
  this.parent (config);
  this.constructor = Canvas;
}

Canvas.prototype = {

  /**
   *
   * @protected
   * @type {CanvasRenderingContext2D|null}
   */
  canvas_ctx: null,
  
  /**
   *
   * @protected
   * @type {HTMLCanvasElement|null}
   */
  canvas_node: null,
  
/*****************************************************************
 *
 ****************************************************************/
  
  /**
   * @protected
   * @function
   */
  destructor: function ()
  {
    View.prototype.destructor.call (this);
  },

  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    View.prototype.initComponent.call (this);
    
    this.canvas_node = this.view.firstChild;
    if (this.canvas_node)
    {
      this.canvas_ctx = this.canvas_node.getContext('2d');
      
      this.canvas_node.width = this._size [0];
      this.canvas_node.height = this._size [1];    
      this.draw (0, 0, this._size [0], this._size [1]);
    }
  },
  
  /**
   *
   * @name vs.ui.Canvas#getContext
   * @function
   * @return {CanvasRenderingContext2D} the canvas context
   */
  getContext: function ()
  {
    return this.canvas_ctx;
  },
  
  /**
   * This method draws a rectangle.
   * <p/>
   * With 4 arguments, it works just like the 2D method. An optional
   * 5th argument specifies a radius for rounded corners. An optional
   * 6th argument specifies a clockwise rotation about (x,y).
   *
   * @name vs.ui.Canvas#c_drawRect
   * @function
   *
   * @param {number} x The x position
   * @param {number} y The y position
   * @param {number} w The rectangle width
   * @param {number} h The rectangle height
   * @param {number} radius The rectangle radius
   * @param {number} rotation The rectangle rotation
   */
  c_drawRect : function (x, y, w, h, radius, rotation)
  {
    if (arguments.length === 4)
    {
      // square corners, no rotation
      this.c_rect (x, y, w, h).stroke ();
    }
    else
    {
      if (!rotation)
      {
        // Rounded corners, no rotation
        this.c_polygon (x, y, x + w, y, x + w, y + h, x, y + h, radius);
      }
      else
      {
        // Rotation with or without rounded corners
        var sr = Math.sin (rotation), cr = Math.cos (rotation),
          points = [x,y], p = this.rotatePoint (w, 0, rotation);
          
        points.push (x + p [0], y + p [1]);
        p = this.rotatePoint (w, h, rotation);
        points.push (x + p [0], y + p [1]);
        p = this.rotatePoint (0, h, rotation);
        points.push (x + p [0], y + p [1]);
        if (radius) { points.push (radius); }
        
        this.c_polygon.apply (this, points);
      }
    }
    // The polygon() method handles setting the current point
    return this;
  },
  
  /**
   * @protected
   * @function
   */
  rotatePoint : function (x, y, angle)
  {
    return [x * Math.cos (angle) - y * Math.sin (angle),
            y * Math.cos (angle) + x * Math.sin (angle)];
  },

  /**
   * This method connects the specified points as a polygon.  It requires
   * at least 6 arguments (the coordinates of 3 points).  If an odd 
   * number of arguments are passed, the last one is taken as a corner
   * radius.
   *
   * @example
   *  var myCanvas = new vs.ui.Canvas (config);
   *  myCanvas.init ();
   *
   *  // draw a triangle
   *  myCanvas.c_polygon (100, 100, 50, 150, 300, 300);
   *
   * @name vs.ui.Canvas#c_polygon
   * @function
   * @param {...number} list of number
   */
  c_polygon : function ()
  {
    // Need at least 3 points for a polygon
    if (arguments.length < 6) { throw new Error("not enough arguments"); }

    var i, radius, n, x0, y0;
    
    this.c_beginPath ();

    if (arguments.length % 2 === 0)
    {
      this.c_moveTo (arguments [0], arguments [1]);
     
      for (i = 2; i < arguments.length; i += 2)
      {
        this.c_lineTo (arguments [i], arguments [i + 1]);
      }
    }
    else
    {
      // If the number of args is odd, then the last is corner radius
      radius = arguments [arguments.length - 1];
      n = (arguments.length - 1) / 2;

      // Begin at the midpoint of the first and last points
      x0 = (arguments [n * 2 - 2] + arguments [0]) /2;
      y0 = (arguments [n * 2 - 1] + arguments [1]) /2;
      this.c_moveTo (x0, y0);
      
      // Now arcTo each of the remaining points
      for (i = 0; i < n - 1; i++)
      {
        this.c_arcTo
          (arguments [i * 2], arguments [i * 2 + 1],
           arguments [i * 2 + 2], arguments [i * 2 + 3], radius);
      }
      // Final arcTo back to the start
      this.c_arcTo
        (arguments [n * 2 - 2], arguments [n * 2 - 1],
         arguments [0], arguments [1], radius);
    }

    this.c_closePath ();
    this.c_moveTo (arguments [0], arguments [1]);
    this.c_stroke ();
    return this;
  },

  /**
   * This method draws elliptical arcs as well as circular arcs.
   *
   * @name vs.ui.Canvas#c_ellipse
   * @function
   * @example
   *  var myCanvas = new Canvas (config);
   *  myCanvas.init ();
   *
   *  myCanvas.c_ellipse (100, 100, 50, 150, Math.PI/5, 0, Math.PI);
   *
   * @param {number} cx The X coordinate of the center of the ellipse
   * @param {number} cy The Y coordinate of the center of the ellipse
   * @param {number} rx The X radius of the ellipse
   * @param {number} ry The Y radius of the ellipse
   * @param {number} rotation The clockwise rotation about (cx,cy).
   *       The default is 0.
   * @param {number} sa The start angle; defaults to 0
   * @param {number} ea The end angle; defaults to 2pi
   * @param {boolean} anticlockwise The arc direction. The default
   *        is false, which means clockwise
   */
  c_ellipse : function (cx, cy, rx, ry, rotation, sa, ea, anticlockwise)
  {
    if (rotation === undefined) { rotation = 0;}
    if (sa === undefined) { sa = 0; }
    if (ea === undefined) { ea = 2 * Math.PI; }
      
    if (anticlockwise === undefined) { anticlockwise = false; }

    // compute the start and end points
    var sp =
      this.rotatePoint (rx * Math.cos (sa), ry * Math.sin (sa), rotation),
      sx = cx + sp[0], sy = cy + sp[1],
      ep = this.rotatePoint (rx * Math.cos (ea), ry * Math.sin (ea), rotation),
      ex = cx + ep[0], ey = cy + ep[1];
    
    this.c_moveTo (sx, sy);

    this.c_translate (cx, cy);
    this.c_rotate (rotation);
    this.c_scale (rx / ry, 1);
    this.c_arc (0, 0, ry, sa, ea, anticlockwise);
    this.c_scale (ry / rx, 1);
    this.c_rotate (-rotation);
    this.c_translate (-cx, -cy);
    
    this.c_stroke ();
    
    return this;
  },
  
  /**
   * Load a web page and draw it in the canvas. (does not work in Webkit)
   *
   * @name vs.ui.Canvas#load
   * @function
   *
   * @param {string} url The web site url
   */
  load : function (url)
  {
    var windowWidth = window.innerWidth - 25;  
    this.__iframe = document.createElement ("iframe");  
    this.__iframe.id = "canvas_load_iframe";  
    this.__iframe.height = "10px";  
    this.__iframe.width = windowWidth + "px";  
    this.__iframe.style.visibility = "hidden";  
    this.__iframe.src = url;  
    // Here is where the magic happens... add a listener to the  
    // frame's onload event
    this.nodeBind (this.__iframe, "load", 'remotePageLoaded');
    //append to the end of the page  
    document.body.appendChild (this.__iframe);
    
    return;      
  },
  
  /**
   * @protected
   * @function
   */
  remotePageLoaded : function ()
  {  
    // Get a reference to the window object you need for the canvas  
    // drawWindow method  
    var remoteWindow = this.__iframe.contentWindow,
      windowWidth = window.innerWidth - 25,
      windowHeight = window.innerHeight;  

    //Draw canvas  
    this.c_clearRect (0, 0, this._size [0], this._size [1]);  
    this.c_save ();  
    this.c_scale (this._size [0] / windowWidth, this._size [1] / windowHeight);  
    this.canvas_ctx.drawWindow
      (remoteWindow, 0, 0, windowWidth, windowHeight, "rgb(255,255,255)");  
    this.c_restore();  
  },
  
  /**
   * vs.ui.Canvas draw method.
   * Should be reimplement when you instanciate a vs.ui.Canvas object.
   *
   * @name vs.ui.Canvas#draw
   * @function
   *
   * @param {number} x The top position of the canvas; Default = 0
   * @param {number} y The left position of the canvas; Default = 0
   * @param {number} width The width of the canvas; Default = canvas's width
   * @param {number} height The height of the canvas; Default = canvas's height
   */
  draw : function (x, y, width, height)
  {
    if (!x) { x = 0; }
    if (!y) { y = 0; }
    if (!width) { width = this._size [0]; }
    if (!height) { height = this._size [1]; }
    
    this.c_clearRect (x, y, width, height);
      
    this.c_lineWidth = 3;
    this.c_shadowColor = 'white';
    this.c_shadowBlur = 1;
    
    var i, x1, y1, x2, y2;
    
    for (i = 0; i < 10; i++)
    {
      this.c_strokeStyle = 'rgb(' + 
        Math.floor (Math.random () * 255) + ',' + 
        Math.floor (Math.random () * 255) + ',' + 
        Math.floor (Math.random () * 255) +')';
      
      x1 = Math.floor (Math.random() * width);
      y1 = Math.floor (Math.random() * height);
  
      x2 = Math.floor (Math.random() * width);
      y2 = Math.floor (Math.random() * height);
  
      this.c_beginPath ();
      this.c_moveTo (x1,y1);
      this.c_lineTo (x2,y2);
      this.c_closePath ();
      this.c_stroke ();
    }
  }
};
util.extendClass (Canvas, View);

/**
 * @private
 */
Canvas.methods =   
  ['arc','arcTo','beginPath','bezierCurveTo','clearRect','clip',  
  'closePath','createImageData','createLinearGradient','createRadialGradient',  
  'createPattern','drawFocusRing','drawImage','fill','fillRect','fillText',  
  'getImageData','isPointInPath','lineTo','measureText','moveTo','putImageData',  
  'quadraticCurveTo','rect','restore','rotate','save','scale','setTransform',  
  'stroke','strokeRect','strokeText','transform','translate'];
  
/**
 * @private
 */
Canvas.props =
  ['canvas','fillStyle','font','globalAlpha','globalCompositeOperation',  
  'lineCap','lineJoin','lineWidth','miterLimit','shadowOffsetX','shadowOffsetY',  
  'shadowBlur','shadowColor','strokeStyle','textAlign','textBaseline'];

/**
 * @private
 */
Canvas.setup = function ()
{
  var i, m, p;
  for (i = 0; i < Canvas.methods.length; i++)
  {
    m = Canvas.methods [i];  
    Canvas.prototype ["c_" + m] = (function (m)
    {
      return function ()
      { // 9 args is most in API  
        this.canvas_ctx [m].apply (this.canvas_ctx, arguments);  
        return this;  
      };
    }(m));  
  }

  for (i = 0; i < Canvas.props.length; i++)
  {  
    p = Canvas.props [i];
    
    var d = {};
    
    d.enumerable = true; 
    d.set = (function (p)
    {
      return function (value)
      {
        this.canvas_ctx [p] = value;
      };
    }(p));
    
    d.get = (function (p)
    {
      return function ()
      {
        return this.canvas_ctx [p];
      };
    }(p));

    util.defineProperty (Canvas.prototype, "c_" + p, d);
  }  
};

Canvas.setup ();

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperty (Canvas, "size", {
 /** 
   * Getter|Setter for size. Gives access to the size of the vs.ui.Canvas
   * @name vs.ui.Canvas#size 
   *
   * @type {Array.<number>}
   */ 
  set : function (v)
  {
    if (!v) { return; } 
    if (!util.isArray (v) || v.length !== 2) { return; }
    if (!util.isNumber (v[0]) || !util.isNumber(v[1])) { return; }

    this._size [0] = v [0];
    this._size [1] = v [1];
    
    if (!this.view) { return; }
    this._updateSizeAndPos ();

    if (!this.canvas_node)
    {
      this.canvas_node = this.view.firstChild;
      if (!this.canvas_node)
      {
        console.error ('Uncompatible canvas view');
        return;
      }
      this.canvas_ctx = this.canvas_node.getContext ('2d');
    }
   this.canvas_node.width = this._size [0];
   this.canvas_node.height = this._size [1];    
   this.draw (0, 0, this._size [0], this._size [1]);
  },

  /**
   * @ignore
   * @type {Array.<number>}
   */
  get : function ()
  {
    if (this.view && this.view.parentNode)
    {
      this._size [0] = this.view.offsetWidth;
      this._size [1] = this.view.offsetHeight;
    }
    return this._size.slice ();
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.Canvas = Canvas;

/********************************************************************
                   Documentation
********************************************************************/

/**
 * Adds points to the subpath such that the arc described by the circumference 
 * of the circle described by the arguments, starting at the given start angle 
 * and ending at the given end angle, going in the given direction (defaulting * 
 * to clockwise), is added to the path, connected to the previous point by a 
 * straight line.
 * @name vs.ui.Canvas#c_arc
 * @function
 */

/**
 * Adds an arc with the given control points and radius to the current subpath, 
 * connected to the previous point by a straight line.
 * @name vs.ui.Canvas#c_arcTo
 * @function
 */

/**
 * Resets the current path.
 * @name vs.ui.Canvas#c_beginPath
 * @function
 */

/**
 * Adds the given point to the current subpath, connected to the previous one by 
 * a cubic Bézier curve with the given control points.
 * @name vs.ui.Canvas#c_bezierCurveTo
 * @function
 */

/**
 * Clears all pixels on the canvas in the given rectangle to transparent black.
 * @name vs.ui.Canvas#c_clearRect
 * @function
 */

/**
 * Further constrains the clipping region to the given path.
 * @name vs.ui.Canvas#c_clip
 * @function
 */

/**
 * Marks the current subpath as closed, and starts a new subpath with a point 
 * the same as the start and end of the newly closed subpath.
 * @name vs.ui.Canvas#c_closePath
 * @function
 */

/**
 * Returns an ImageData object with the given dimensions in CSS pixels (which 
 * might map to a different number of actual device pixels exposed by the object 
 * itself). All the pixels in the returned object are transparent black.
 * @name vs.ui.Canvas#c_createImageData
 * @function
 */

/**
 * Returns a CanvasGradient object that represents a linear gradient that paints 
 * along the line given by the coordinates represented by the arguments.
 * If any of the arguments are not finite numbers, throws a NotSupportedError 
 * exception.
 * @name vs.ui.Canvas#c_createLinearGradient
 * @function
 */

/**
 * Returns a CanvasGradient object that represents a radial gradient that paints 
 * along the cone given by the circles represented by the arguments.
 * If any of the arguments are not finite numbers, throws a NotSupportedError 
 * exception. If either of the radii are negative, throws an IndexSizeError 
 * exception.
 * @name vs.ui.Canvas#c_createRadialGradient
 * @function
 */

/**
 * Returns a CanvasPattern object that uses the given image and repeats in the 
 * direction(s) given by the repetition argument.
 * @name vs.ui.Canvas#c_createPattern
 * @function
 */

/**
 * @name vs.ui.Canvas#c_drawFocusRing
 * @function
 */

/**
 * Draws the given image onto the canvas.
 * @name vs.ui.Canvas#c_drawImage
 * @function
 */

/**
 * @name vs.ui.Canvas#c_fill
 * @function
 */

/**
 * Paints the given rectangle onto the canvas, using the current fill style.
 * @name vs.ui.Canvas#c_fillRect
 * @function
 */

/**
 * Fills the given text at the given position. If a maximum width is provided, 
 * the text will be scaled to fit that width if necessary.
 * @name vs.ui.Canvas#c_fillText
 * @function
 */

/**
 * Returns an ImageData object containing the image data for the given rectangle 
 * of the canvas.
 * @name vs.ui.Canvas#c_getImageData
 * @function
 */

/**
 * Returns true if the given point is in the current path.
 * @name vs.ui.Canvas#c_isPointInPath
 * @function
 */

/**
 * Adds the given point to the current subpath, connected to the previous one by 
 * a straight line.
 * @name vs.ui.Canvas#c_lineTo
 * @function
 */

/**
 * Returns a TextMetrics object with the metrics of the given text in the 
 * current font.
 * @name vs.ui.Canvas#c_measureText
 * @function
 */

/**
 * Creates a new subpath with the given point.
 * @name vs.ui.Canvas#c_moveTo
 * @function
 */

/**
 * Paints the data from the given ImageData object onto the canvas. If a dirty 
 * rectangle is provided, only the pixels from that rectangle are painted.
 * @name vs.ui.Canvas#c_putImageData
 * @function
 */

/**
 * Adds the given point to the current subpath, connected to the previous one by 
 * a quadratic Bézier curve with the given control point.
 * @name vs.ui.Canvas#c_quadraticCurveTo
 * @function
 */

/**
 * Adds a new closed subpath to the path, representing the given rectangle.
 * @name vs.ui.Canvas#c_rect
 * @function
 */

/**
 * Pops the top state on the stack, restoring the context to that state.
 * @name vs.ui.Canvas#c_restore
 * @function
 */

/**
 * Changes the transformation matrix to apply a rotation transformation with the 
 * given characteristics. The angle is in radians.
 * @name vs.ui.Canvas#c_rotate
 * @function
 */

/**
 * Pushes the current state onto the stack.
 * @name vs.ui.Canvas#c_save
 * @function
 */

/**
 * Changes the transformation matrix to apply a scaling transformation with the 
 * given characteristics.
 * @name vs.ui.Canvas#c_scale
 * @function
 */

/**
 * Changes the transformation matrix to the matrix given by the arguments as 
 * described below.
 * @name vs.ui.Canvas#c_setTransform
 * @function
 */

/**
 * Strokes the subpaths with the current stroke style.
 * @name vs.ui.Canvas#c_stroke
 * @function
 */

/**
 * Paints the box that outlines the given rectangle onto the canvas, using the 
 * current stroke style.
 * @name vs.ui.Canvas#c_strokeRect
 * @function
 */

/**
 * Strokes the given text at the given position. If a maximum width is provided, 
 * the text will be scaled to fit that width if necessary.
 * @name vs.ui.Canvas#c_strokeText
 * @function
 */

/**
 * Changes the transformation matrix to apply the matrix given by the arguments 
 * as described below.
 * @name vs.ui.Canvas#c_transform
 * @function
 */

/**
 * Changes the transformation matrix to apply a translation transformation with 
 * the given characteristics.
 * @name vs.ui.Canvas#c_translate
 * @function
 */

/**
 * Returns the canvas element.
 * @name vs.ui.Canvas#c_canvas
 */

/**
 * Can be set, to change the fill style.
 * <br />
 * Returns the current style used for filling shapes.
 * @name vs.ui.Canvas#c_fillStyle
 */

/**
 * Can be set, to change the font. The syntax is the same as for the CSS 'font' 
 * property; values that cannot be parsed as CSS font values are ignored.
 * <br />
 * Returns the current font settings
 * @name vs.ui.Canvas#c_font
 */

/**
 * Can be set, to change the alpha value. Values outside of the range 0.0 .. 1.0 
 * are ignored.
 * <br />
 * Returns the current alpha value applied to rendering operations.
 * @name vs.ui.Canvas#c_globalAlpha
 */

/**
 * Can be set, to change the composition operation. Unknown values are ignored.
 * <br />
 * Returns the current composition operation, from the list below.
 * @name vs.ui.Canvas#c_globalCompositeOperation
 */

/**
 * Can be set, to change the line cap style.
 * <br />
 * Returns the current line cap style.
 * @name vs.ui.Canvas#c_lineCap
 */

/**
 * Can be set, to change the line join style.
 * <br />
 * Returns the current line join style.
 * @name vs.ui.Canvas#c_lineJoin
 */

/**
 * Can be set, to change the miter limit ratio. Values that are not finite 
 * values greater than zero are ignored.
 * <br />
 * Returns the current miter limit ratio.
 * @name vs.ui.Canvas#c_miterLimit
 */

/**
 * Can be set, to change the line width. Values that are not finite values 
 * greater than zero are ignored.
 * Returns the current line width.
 * @name vs.ui.Canvas#c_lineWidth
 */

/**
 * Can be set, to change the shadow offset. Values that are not finite numbers 
 * are ignored.
 * <br />
 * Returns the current shadow offset.
 * @name vs.ui.Canvas#c_shadowOffsetX
 */

/**
 * Can be set, to change the shadow offset. Values that are not finite numbers 
 * are ignored.
 * <br />
 * Returns the current shadow offset.
 * @name vs.ui.Canvas#c_shadowOffsetY
 */

/**
 * Can be set, to change the blur level. Values that are not finite numbers 
 * greater than or equal to zero are ignored.
 * <br />
 * Returns the current level of blur applied to shadows.
 * @name vs.ui.Canvas#c_shadowBlur
 */

/**
 * Can be set, to change the shadow color. Values that cannot be parsed as CSS 
 * colors are ignored.
 * <br />
 * Returns the current shadow color.
 * @name vs.ui.Canvas#c_shadowColor
 */

/**
 * Can be set, to change the stroke style.
 * <br />
 * Returns the current style used for stroking shapes.
 * @name vs.ui.Canvas#c_strokeStyle
 */

/**
 * Can be set, to change the alignment. The possible values are start, end, 
 * left, right, and center. Other values are ignored. The default is start.
 * Returns the current text alignment settings.
 * @name vs.ui.Canvas#c_textAlign
 */

/**
 * Can be set, to change the baseline alignment. The possible values and their 
 * meanings are given below. Other values are ignored. The default is 
 * alphabetic.
 * <br />
 * Returns the current baseline alignment settings.
 * @name vs.ui.Canvas#c_textBaseline
 */
 /**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.ui.ProgressBar class
 *
 *  @extends vs.ui.View
 *  @class
 *  The vs.ui.ProgressBar class is used to convey the progress of a task.
 *
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.ui.ProgressBar.
 * @name vs.ui.ProgressBar
 *
 * @param {Object} config the configuration structure [mandatory]
*/
function ProgressBar (config)
{
  this.parent = View;
  this.parent (config);
  this.constructor = ProgressBar;
  
  this._range = [0, 100];
}

/**
 * @const
 * @private
 * @type {number}
 */
ProgressBar.BORDER_WIDTH_IOS = 5;

/**
 * @const
 * @private
 * @type {number}
 */
ProgressBar.BORDER_WIDTH_ANDROID = 5;

/**
 * @const
 * @private
 * @type {number}
 */
ProgressBar.BORDER_WIDTH_WP7 = 0;

/**
 * @const
 * @private
 * @type {number}
 */
ProgressBar.BORDER_WIDTH_SYMBIAN = 0;

/**
 * @const
 * @private
 * @type {number}
 */
ProgressBar.BORDER_WIDTH_BB = 1;

ProgressBar.prototype = {
  
  /**
   *
   * @private
   * @type {HTMLDivElement}
   */
  __inner_view: null,

  /**
   *
   * @protected
   * @type {number}
   */
  _index: 0,
  
  /**
   *
   * @protected
   * @type {number}
   */
  _indeterminate: false,

  /**
   *
   * @protected
   * @type {Array.<number>}
   */
  _range: null,
   
  /**
   *
   * @private
   * @type {number}
   */
  __border_width: 0,
  
  /*****************************************************************
   *
   ****************************************************************/

  /**
   * @protected
   * @function
   */
  destructor: function ()
  {
    View.prototype.destructor.call (this);
  },

  /**
   * @protected
   * @function
   */
  _updateSize: function ()
  {
    util.setElementSize (this.view, this._size [0],  this._size [1]);
    this.index = this._index;
  },
  
  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    View.prototype.initComponent.call (this);
    
    this.__inner_view = this.view.firstElementChild;
    this.indeterminate = this._indeterminate;

    var os_device = window.deviceConfiguration.os;
    if (os_device == DeviceConfiguration.OS_ANDROID)
    {
      this.__border_width = ProgressBar.BORDER_WIDTH_ANDROID * 2;
    }
    else if (os_device == DeviceConfiguration.OS_IOS)
    {
      this.__border_width = ProgressBar.BORDER_WIDTH_IOS * 2;
    }
    else if (os_device == DeviceConfiguration.OS_WP7)
    {
      this.__border_width = ProgressBar.BORDER_WIDTH_WP7 * 2;
    }
    else if (os_device == DeviceConfiguration.OS_SYMBIAN)
    {
      this.__border_width = ProgressBar.BORDER_WIDTH_SYMBIAN * 2;
    }
    else if (os_device == DeviceConfiguration.OS_BLACK_BERRY)
    {
      this.__border_width = ProgressBar.BORDER_WIDTH_BB * 2;
    }

    this.index = this._index;
  },
  
  /**
   * @protected
   * @function
   */
  refresh : function ()
  {
    this.index = this._index;
    View.prototype.refresh.call (this);
  }
};
util.extendClass (ProgressBar, View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (ProgressBar, {
  'index': {
    /** 
     * Allow to set or get the progress bar index
     * @name vs.ui.ProgressBar#index 
     * @type number
     */ 
    set : function (v)
    {
      if (!util.isNumber (v)) { return; }
  
      this._index = v;
      
      if (!this.__inner_view) { return; }
      
      var width = this.size [0], w;
      width -= this.__border_width;
      
      w = width * (this._index - this._range[0]) / 
                  (this._range [1] - this._range [0]);
      
      if (w > width) { w = width; }
      if (w < 0) { w = 0; }
          
      var os_device = window.deviceConfiguration.os;
      if (os_device === DeviceConfiguration.OS_ANDROID ||
          os_device === DeviceConfiguration.OS_IOS)
      {
        this.__inner_view.style.width = (w + this.__border_width) + 'px';
      }
      else { this.__inner_view.style.width = w + 'px'; }
    },
  
    /** 
     * @ignore
     * @return {number}
     */ 
    get : function ()
    {
      return this._index;
    }
  },
  'range': {
    /** 
     * Set or get the progress bar range, By default range = [0, 100];
     * @name vs.ui.ProgressBar#range 
     * @type Array
     */ 
    set : function (v)
    {
      if (!util.isArray (v) || v.length !== 2) { return; }
      if (!util.isNumber (v[0]) || !util.isNumber (v[1])) { return; }
      if (v[0] === v[1] || v[0] > v[1]) { return; }
  
      this._range [0] = v [0];
      this._range [1] = v [1];
      this.index = this._index;
    },
  
    /** 
     * @ignore
     * @return {Array}
     */ 
    get : function ()
    {
      return this._range.slice ();
    }
  },
  'indeterminate': {
    /** 
     * Boolean value indicating whether the progress bar is indeterminate.
     * @name vs.ui.ProgressBar#indeterminate 
     * @type Boolean
     */ 
    set : function (v)
    {
      if (v)
      {
        this._indeterminate = true;
        if (this.view) util.addClassName (this.view, 'indeterminate');
      }
      else
      {
        this._indeterminate = false;
        if (this.view) util.removeClassName (this.view, 'indeterminate');
      }
    },
  
    /** 
     * @ignore
     * @return Boolean
     */ 
    get : function ()
    {
      return this._indeterminate ;
    }
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.ProgressBar = ProgressBar;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.ui.Slider class
 *
 *  @extends vs.ui.View
 *  @class
 *  An vs.ui.Slider is a control used to select a single value from a continuous
 *  range of values. Sliders are horizontal or vertical.
 *  <p/>
 *  By default the range is include in [0, 100] and the value is a float.
 *
 *  <p>
 *  Events:
 *  <ul>
 *    <li/> continuous_change: data [number]; propagate when during slide
 *    <li/> change: data [number]: propagate at end of slide 
 *  </ul>
 *  <p>
 *  @example
 *  var config = {}
 *  var config.id = 'mySlider';
 *  var config.orientation = vs.ui.Slider.HORIZONTAL;
 *  var config.value = 10;
 *
 *  var mySlider = vs.ui.Slider (config);
 *  mySlider.init ();
 * <p>
 *
 *  @author David Thevenin
 * @name vs.ui.Slider 
 *
 *  @constructor
 *   Creates a new vs.ui.Slider.
 *
 * @param {Object} config the configuration structure [mandatory]
*/
function Slider (config)
{
  this.parent = View;
  this.parent (config);
  this.constructor = Slider;
  
  this._range = [0, 100];
}

/** 
 * Horizontal constant to configure a slider.
 * <p/>A slider can be horizontal or vertical.
 * Set the orientation property with this constant for a horizontal slider.
 * By default a slider is horizontal.
 * @see vs.ui.Slider#orientation
 * @name vs.ui.Slider.HORIZONTAL
 * @const
 */
Slider.HORIZONTAL = 0;

/** 
 * Vertical constant to configure a slider.
 * <p/>A slider can be horizontal or vertical.
 * Set the orientation property with this constant for a vertical slider.
 * By default a slider is horizontal.
 * @see vs.ui.Slider#orientation
 * @name vs.ui.Slider.VERTICAL
 * @const
 */
Slider.VERTICAL = 1;

Slider.prototype = {

  /*****************************************************************
   *
   ****************************************************************/
  /**
   * slider orientation (0: horizontal, 1: vertical)
   * @protected
   * @type {number}
   */
  _orientation : Slider.HORIZONTAL,

  /**
   * set default button position to 0
   * @protected
   * @type {number}
   */
  _value : 0,

  /**
   *
   * @protected
   * @type {Array.<number>}
   */
  _range: null,

  /*****************************************************************
   *
   ****************************************************************/

  /**
   * @private
   * @type {number}
   */
  __v : 0,

  /**
   * @private
   * @type {number}
   */
  __drag_x : 0,

  /**
   * @private
   * @type {number}
   */
  __drag_y : 0,

  /**
   * @private
   * @type {HTMLDivElement}
   */
  __handle : null,
  
  /**
   * @private
   * @type {number}
   */
  __handle_width : 0,
     
  /**
   * @private
   * @type {number}
   */
  __handle_delta : 10,
     
/********************************************************************
                  setter and getter declarations
********************************************************************/

  /**
   * @protected
   * @function
   */
  destructor: function ()
  {
    if (this.__drag_recognizer)
    {
      this.removePointerRecognizer (this.__drag_recognizer);
      this.__drag_recognizer = null;
    }
    View.prototype.destructor.call (this);
  },

  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    View.prototype.initComponent.call (this);

    var os_device =  vs.ui.View.getDeviceCSSCode (); //window.deviceConfiguration.os;

    if (os_device == Application.CSS_IOS)
    {
      this.__handle_width = 28;
    }
    else if (os_device == Application.CSS_WP7)
    {
      this.__handle_width = 30;
    }
    else if (os_device == Application.CSS_ANDROID)
    {
      this.__handle_width = 34;
    }
    else if (os_device == Application.CSS_BLACKBERRY)
    {
      this.__handle_width = 35;
      this.__handle_height = 12;
      this.__handle_delta = 3;
    }
    else { this.__handle_width = 23; }
    
    //1) find first Div.
    this.__handle = this.view.querySelector ('.handle');
      
    // top/bottom click listening
    vs.addPointerListener (this.__handle, core.POINTER_START, this, true);
    if (!this.__drag_recognizer)
    {
      this.__drag_recognizer = new DragRecognizer (this);
      this.addPointerRecognizer (this.__drag_recognizer);
    }
    
    this.orientation = this._orientation;
    this.value = this._value;
  },
  
  didDragStart : function (e) {
    // do not manage event for other targets
    if (e.targetPointerList.length === 0) { return; }
    
    this.__handle_width = this.__handle.offsetWidth;
    this.__handle_x = this.__handle.offsetLeft;
    this.__handle_y = this.__handle.offsetTop;
    
    this.__abs_pos = vs.util.getElementAbsolutePosition (this.view);

    // set the new handler position
    var clientX = e.targetPointerList[0].pageX - this.__abs_pos.x;
    var clientY = e.targetPointerList[0].pageY - this.__abs_pos.y;
    
    if (this._orientation === 0) {
      this.value = this._range [0] +
        (this._range [1] - this._range [0]) * clientX / this.view.offsetWidth;
    }
    else {
      this.value = this._range [0] +
        (this._range [1] - this._range [0]) * clientY / this.view.offsetHeight;
    }

    // save the actual value for drag incrementation
    this.__v = this._value;
    this.outPropertyChange ();
    this.propagate ('continuous_change', this._value);
    this.propagate ('change', this._value);
  },
  
  didDrag : function (info, e) {
    // do not manage event for other targets
    if (e.targetPointerList.length === 0) { return; }
    
    var clientX = e.targetPointerList[0].pageX - this.__abs_pos.x;
    var clientY = e.targetPointerList[0].pageY - this.__abs_pos.y;
    
    if (this._orientation === 0) {
      this.value = this._range [0] +
        (this._range [1] - this._range [0]) * clientX / this.view.offsetWidth;
    }
    else {
      this.value = this._range [0] +
        (this._range [1] - this._range [0]) * clientY / this.view.offsetHeight;
    }
    
    this.outPropertyChange ();
    this.propagate ('continuous_change', this._value);
  },
    
  didDragEnd : function () {
    this.propagate ('change', this._value);
  },
  
 /**********************************************************************
 
 *********************************************************************/

  /**
   * @protected
   * @function
   */
  refresh : function ()
  {
    // reconfigure handle size
    this.__handle_width = this.__handle.offsetWidth;
    
    if (this._orientation === 0)
      this.__handle_delta = this.view.offsetHeight;
    else
      this.__handle_delta = this.view.offsetWidth;
      
    // force GUI update
    this.value = this._value;

    View.prototype.refresh.call (this);
  }
};
util.extendClass (Slider, View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (Slider, {
  'value':{
    /**
     * Set the current slider value
     * The value should be include in [0, 100]
     * @name vs.ui.Slider#value 
     * @type number
     */
    set : function (v)
    {
      var height, width, x, y;
      
      if (isNaN (v)) return;
      if (v < this._range [0]) { v = this._range [0]; }
      if (v > this._range [1]) { v = this._range [1]; }
      
      this._value = v;
      var d1 = this.__handle_width / 2, d2 = 0;
       
      var os_device = window.deviceConfiguration.os;
      if (os_device === DeviceConfiguration.OS_BLACK_BERRY)
      {
        d2 = (this.__handle_height - this.__handle_delta) / 2;
      }
      else
      {
        d2 = (this.__handle_width - this.__handle_delta) / 2;
      }
      
      if (this._orientation === 0)
      {
        width = this.view.offsetWidth,
          x = Math.floor ((v - this._range [0]) * width /
            (this._range [1] - this._range [0])) - d1;
        
        if (SUPPORT_3D_TRANSFORM)
          setElementTransform (this.__handle, "translate3d(" + x + "px,-" + d2 + "px,0)");
        else
          setElementTransform (this.__handle, "translate(" + x + "px,-" + d2 + "px)");
          
        this.view.style.backgroundSize = (x + d1) + "px 10px";
      }
      else
      {
        height = this.view.offsetHeight,
          y = Math.floor ((v - this._range [0]) * height /
            (this._range [1] - this._range [0])) - d1;
          
        if (SUPPORT_3D_TRANSFORM)
          setElementTransform (this.__handle, "translate3d(-" + d2 + "px," + y + "px,0)");
        else
          setElementTransform (this.__handle, "translate(-" + d2 + "px," + y + "px)");
          
        this.view.style.backgroundSize = "10px " + (y + d1) + "px";
      }
    },
  
    /**
     * @ignore
     */
    get : function ()
    {
      return this._value;
    }
  },
  'range':{
    /** 
     * Set or get the slider range, By default range = [0, 100];
     * @name vs.ui.Slider#range 
     * @type Array.<number>
     */ 
    set : function (v)
    {
      if (!util.isArray (v) || v.length !== 2) { return; }
      if (!util.isNumber (v[0]) || !util.isNumber (v[1])) { return; }
      if (v[0] === v[1] || v[0] > v[1]) { return; }
  
      this._range [0] = v [0];
      this._range [1] = v [1];
       
      this.value = this._value;
    },
  
    /** 
     * @ignore
     * @return {Array}
     */ 
    get : function ()
    {
      return this._range.slice ();
    }
  },
  'orientation':{
    /**
     * Property to configure the slider orientation.
     * <p/>A slider can be horizontal or vertical.
     *  Use the vs.ui.Slider.HORIZONTAL
     * or vs.ui.Slider.VERTICAL constant to configure the slider.
     * <p/>By default a slider is horizontal.
     * @name vs.ui.Slider#orientation 
     * @type number
     */
    set : function (v)
    {
      if (v !== Slider.HORIZONTAL && v !== Slider.VERTICAL) { return; }
      
      this._orientation = v;
      
      if (this._orientation === 0)
      {
        this.removeClassName ('vertical');
        this.addClassName ('horizontal');
      }
      else
      {
        this.addClassName ('vertical');
        this.removeClassName ('horizontal');
      }
      
      // re-apply the value
      this.value = this._value;
    },
  
    /**
     * @ignore
     */
    get : function ()
    {
      return this._orientation;
    }
  },
  'size':{
    /** 
     * Getter|Setter for size. Gives access to the size of the GUI Object
     * @name vs.ui.Slider#size 
     *
     * @type {vs.ui.Slider.<number>}
     */ 
    set : function (v)
    {
      if (!v) { return; } 
      if (!util.isArray (v) || v.length !== 2) { return; }
      if (!util.isNumber (v[0]) || !util.isNumber(v[1])) { return; }
      
      this._size [0] = v [0];
      this._size [1] = v [1];
      
      if (!this.view) { return; }
      this._updateSizeAndPos ();
      
      // re-apply the value
      this.value = this._value;
    },
  
    /**
     * @ignore
     * @type {Array.<number>}
     */
    get : function ()
    {
      if (this.view && this.view.parentNode)
      {
        this._size [0] = this.view.offsetWidth;
        this._size [1] = this.view.offsetHeight;
      }
      return this._size.slice ();
    }
  }
});
/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.Slider = Slider;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * A vs.ui.ImageView.
 * @constructor
 * @name vs.ui.ImageView
 * @extends vs.ui.View
 * An vs.ui.ImageView embeds an image in your application.
 */
function ImageView (config)
{
  this.parent = View;
  this.parent (config);
  this.constructor = ImageView;
}

ImageView.prototype = {

  /**
   * The image url
   * @private
   * @type {string}
   */
  _src: null,

  /*****************************************************************
   *
   ****************************************************************/  
  /**
   * @protected
   * @function
   */
  destructor : function ()
  {
    if (this.view)
    {
      // force image free
      this.view.src = 
        'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';
    }
    View.prototype.destructor.call (this);
  },

  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    View.prototype.initComponent.call (this);
    
    this.view.ondragstart = function (e) { e.preventDefault(); return false; }

    // init default image src with the attribute node img.src
    // if it exists. Use getAttribute instead of direct property
    // in order to have a relative path (without base)
    if (this.view.src)
      this._src = this.view.getAttribute ('src');
    else
      this.view.src = this._src;
    
    this.view.setAttribute ('width', "100%");
    this.view.setAttribute ('height', "100%");
  }
};
util.extendClass (ImageView, View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (ImageView, {

  'src': {
    /**
     * Set the image url
     * @name vs.ui.ImageView#src 
     * @type {string}
     */
    set : function (v)
    {
      if (!util.isString (v)) { return; }
      
      this._src = v;
      
      if (this.view)
      {
        this.view.src = this._src;
      }
    },
  
    /**
     * Get the image url
     * @ignore
     * @return {string}
     */
    get : function ()
    {
      return this._src;
    }
  },
  'size': {
    /**
     * Set the image size
     * @name vs.ui.ImageView#size 
     *
     * @type {Array.<number>}
     */
    set : function (v)
    {
      if (!util.isArray (v) && v.length !== 2)
      {
        if (!util.isNumber (v[0]) || !util.isNumber(v[1])) { return; }
      }
      if (this.view)
      {
        this.view.setAttribute ('width', v [0]);
        this.view.setAttribute ('height', v [1]);
      }
      this._size [0] = v [0];
      this._size [1] = v [1];
      this._updateSizeAndPos ();
    },
  
    /**
     * @ignore
     * @return {Array.<number>}
     */
    get : function ()
    {
      if (this.view && this.view.parentNode)
      {
        this._size [0] = this.view.offsetWidth;
        this._size [1] = this.view.offsetHeight;
      }
      return this._size.slice ();
    }
  }
});
/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.ImageView = ImageView;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.ui.InputField class
 *
 *  @extends vs.ui.View
 *  @class
 *  The vs.ui.InputField class implements an input text.
 *  <p/>
 *  The control provides 
 *  a text field (for entering text) and cancel button. The View can be styled
 *  as a text field, a password field style (characters are replaced by dots)
 *  or a search field style.
 *  <p/>
 *  Events:
 *  <ul>
 *    <li /> change: Fired after the user enter a new value
 *  </ul>
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.ui.InputField.
 * @name vs.ui.InputField
 *
 *  @example
 *   var myInput = new vs.ui.InputField ({id:'input'});
 *   myInput.init ();
 *
 *   myInput.placeholder = "Type our password...";
 *   myVideo.type = vs.ui.InputField.PASSWORD;
 *
 * @param {Object} config The configuration structure [mandatory]
*/
function InputField (config)
{
  this.parent = View;
  this.parent (config);
  this.constructor = InputField;
}

/**
 * InputField is a text input
 * @name vs.ui.InputField.TEXT
 * @const
 */
InputField.TEXT = 'text';

/**
 * InputField is a passord input, that means the characters are replaced by dots
 * @name vs.ui.InputField.PASSWORD
 * @const
 */
InputField.PASSWORD = 'password';

/**
 * InputField is a search input
 * @name vs.ui.InputField.SEARCH
 * @const
 */
InputField.SEARCH = 'search';

InputField.prototype = {

  /**
   * The text field node
   * @private
   * @type {HTMLElement}
   */
  _text_field: null,
  
  /**
   * @private
   * @type {HTMLElement}
   */
  _clear_button: null,

  /**
   * The current field value
   *
   * @protected
   * @type {string}
   */
  _value: "",
  
  /**
   * @protected
   * @type {string}
   */
  _placeholder: "type ...",
  
  /**
   * The field type (TEST, PASSWORD, SEARCH)
   *
   * @protected
   * @type {int}
   */
  _type: InputField.TEXT,

  /*****************************************************************
   *
   ****************************************************************/

  /**
   * @protected
   * @function
   */
  destructor: function ()
  {
    this._text_field.removeEventListener ('focus', this);
    this._text_field.removeEventListener ('blur', this);
    this._text_field.removeEventListener ('change', this);
    this._text_field.removeEventListener ('input', this);
    
    if (this._clear_button)
    {    
      this.nodeUnbind (this._clear_button, core.POINTER_START, 'cleanData');  
    }
    delete (this._text_field);

    View.prototype.destructor.call (this);
  },

  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    View.prototype.initComponent.call (this);
        
    this._text_field = this.view.querySelector ('input');
    this._text_field.name = this.id
    
    this._clear_button = this.view.querySelector ('.clear_button');
    if (this._clear_button)
    {
      this.nodeBind (this._clear_button, core.POINTER_START, 'cleanData');  
    }
    this.type = this._type;
    this.value = this._value;
    this.placeholder = this._placeholder;

    this._text_field.addEventListener ('focus', this);
    this._text_field.addEventListener ('blur', this);
    this._text_field.addEventListener ('change', this);
    this._text_field.addEventListener ('input', this);
  },
    
  /**
   * @protected
   * @function
   */
  cleanData : function (v)
  {
    this._text_field.value = '';
    this._value = '';
    this._activateDelete (false);
    
    this.outPropertyChange ();
    this.propagate ('continuous_change', this._value);
    this.propagate ('change', this._value);
  },
    
  /**
   * @private
   * @function
   */
  changeData : function ()
  {
    this._value = this._text_field.value;
    if (this._value) { this._activateDelete (true); }
    else { this._activateDelete (false); }
  },
  
  /**
   * @private
   * @function
   */
  _activateDelete : function (v)
  {
    if (!this._clear_button)
    { return; }
    
    if (v) { util.setElementVisibility (this._clear_button, true); }
    else { util.setElementVisibility (this._clear_button, false); }
  },
  
  /**
   * @private
   * @function
   */
  onkeydown : function (event)
  {
    event = fixEvent (event)
    
    var editor = event.target
    if ((event.keyCode === TAB) || (event.keyCode === ENTER))
    {
      editor.blur ();
      return false
    }
  },
  
  /**
   * Set the focus to your input
   * @name vs.ui.InputField#setFocus 
   * @function
   */
  setFocus : function ()
  {
    this._text_field.focus ();
  },

  /**
   * Remove the focus to your input
   * @name vs.ui.InputField#setBlur 
   * @function
   */
  setBlur : function ()
  {
    this._text_field.blur ();
  },
  
  /**
   *  Set pointer events
   *
   * @name vs.ui.InputField#setPointerEvents 
   * @function
   */
  setPointerEvents : function (v)
  {
    if (v)
    { this._text_field.style.pointerEvents = 'none'; }
    else
    { this._text_field.style.pointerEvents = 'auto'; }
  },
  
  /**
   * Did enable delegate
   * @name vs.ui.View#_didEnable
   * @protected
   */
  _didEnable : function ()
  {
    if (this._enable) this._text_field.removeAttribute ('disabled');
    else this._text_field.setAttribute ('disabled', true);
  },
  
  /**
   * @private
   * @function
   */
  handleEvent : function (event)
  {
    var self = this;
    function manageBlur (event)
    {
      if (event.target === self.view || event.target === self._text_field)
      { return; }
      
      if (event.target === self._clear_button)
      {
        self.cleanData ();
        event.stopPropagation ();
        event.preventDefault ();
        return;
      }
      
      vs.removePointerListener (document, core.POINTER_START, manageBlur, true);
      self.setBlur ();
    }

    if (event.type === 'change')
    {
      this.changeData ();
      this.outPropertyChange ();
      this.propagate ('change', this._value);
    }
    else if (event.type === 'input')
    {
      this.changeData ();
      this.outPropertyChange ();
      this.propagate ('continuous_change', this._value);
    }
    else if (event.type === 'focus')
    {
      this.addClassName ('focus');
      this._value = this._text_field.value;
      if (this._value) { this._activateDelete (true); }
      else { this._activateDelete (false); }
      
      vs.addPointerListener (document, core.POINTER_START, manageBlur, true);
      this.propagate ('focus');
    }
    else if (event.type === 'blur')
    {
      this.removeClassName ('focus');
      this._activateDelete (false);
      window.scrollTo (0, 0);
      this.propagate ('blur');
    }
  }
}
util.extendClass (InputField, View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (InputField, {
  'value': {
    /**
     * Allows to set the input value
     * @name vs.ui.InputField#value 
     * @type {string}
     */
    set : function (v)
    {
      if (v === null || typeof (v) === "undefined") { v = ''; }
      else if (util.isNumber (v)) { v = '' + v; }
      else if (!util.isString (v))
      {
        if (!v.toString) { return; };
        v = v.toString ();
      }
  
      this._value= v;
      if (this._text_field)
      {
        this._text_field.value = this._value;
        if (!this._value || this._value === '')
        {this._activateDelete (false);}
        else {this._activateDelete (true);}
      }
    },
  
    /**
     * @ignore
     * @type {string}
     * @nosideeffects
     */
    get : function ()
    {
      this._value = this._text_field.value;
      return this._value;
    }
  },
  'type': {
    /**
     * Allows to change the input type.
     * you can choose between :
     * <ul>
     *   <li/>vs.ui.InputField.TEXT
     *   <li/>vs.ui.InputField.PASSWORD
     *   <li/>vs.ui.InputField.SEARCH
     * </ul>
     * @name vs.ui.InputField#type 
     * @type {enum}
     */
    set : function (v)
    {
      if (v !== InputField.TEXT &&
        v !== InputField.PASSWORD &&
        v !== InputField.SEARCH) { return; }
  
      if (!this.view) { return; } 
      
      this.removeClassName (this._type);
      this._type = v;
      this.addClassName (this._type);
      
      if (!this._text_field) { return; }
      if (this._type === InputField.PASSWORD)
      {
        this._text_field.setAttribute ('type', 'password');
      }
      else if (this._type === InputField.SEARCH)
      {
        this._text_field.setAttribute ('type', 'search');
      }
      else
      {
        this._text_field.setAttribute ('type', 'text');
      }
    }
  },
  'placeholder': {
    /**
     * Defines a hint to help users fill out the input field.
     * @name vs.ui.InputField#placeholder 
     * @type {enum}
     */
    set : function (v)
    {
      if (v === null || typeof (v) === "undefined") { v = ''; }
      else if (util.isNumber (v)) { v = '' + v; }
      else if (!util.isString (v))
      {
        if (!v.toString) { return; };
        v = v.toString ();
      }
  
      this._placeholder = v;
      if (this._text_field)
      {
        this._text_field.setAttribute ('placeholder', this._placeholder);
      }
    }
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.InputField = InputField;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.ui.PopOver class
 *
 *  @extends vs.ui.View
 *  @class
 *  The vs.ui.PopOver view allows you to present information temporarily on top of
 *  your existing views. This view should not be draw over the entire screen.
 *  <p/>
 *  To display properly (with the arrow) the popover you have to use the method 
 *  how" with 2 following parameters:
 *  <ul>
 *    <li/>The coordinate [x, y] on screen, specify the point
 *         which is pointed by the popover
 *    <li/>The popover position related the to first parameter
 *           (ABOVE, BELOW, RIGHT, LEFT). 
 *  </ul>
 * 
 *  The popover is composed of tree views.
 *  <ul>
 *    <li/>The main subView (vs.ui.View). This is the main view in which you can
 *         add any widgets you want to present. The insertion peg is name
 *         'children'. This view should presents information associate to the
 *         user task. <br/>For adding view, you should use the method "add" of the 
 *         popover
 *    <li/>The second and third views are the header and footer views. They are
 *         deactivated by default. These views are usefull to presents 
 *         information related to navigation, for instance navigation buttons,
 *         cancel/validation button, etc. 
 *  </ul>
 *
 * @example
 *   // PopOver creation
 *   var popOver = new vs.ui.PopOver ();
 *   popOver.init ();
 *
 *   // PopOver main view construction
 *   var list = new vs.ui.List ();
 *   list.init ();
 *   list.data = data;
 *   popOver.add (list, 'children');
 *
 *   // PopOver footer view activation and init
 *   popOver.hasFooter = true;
 *   var cancelButton = new vs.ui.Button ();
 *   cancelButton.init ();
 *   cancelButton.text = "Cancel";
 *   popOver.add (cancelButton, 'footer');
 *
 *   // PopOver draw
 *   popOver.show ([300, 100], vs.ui.PopOver.RIGHT);
 *
 *  @author David Thevenin
 * @name vs.ui.PopOver
 *
 *  @constructor
 *   Creates a new vs.ui.PopOver.
 *
 * @param {Object} config the configuration structure [mandatory]
*/
function PopOver (config)
{
  this.parent = View;
  this.parent (config);
  this.constructor = PopOver;
}

/**
 * The popover is positioned below the reference point
 * @name vs.ui.PopOver.BELOW
 * @const
 */
PopOver.BELOW = 0;

/**
 * The popover is positioned above the reference point
 * @name vs.ui.PopOver.ABOVE
 * @const
 */
PopOver.ABOVE = 1;

/**
 * The popover is positioned at left of the reference point
 * @name vs.ui.PopOver.LEFT
 * @const
 */
PopOver.LEFT = 2;

/**
 * The popover is positioned at right of the reference point
 * @name vs.ui.PopOver.RIGHT
 * @const
 */
PopOver.RIGHT = 3;

PopOver.prototype = {
  
  /*****************************************************************
   *               public members
   ****************************************************************/
   
  /*****************************************************************
   *               private/protected members
   ****************************************************************/
   
  /**
   *
   * @protected
   * @type {Array}
   */
  _point_position: null,

  /**
   *
   * @protected
   * @type {boolean}
   */
  _has_footer: false,

  /**
   *
   * @protected
   * @type {boolean}
   */
  _has_header: false,

  /*****************************************************************
   *               init methods
   ****************************************************************/
   
  /**
   * Object default init. <p>
   * Must be call after the new.
   * @protected
   * @function
   */
  initComponent : function ()
  {
    View.prototype.initComponent.call (this);
    
    this._arrow = this.view.querySelector ('.vs_ui_popover >.arrow');
    
    this.__show_clb = this._endShowConfiguration;
  },
        
  /*****************************************************************
   *               General methods
   ****************************************************************/
   
  /**
   * @protected
   * @function
   */
  _endShowConfiguration : function ()
  {
    var envlop = {}, delta, endShowConfiguration, size = this.size,
      max_y = window.innerHeight, max_x = window.innerWidth, pos;
    
    if (typeof this.__direction !== "undefined" && this._point_position)
    {
      envlop.x = this._point_position [0] - (size [0] /2);
      envlop.y = this._point_position [1] - (size [1] /2);
      envlop.width = size [0];
      envlop.height = size [1];
      
      if (this.__direction !== PopOver.BELOW &&
          this.__direction !== PopOver.ABOVE &&
          this.__direction !== PopOver.RIGHT &&
          this.__direction !== PopOver.LEFT)
      {
        if (this._point_position [0] > max_x /2)
        { this.__direction = PopOver.RIGHT; }
        else
        { this.__direction = PopOver.LEFT; }
        
        if (this._point_position [1] + envlop.height + 30 < max_y)
        { this.__direction = PopOver.BELOW; }
        else if (this._point_position [1] - envlop.height - 30 > 0)
        { this.__direction = PopOver.ABOVE; }
      }
      
      switch (this.__direction)
      {
        case PopOver.BELOW:
          envlop.y = envlop.y + (size [1] /2) + 15;
          if (envlop.x < 5) { envlop.x = 5; }
          if (envlop.x + envlop.width > max_x)
          { envlop.x = max_x - envlop.width - 5; }
          
          this._arrow.className = "arrow top";
          delta = this._point_position [0] - envlop.x - 15 - 8;
          this._arrow.style.left = "5px";
          this._arrow.style.right = "5px";
          this._arrow.style["-webkit-mask-position-x"] = delta + "px";
          this._arrow.style["-webkit-mask-position-y"] = "0px";
        break;
      
        case PopOver.ABOVE:
          envlop.y = envlop.y - (size [1] /2) - 15;
          if (envlop.x < 5) { envlop.x = 5; }
          if (envlop.x + envlop.width > max_x)
          { envlop.x = max_x - envlop.width - 5; }
          
          this._arrow.className = "arrow bottom"
          delta = this._point_position [0] - envlop.x - 15 - 8;
          this._arrow.style.left = "5px";
          this._arrow.style.right = "5px";
          this._arrow.style["-webkit-mask-position-x"] = delta + "px";
          this._arrow.style["-webkit-mask-position-y"] = "0px";
        break;
          
        case PopOver.RIGHT:
          envlop.x = envlop.x - (size [0] /2) - 15;
          if (envlop.y < 5) { envlop.y = 5; }
          if (envlop.y + envlop.height > max_y - 20)
          { envlop.y = max_y - envlop.height - 20; }
          
          this._arrow.className = "arrow right"
          delta = envlop.height - (this._point_position [1] - envlop.y + 15) - 2;
          this._arrow.style.left = "auto";
          this._arrow.style.right = "-13px";
          this._arrow.style["-webkit-mask-position-x"] = "0px";
          this._arrow.style["-webkit-mask-position-y"] = delta + "px";
        break;
      
        case PopOver.LEFT:
          envlop.x = envlop.x + (size [0] /2) + 15;
          if (envlop.y < 5) { envlop.y = 5; }
          if (envlop.y + envlop.height > max_y - 20)
          { envlop.y = max_y - envlop.height - 20; }
          
          this._arrow.className = "arrow left"
          delta = this._point_position [1] - envlop.y - 15 - 2;
          this._arrow.style.left = "-13px";
          this._arrow.style.right = "auto";
          this._arrow.style["-webkit-mask-position-x"] = "0px";
          this._arrow.style["-webkit-mask-position-y"] = delta + "px";
        break;
      }
      
      pos = util.getElementAbsolutePosition (this.view.parentElement);
      if (pos)
      {
        this.position = [envlop.x - pos.x, envlop.y - pos.y];
      }
      else
      {
        this.position = [envlop.x, envlop.y];
      }
      this.size = [envlop.width, envlop.height];
    }
    
    // force redraw !!!! grrrr !!!!
    this.redraw ();
  },
 
 /** 
   *  Shows and positions the popover according a given coordinate.
   *  <p/>
   *  The position is defined by a coordinate and position of the popover
   *  related to the coordinate. can be vs.ui.PopOver.ABOVE, 
   *  vs.ui.PopOver.BELOW, vs.ui.PopOver.RIGHT, vs.ui.PopOver.LEFT
   * 
   * @name vs.ui.PopOver#show
   * @function
   *
   * @param coordinate [Array] the coordinate of screen for the popover position
   * @param position [number] the position of the popover related to the
   *     coordinate. 
   * @param {Function} clb a function to call a the end of show process
   */ 
  show : function (pos, direction, clb)
  {
    if (!this.view || this._visible) { return; }
    
    if (pos && util.isArray (pos) && pos.length === 2 &&
      util.isNumber (pos[0]) && util.isNumber(pos[1]))
    {
      this._point_position = pos.slice ();;
    }
    else
    {
      this._point_position = null;
    }

    this.__direction = direction;

    this.view.style.setProperty ("display", 'block', null);
    this.__view_display = undefined;

    this.__is_hidding = false;
    this.__is_showing = true;

    if (this._show_animation)
    {
      this._show_animation.process (this, function () {
        this._show_object (clb);
      }, this);
    }
    else
    {
      this._show_object (clb);
    }
    
    vs.addPointerListener (document, core.POINTER_START, this, true); 
  },
  
  /**
   * @protected
   * @function
   */
  handleEvent : function (e)
  {
    if (this.childOf (e.target, this.view))
    { return; }
    
    e.preventDefault ();
    e.stopPropagation ();
  
    this.hide ();
  },
  
  
  /**
   * @protected
   * @function
   */
  childOf : function (child, parent)
  {
    if (child === parent) { return true; }
    
    child = child.parentElement
    while (child)
    {
      if (child === parent) { return true; }
      child = child.parentElement
    }
    return false;
  },

  /**
   * Hides the popover
   * @name vs.ui.PopOver#hide 
   * @function
   */
  hide : function ()
  {
    if (!this.view) { return; }
    View.prototype.hide.call (this);
    
    vs.removePointerListener (document, core.POINTER_START, this, true); 
    this.view.style.display = 'none';
  }
};
util.extendClass (PopOver, View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (PopOver, {
  'hasFooter': {
    /** 
     * Activate/deactivate the footer space. If its activate, you can
     * add child to this view.
     * @example
     *   myPopOver.hasFooter = true;
     *   button = new vs.ui.Button (...);
     *   myPopOver.add (button, 'footer');
     * @name vs.ui.PopOver#hasFooter 
     * @type boolean
     */ 
    set : function (v)
    {
      if (v) { this._has_footer = true; }
      else { this._has_footer = false; }
      
      if (this.view && this._has_footer)
      {
        this.addClassName ('withFooter');
      }
      if (this.view && !this._has_footer)
      {
        this.removeClassName ('withFooter');
      }
    },
  
    /** 
     * @ignore
     * @return boolean
     */ 
    get : function ()
    {
      return this._has_footer;
    }
  },
  'hasHeader': {
    /** 
     * Activate/deactivate the header space. If its activate, you can
     * add child to this view.
     * @example
     *   myPopOver.hasHeader = true;
     *   button = new vs.ui.Button (...);
     *   myPopOver.add (button, 'header');
     * @name vs.ui.PopOver#hasHeader 
     * @type boolean
     */ 
    set : function (v)
    {
      if (v) { this._has_header = true; }
      else { this._has_header = false; }
      
      if (this.view && this._has_header)
      {
        this.addClassName ('withHeader');
      }
      if (this.view && !this._has_header)
      {
        this.removeClassName ('withHeader');
      }
    },
  
    /** 
     * @ignore
     * @return {boolean}
     */ 
    get : function ()
    {
      return this._has_header;
    }
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.PopOver = PopOver;
/*
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.ui.Switch class
 *
 *  @extends vs.ui.View
 *  @class
 *  The vs.ui.Switch display an element showing the boolean state value.
 *  User is able to tap the control to change the value.
 *  <p>
 *  Events:
 *  <ul>
 *    <li /> change: Fired after the switch is tap. Event.data = true if button is toggled.
 *  </ul>
 *  <p>
 *  @example
 *  var toggle = new vs.ui.Switch ();
 *  toggle.init ();
 *  toggle.position = [100, 250];
 *
 *  toggle.textOn = 'I'
 *  toggle.textOff = 'O'
 * <p>
 *
 *  @author David Thevenin
 * @name vs.ui.Switch 
 *
 *  @constructor
 *   Creates a new vs.ui.Switch.
 *
 * @param {Object} config the configuration structure [mandatory]
*/
function Switch (config)
{
  this.parent = View;
  this.parent (config);
  this.constructor = Switch;
}

Switch.prototype = {
  
  /*****************************************************************
   *               private/protected members
   ****************************************************************/
   
  /**
   *
   * @private
   * @type {boolean}
   */
  __tap_recognizer: null,
  __switch_translate: 0,
    
  /**
   *
   * @protected
   * @type {boolean}
   */
  _selected: false,

  /**
   *
   * @protected
   * @type {boolean}
   */
  _toggled: true,

  /**
   * @private
   * @type {Number}
   */
  _mode: Application.CSS_DEFAULT,

  /**
   *
   * @private
   * @type {HTMLDivElement}
   */
  __toggle_on_view: null,

  /**
   *
   * @private
   * @type {HTMLDivElement}
   */
  __toggle_off_view: null,

  /**
   *
   * @private
   * @type {HTMLDivElement}
   */
  __switch_view: null,
  
  /**
   *
   * @protected
   * @type {string}
   */
  _text_on: "",

  /**
   *
   * @protected
   * @type {string}
   */
  _text_off: "",
  
  /*****************************************************************
   *    
   ****************************************************************/

  /**
   * @protected
   * @function
   */
  didTouch : function ()
  {
    this.addClassName ('pressed');
    this._selected = true;
  },
  
  /**
   * @protected
   * @function
   */
  didUntouch : function ()
  {
    this.removeClassName ('pressed');
    this._selected = false;
  },

  /*****************************************************************
   *               General methods
   ****************************************************************/
   
  /**
   * @protected
   * @function
   */
  _setToggle: function (v)
  {
    var self = this;

    if (v) {
      self._toggled = true;
    }
    else {
      self._toggled = false;
    }
  
    vs.scheduleAction (function () {
      self._initWidthSwitch ();
    
      if (self._toggled) {
        self.addClassName ('on');
        if (self._mode === Application.CSS_PURE) {
          util.setElementTransform (self.__switch_view,
            "translate3d(-15px,0,0)");
        }
        else if (self._mode !== Application.CSS_ANDROID) {
          util.setElementTransform (self.__switch_view,
            "translate3d(" + self.__switch_translate + "px,0,0)");
        }
        else if (self._mode === Application.CSS_ANDROID) {
          util.setElementTransform (self.__switch_view, "translate3d(0,0,0)");
        }
      }
      else {
        self.removeClassName ('on');
        util.setElementTransform (self.__switch_view, "translate3d(0,0,0)");
      }
      self.outPropertyChange ();
    });
  },
  
  /**
   * @protected
   * @function
   */
  viewDidAdd: function () {
    View.prototype.viewDidAdd.call (this);
    
    this._setToggle (this._toggled);
  },

  /**
   * @protected
   * @function
   */
  refresh: function () {
    View.prototype.refresh.call (this);
    
    this._mode =  vs.ui.View.getDeviceCSSCode ();
    this._setToggle (this._toggled);
  },

  /**
   * @protected
   * @function
   */
  didTap : function ()
  {
    this._setToggle (!this._toggled);
    this.propagate ('change', this._toggled);
  },

  /**
   * @protected
   * @function
   */
  destructor : function ()
  {
    if (this.__tap_recognizer)
    {
      this.removePointerRecognizer (this.__tap_recognizer);
      this.__tap_recognizer = null;
    }
    View.prototype.destructor.call (this);
  },

  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    View.prototype.initComponent.call (this);

    this.__toggle_on_view =
      this.view.querySelector ('.vs_ui_switch .toggle_on');
    this.__toggle_off_view =
      this.view.querySelector ('.vs_ui_switch .toggle_off');
    this.__switch_view =
      this.view.querySelector ('.vs_ui_switch .switch');

    if (!this.__tap_recognizer)
    {
      this.__tap_recognizer = new TapRecognizer (this);
      this.addPointerRecognizer (this.__tap_recognizer);
    }

    this._mode =  vs.ui.View.getDeviceCSSCode ();
    
    if (this._text_on)
    {
      this.textOn = this._text_on;
    }
//     else
//     {
//       this.textOn = "";//"ON";
//     }
    if (this._text_off)
    {
      this.textOff = this._text_off;
    }
//     else
//     {
//       this.textOff = "";//"OFF";
//     }

    this.toggled = this._toggled;
  },
  
  /**
   * @private
   * @function
   */
  _initWidthSwitch : function ()
  {
    var border = 
      parseInt (vs.util.getElementStyle (this.view, 'border-left-width'), 10) + 
      parseInt (vs.util.getElementStyle (this.view, 'border-right-width'), 10);
      
		this.__switch_translate =
		  this.view.offsetWidth - 
		  (this.__switch_view.offsetWidth + 2 * this.__switch_view.offsetLeft) -
		  border;
  },
  
  /**
   * @protected
   * @function
   */
  _updateSizeAndPos: function ()
  {
    var
      w = this._size [0], h = this._size [1],
 	    x = this._pos [0], y = this._pos [1], width,
      pWidth = 0, pHeight = 0,
      sPosL = 'auto', sPosT = 'auto', sPosR = 'auto',
      aH = this._autosizing [0], aV = this._autosizing [1];
    
    if (this.view.parentNode)
    {
      pWidth = this.view.parentNode.offsetWidth;
      pHeight = this.view.parentNode.offsetHeight;
    }
    
    if (aH === 4 || aH === 1) { width = w + 'px'; }
    else if (aH === 5 || aH === 7) { width = 'auto'; }
    else if (aH === 2 || aH === 3 || aH === 6 || aH === 0)
    {
      if (pWidth)
      {
        width = Math.round (w / pWidth * 100) + '%';
      }
      else { width = w + 'px'; } 
    }
    
    else { width = '100%'; }
    
    
    if (aH === 4 || aH === 5 || aH === 6 || aH === 7 || (aH === 2 && !pWidth))
    { sPosL = x + 'px'; }
    else if ((aH === 2 || aH === 0) && pWidth)
    { sPosL = Math.round (x / pWidth * 100) + '%'; }
    
    if (aH === 1 || aH === 3 || aH === 5 || aH === 7)
    {
      sPosR = pWidth - (x + w) + 'px';
    }

    if (aV === 4 || aV === 5 || aV === 6 || aV === 7 || (aV === 2 && !pHeight))
    { sPosT = y + 'px'; }
    else if ((aV === 2 || aV === 0) && pHeight)
    { sPosT = Math.round (y  / pHeight * 100) + '%'; }

    this.view.style.width = width;
    this.view.style.removeProperty ('height');

    this.view.style.left = sPosL;
    this.view.style.top = sPosT;
    this.view.style.right = sPosR;
    this.view.style.bottom = 'auto';
  }
};
util.extendClass (Switch, View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (Switch, {

  'textOn': {
    /** 
     * Getter|Setter for the text switch. Allow to get or change the text draw
     * by the switch when its on.
     * @name vs.ui.Switch#textOn 
     * @type String
     */ 
    set : function (v)
    {
      if (!this.__toggle_on_view)
      {
        console.warn ("vs.ui.Switch.textOff, none initialized comp: " + this.id);
        return;
      }
  
      if (v === null || typeof (v) === "undefined") { v = ''; }
      else if (util.isNumber (v)) { v = '' + v; }
      else if (!util.isString (v))
      {
        if (!v.toString) { return; }
        v = v.toString ();
      }
  
      this._text_on = v;
      util.setElementInnerText (this.__toggle_on_view, this._text_on);
    },
  
    /** 
     * @ignore
     * @return {string}
     */ 
    get : function ()
    {
      return this._text_on;
    }
  },
  'textOff': {
    /** 
     *  Getter|Setter for the text switch. Allow to get or change the text draw
     *  by the switch when its off.
     * @name vs.ui.Switch#textOff 
     *  @type String
     */ 
    set : function (v)
    {
      if (!this.__toggle_off_view)
      {
        console.warn ("vs.ui.Switch.textOff, none initialized comp: " + this.id);
        return;
      }
  
      if (v === null || typeof (v) === "undefined") { v = ''; }
      else if (util.isNumber (v)) { v = '' + v; }
      else if (!util.isString (v))
      {
        if (!v.toString) { return; }
        v = v.toString ();
      }
  
      this._text_off = v;
      util.setElementInnerText (this.__toggle_off_view, this._text_off);
    },
  
    /** 
     * @ignore
     * @return {string}
     */ 
    get : function ()
    {
      return this._text_off;
    }
  },
  'toggled': {
  
    /** 
     * Getter|Setter the toggled state.
     * @name vs.ui.Switch#toggled 
     * @type boolean
     */ 
    set : function (v)
    {
      var self = this;
      vs.scheduleAction (function () { self._setToggle (v); });
    },
  
    /** 
     * @ignore
     * @return {boolean}
     */ 
    get : function ()
    {
      return this._toggled;
    }
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.Switch = Switch;
/*
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * 
 * Find more about the Spinning Wheel function at
 * http://cubiq.org/spinning-wheel-on-webkit-for-iphone-ipod-touch/11
 *
 * Copyright (c) 2009 Matteo Spinelli, http://cubiq.org/
 * Released under MIT license
 * http://cubiq.org/dropbox/mit-license.txt
 * 
 * Version 1.4 - Last updated: 2009.07.09
 * 
 */

/**
 *  The vs.ui.Picker class
 *
 *  @extends vs.ui.View
 *  @class
 *  vs.ui.Picker defines a view that use a spinning-wheel or slot-machine 
 *  metaphor to show one or more sets of values. Users select values by 
 *  rotating the wheels so that the desired row of values aligns with a
 *  selection indicator.
 *  <p>
 *  This code ins based on Spinning Wheel object from Matteo Spinelli.
 *
 *  <p>
 *  Delegate:
 *  <ul>
 *    <li/>pickerViewSelectRow : function (vs.ui.Picker the view)
 *  </ul>
 *  <p>
 *  Event:
 *  <ul>
 *    <li/>change : data : {index: slot_index, key: selected key, value, 
 *                  selected value} 
 *  </ul>
 *  <p>
 *  @example
 *  var sizePicker = new vs.ui.Picker ();
 *  
 *  sizePicker.addSlot (vs.ui.Picker.NUMBERS, 'right');
 *  sizePicker.addSlot (vs.ui.Picker.NUMBERS, 'right');
 *  sizePicker.addSlot (vs.ui.Picker.NUMBERS, 'right');
 *  sizePicker.addSlot ({ separator: ',', 'readonly');
 *  sizePicker.addSlot (vs.ui.Picker.NUMBERS, 'right');
 *  sizePicker.addSlot ({ cm: 'Cm', ft: 'Feet' }, 'shrink');
 *
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.ui.Picker.
 * @name vs.ui.Picker
 *
 * @param {Object} config the configuration structure [mandatory]
 */
function Picker (config)
{
  this.parent = View;
  this.parent (config);
  this.constructor = Picker;
}

/**
 * Predefined numbers for the Picker
 *
 * @name vs.ui.Picker.NUMBERS
 * @public
 * @const
 */
Picker.NUMBERS =
  { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9};

Picker.prototype = {

  /**
   * @private
   * @type {Number}
   */
  _mode: Application.CSS_DEFAULT,

  /**
   * @private
   * @type {Number}
   */
  _cell_height: 44,

  /**
   * @private
   * @type {Number}
   */
  _friction: 0.003,

  /**
   * Slots data
   * @protected
   * @type {Array}
   */
  _data: null,

  /**
   * Slots build elements
   * @private
   * @type {Array}
   */
  _slots_elements: null,

  /**
   * Slots build elements
   * @private
   * @type {Array}
   */
  _current_values: null,

  /**
   * @protected
   * @type {Array}
   */
  _selected_keys: null,

  /**
   * @protected
   * @type {Array}
   */
  _selected_values: null,

  /*****************************************************************
   *
   ****************************************************************/

  /**
   * destructor
   *
   * @protected
   * @function
   */
  destructor : function ()
  {
    vs.removePointerListener (this.view, core.POINTER_START, this, false);

    vs.removePointerListener (document, core.POINTER_START, this, false);
    vs.removePointerListener (document, core.POINTER_MOVE, this, false);

    util.removeAllElementChild (this._slots_view);

    delete (this._data);
    delete (this._slots_elements);
    delete (this._frame_view);
    delete (this._slots_view);
 
    delete (this._current_values);
 
    View.prototype.destructor.call (this);
  },
  
  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    View.prototype.initComponent.call (this);

    this._data = [];
    this._slots_elements = [];
    
    this._mode =  vs.ui.View.getDeviceCSSCode ();
    
    // Pseudo table element (inner wrapper)
    this._slots_view = this.view.querySelector ('.slots');
        
    // The scrolling controller
    this._frame_view = this.view.querySelector ('.frame');
    
    switch (this._mode)
    {
      case Application.CSS_BLACKBERRY:
         this._cell_height = 50;

      case Application.CSS_DEFAULT:
      default:
        // Add scrolling to the slots
        vs.addPointerListener (this.view, core.POINTER_START, this);
        this._frame_border_width = 0;
      break;
      
      case Application.CSS_WP7:
        this._cell_height = 83;
      
      case Application.CSS_ANDROID:
        this._frame_view.parentElement.removeChild (this._frame_view);
      break;
    }    
  },

  /**
   * Remove all slots from the picker
   *
   * @public
   * @name vs.ui.Picker#removeAllSlots 
   * @function
   */
  removeAllSlots: function ()
  {
    delete (this._data);
    this._data = [];
    
    this._remove_all_slots ();
  },

  /**
   * Remove all slots from the picker
   *
   * @public
   * @name vs.ui.Picker#removeAllSlots 
   * @function
   */
  _remove_all_slots: function ()
  {
    util.removeAllElementChild (this._slots_view);

    delete (this._slots_elements);
    this._slots_elements = [];
    
    this._active_slot = null;
  },

  /**
   * Renders slots
   *
   * @private
   * @function
   */
  _render_slots: function ()
  {
    // Create HTML slot elements
    for (var l = 0; l < this._data.length; l++)
    {
      // Create the slot
      this._render_a_slot (l);
    }
  },  
  
  /**
   * Renders one slot
   *
   * @private
   * @function
   */
  _render_a_slot: function (l)
  {
    var i, out, ul, div, data = this._data[l];

    if (!data) { return; }

    var width = 0;
    var os_device = window.deviceConfiguration.os;
    if (data.length && os_device == DeviceConfiguration.OS_WP7)
      width = Math.floor (100 / data.length);
    
     // Create the slot
    ul = document.createElement ('ul');
    ul.index = l;

    // WP7 does not manage box model (then use inline-block instead of)
    if (width) util.setElementStyle (ul, {"width": width + '%'});

    out = '';
    
    for (i in data.values)
    {
      out += '<li>' + data.values[i] + '<' + '/li>';
    }
    util.safeInnerHTML (ul, out);
    
    if (this._mode === Application.CSS_ANDROID)
    {
      // Create slot container
      div = document.createElement ('div');
      
      var buttons = this._generate_button (l);

      div.appendChild (buttons [0]);
    
      // Create slot container
      var slot = document.createElement ('div');
      // Add styles to the container
      slot.className = data.style;
      slot.appendChild (ul);
      div.appendChild (slot);

      div.appendChild (buttons [1]);
    }
    else
    {
      // Create slot container
      div = document.createElement ('div');
      // Add styles to the container
      div.className = data.style;
      div.appendChild (ul);
    }

    // Append the slot to the wrapper
    this._slots_view.appendChild (div);
    
    // Save the slot position inside the wrapper
    ul.slotPosition = l;
    ul.slotYPosition = 0;
    switch (this._mode)
    {
      case Application.CSS_WP7:
        ul.slotMaxScroll = this.view.clientHeight - ul.clientHeight;
        vs.addPointerListener (ul, core.POINTER_START, this, true);
      break;
    }    
    
    // Add default transition
    ul.style.webkitTransitionTimingFunction = 'cubic-bezier(0, 0, 0.2, 1)';   

    if (SUPPORT_3D_TRANSFORM)
      setElementTransform (ul, 'translate3d(0,0,0)');
    else
      setElementTransform (ul, 'translate(0,0)');
    
    // Save the slot for later use
    this._slots_elements.push (ul);
    
    // Place the slot to its default position (if other than 0)
    if (data.defaultValue)
    {
      this.scrollToValue (l, data.defaultValue);  
    }
  },
  
  /**
   * @protected
   * @function
   */
  _generate_button: function (i)
  {
    var readonly = this._data[i].style.match ('readonly');

    var button_incr = document.createElement ('div');
    if (readonly)
    {
      button_incr.className = 'button_incr readonly';
    }
    else
    {
      button_incr.className = "button_incr";
      util.setElementInnerText (button_incr, '+');
      button_incr.slotPosition = i;
    }

    if (!readonly)
    {
      vs.addPointerListener (button_incr, core.POINTER_START, this);
      vs.addPointerListener (button_incr, core.POINTER_END, this);
      vs.addPointerListener (button_incr, core.POINTER_CANCEL, this);
    }
    
    // Create the slot
    var button_decr = document.createElement ('div');
    if (readonly)
    {
      button_decr.className = 'button_decr readonly';
    }
    else
    {
      button_decr.className = 'button_decr';
      util.setElementInnerText (button_decr, '-');
      button_decr.slotPosition = i;
    }

    if (!readonly)
    {
      vs.addPointerListener (button_decr, core.POINTER_START, this);
      vs.addPointerListener (button_decr, core.POINTER_END, this);
      vs.addPointerListener (button_decr, core.POINTER_CANCEL, this);
    }
    
    return [button_incr, button_decr];
  },
  
  /**
   * @protected
   * @function
   */
  _buttonSelected : function (e)
  {
    var slotNum = e.target.slotPosition;
    switch (e.type)
    {
      case core.POINTER_START:
        util.addClassName (e.target, 'active');
        break
      
      case core.POINTER_END:
        var slot_elem = this._slots_elements[slotNum], slotMaxScroll,
          pos = slot_elem.slotYPosition;
        if (util.hasClassName (e.target, 'button_decr'))
        {
          pos += 44;
          if (pos > 0) { pos = 0;}
        }
        else
        {
          pos -= 44;
          var slotMaxScroll = this.getSlotMaxScroll (slot_elem);
          if (pos < slotMaxScroll) { pos = slotMaxScroll; }
        }

        this._scrollTo (slotNum, pos);
      case core.POINTER_CANCEL:
        util.removeClassName (e.target, 'active');
        break
    }
  },
  
  /**
   * Add a new slot to the picket view.
   * <p>
   * The new slot is added at right of others slots.<br/>
   * Values is in the form of: < key: value >. Keys are the identifiers
   * that won’t be shown in the picker.<br/>
   *
   * Styles is a list of space separated predefined styles to be applied
   * to the slot. The available values are:
   * <ul>
   *  <li />right, align text inside the slot to the right;
   *  <li />readonly, the slot can’t be spun;
   *  <li />shrink, shrink the slot width to the minimum possible.
   * </ul>
   *
   * @name vs.ui.Picker#addSlot
   * @function
   *
   * @param {Object} values The slot data
   * @param {string} style The slot style
   * @param {string} defaultValue The default value to set
   */
  addSlot: function (values, style, defaultValue)
  {
    if (!style) { style = ''; }

    var obj = {}
    obj.values = values;
    obj.style = style;
    obj.defaultValue = defaultValue;
    
    this._data.push (obj);
    
    this._render_a_slot (this._data.length - 1);
  },
  
  /**
   * Returns slots selected value.
   *
   * @public
   *
   * @name vs.ui.Picker#getSelectedValues
   * @function
   *
   * @return {Object} {keys, values}
   */
  getSelectedValues: function ()
  {
    if (this._current_values) { return this._current_values; }
    
    var index, count, i, l, elem, slotMaxScroll;
    
    this._selected_keys = [];
    this._selected_values = [];

    for (i = 0; i < this._slots_elements.length; i++)
    {
      elem = this._slots_elements[i];
      if (!elem)
      { continue; }
      // Remove any residual animation
      elem.removeEventListener (vs.TRANSITION_END, this, false);
      elem.style.setProperty (vs.TRANSITION_DURATION, '0');

      slotMaxScroll = this.getSlotMaxScroll (elem);
      
      if (elem.slotYPosition > 0)
      {
        this._setPosition (i, 0);
      }
      else if (elem.slotYPosition <  slotMaxScroll)
      {
        this._setPosition (i, slotMaxScroll);
      }

      index = -Math.round (elem.slotYPosition / this._cell_height);

      count = 0;
      for (l in this._data[i].values)
      {
        if (count == index)
        {
          this._selected_keys.push (l);
          this._selected_values.push (this._data[i].values[l]);
          break;
        }
        
        count++;
      }
    }

    this._current_values =
      { 'keys': this._selected_keys, 'values': this._selected_values };
    return this._current_values;
  },

  /**
   * Returns slots selected value.
   *
   * @private
   * @function
   *
   * @return {Object} {keys, values}
   */
  _getSelectedValues: function ()
  {
    if (this._current_values) { return this._current_values; }
    
    var index, count, i, l, elem;

    this._selected_keys = [];
    this._selected_values = [];

    for (i = 0; i < this._slots_elements.length; i++)
    {
      elem = this._slots_elements[i];
      if (!elem) { continue; }

       index = -Math.round (elem.slotYPosition / this._cell_height);

      count = 0;
      for (l in this._data[i].values)
      {
        if (count == index)
        {
          this._selected_keys.push (l);
          this._selected_values.push (this._data[i].values[l]);
          break;
        }
        
        count++;
      }
    }

    this._current_values =
      { 'keys': this._selected_keys, 'values': this._selected_values };
    return this._current_values;
  },

  /**
   * Scroll a given slot to a set value
   *
   * @name vs.ui.Picker#scrollToValue
   * @function
   *
   * @param {number} slot the slot number (number starting from 0)
   * @param {string} value the value to set
   * @return {boolean} returns true if the value was set. False otherwise.
   */
  scrollToValue: function (slot, value)
  {
    var yPos, count, i, elem = this._slots_elements[slot],
      slot_data = this._data[slot];

    if (!elem) { return false; }
    if (!slot_data) { return false; }
    
    elem.removeEventListener (vs.TRANSITION_END, this, false);
    elem.style.setProperty (vs.TRANSITION_DURATION, '0');
    
    count = 0;
    for (i in slot_data.values)
    {
      if (i == value)
      {
        yPos = count * this._cell_height;
        this._setPosition (slot, yPos);
        return true;
      }
      
      count -= 1;
    }
    return false
  },
  
  /*****************************************************************
   *              private general methodes
   ****************************************************************/

  /**
   * Rolling slots
   *
   * @private
   * @function
   */
  _setPosition: function (slot, pos)
  {
    delete (this._current_values);
    var elem = this._slots_elements [slot];
    elem.slotYPosition = pos;

    if (SUPPORT_3D_TRANSFORM)
      setElementTransform (elem, 'translate3d(0,' + pos + 'px,0)');
    else
      setElementTransform (elem, 'translate(0,' + pos + 'px)');
  },
  
  /**
   * Rolling slots
   *
   * @private
   * @function
   */
  _scrollTo: function (slotNum, dest, runtime)
  {
    var slot_elem = this._slots_elements[slotNum], slotMaxScroll;
    slot_elem.style.setProperty (vs.TRANSITION_DURATION, runtime ? runtime + 'ms': '100ms');
    this._setPosition (slotNum, dest ? dest : 0);

    slotMaxScroll = this.getSlotMaxScroll (slot_elem);
    
    // If we are outside of the boundaries go back to the sheepfold
    if (slot_elem.slotYPosition > 0 ||
        slot_elem.slotYPosition < slotMaxScroll)
    {
      slot_elem.addEventListener (vs.TRANSITION_END, this, false);
    }
    else
    {
      if (this._delegate && this._delegate.pickerViewSelectRow)
      {
        this._delegate.pickerViewSelectRow (this);
      }
      this.propagate ('change', this._getSelectedValues ());
      this.outPropertyChange ();
    }
  },
  
  /*****************************************************************
   *              Events managements
   ****************************************************************/

  /**
   * Main event handler
   *
   * @private
   * @function
   */
  handleEvent: function (e)
  {
    if (this._mode === Application.CSS_ANDROID)
    {
      this._buttonSelected (e);
    }
    else switch (e.type)
    {
      case core.POINTER_START:
        this._scrollStart (e);
      break;

      case core.POINTER_MOVE:
        this._scrollMove (e);
      break;

      case core.POINTER_END:
        this._scrollEnd (e);
      break;

      case vs.TRANSITION_END:
        this._backWithinBoundaries (e);
      break;
    }
  },

  /**
   * @private
   * @function
   */
  __get_slot_index : function (point) {

    var target = point.target, ul_slot;
    if (target.nodeName === "UL") {
      return target.index;
    }
    
    if (target.nodeName === "LI") {
      return target.parentElement.index;
    }
    // in case "pointer-events" property does not work
    if (target === this._frame_view) {
      var css = this._getComputedStyle (this._frame_view);
      this._frame_border_width = css ? parseInt (css.getPropertyValue ('border-left-width')) : 0;

      var delta = 0;
      // Find the clicked slot
      var rec = util.getBoundingClientRect (this._slots_view);
      if (this._mode == Application.CSS_BLACKBERRY) { delta = 8; }
    
      // Clicked position
      var xPos = point.clientX - rec.left - this._frame_border_width - delta; 
    
      // Find tapped slot
      var slot = 0;
      for (var i = 0; i < this._slots_elements.length; i++)
      {
        slot += this._slots_elements[i].offsetWidth;
      
        if (xPos < slot)
        {
          return i;
        }
      }
    }
    return undefined;
  },

  /**
   * @protected
   * @function
   */
  _scrollStart: function (e)
  {
  
    if (e.nbPointers > 1) return false;
    
    e.preventDefault ();
    e.stopPropagation ();
    
    var point = e.targetPointerList [0];
    this._active_slot = undefined;

    switch (this._mode)
    {
      default:
        this._active_slot = this.__get_slot_index (point);
      break;

      case Application.CSS_WP7:
        this._active_slot = e.currentTarget.index;
        util.addClassName ("dragging");
      break;
    }
    
    if (typeof this._active_slot === "undefined")
    { return; }

    // If slot is readonly do nothing
    if (this._data[this._active_slot].style.match('readonly'))
    {
      vs.removePointerListener (document, core.POINTER_MOVE, this, true);
      vs.removePointerListener (document, core.POINTER_END, this, true);
      return false;
    }
    
    var slot_elem = this._slots_elements[this._active_slot];
    
    slot_elem.slotMaxScroll = this.getSlotMaxScroll (slot_elem);

    slot_elem.removeEventListener (vs.TRANSITION_END, this, false);  // Remove transition event (if any)
    slot_elem.style.setProperty (vs.TRANSITION_DURATION, '0');   // Remove any residual transition
    
    // Stop and hold slot position
    if (SUPPORT_3D_TRANSFORM)
    {
      var
        matrix = vs.util.getElementMatrixTransform (slot_elem),
        pos_y = matrix.m42;

      if (pos_y != slot_elem.slotYPosition)
      {
        this._setPosition (this._active_slot, pos_y);
      }
    }
    
    this.startY = point.pageY;
    this.scrollStartY = slot_elem.slotYPosition;
    this.scrollStartTime = e.timeStamp;

    vs.addPointerListener (document, core.POINTER_MOVE, this, true);
    vs.addPointerListener (document, core.POINTER_END, this, true);
    
    switch (this._mode)
    {
      case Application.CSS_WP7:
      case Application.CSS_BLACKBERRY:
        if (this.__timer)
        {
          clearTimeout (this.__timer);
          this.__timer = 0;
        }
        
        if (this.__elem_to_hide && this.__elem_to_hide != slot_elem)
        {
          util.removeClassName (this.__elem_to_hide.parentElement, "visible");
          this.__elem_to_hide = null;
        }
        util.addClassName (slot_elem.parentElement, "visible");
      break;
    }    

    return true;
  },

  /**
   * @protected
   * @function
   */
  _scrollMove: function (e)
  {
    e.preventDefault ();
    e.stopPropagation ();

    var point = e.targetPointerList [0];
    var topDelta = point.pageY - this.startY;
    var slot_elem = this._slots_elements[this._active_slot];

    if (slot_elem.slotYPosition > 0 ||
        slot_elem.slotYPosition < slot_elem.slotMaxScroll)
    {
      topDelta /= 2;
    }
    
    this._setPosition (this._active_slot, slot_elem.slotYPosition + topDelta);
    this.startY = point.pageY;

    // Prevent slingshot effect
    if (e.timeStamp - this.scrollStartTime > 80)
    {
      this.scrollStartY = slot_elem.slotYPosition;
      this.scrollStartTime = e.timeStamp;
    }
  },
  
  /**
   * @protected
   * @function
   */
  _scrollEnd: function (e)
  {
    vs.removePointerListener (document, core.POINTER_MOVE, this, true);
    vs.removePointerListener (document, core.POINTER_END, this, true);
    
    var elem = this._slots_elements[this._active_slot], scrollDist,
      scrollDur, newDur, newPos, self = this;
    if (!elem) { return; }

    switch (this._mode)
    {
//      case Application.CSS_BLACKBERRY:
//        this.__elem_to_hide = elem;
//      break;
  
      case Application.CSS_BLACKBERRY:
      case Application.CSS_WP7:
        if (elem.parentElement)
        {
          this.__elem_to_hide = elem;
          this.__timer = setTimeout (function ()
          {
            util.removeClassName (self.__elem_to_hide.parentElement, "visible");
            self.__elem_to_hide = null;
            self.removeClassName ("dragging");
          }, 1000);
        }
      break;
    }    

    // If we are outside of the boundaries, let's go back to the sheepfold
    if (elem.slotYPosition > 0 || elem.slotYPosition < elem.slotMaxScroll)
    {
      this._scrollTo 
        (this._active_slot, elem.slotYPosition > 0 ? 0 : elem.slotMaxScroll);
      return false;
    }

    // Lame formula to calculate a fake deceleration
    scrollDist = elem.slotYPosition - this.scrollStartY;

    // The drag session was too short
    if (scrollDist < this._cell_height / 1.5 && 
        scrollDist > -this._cell_height / 1.5)
    {
      if (elem.slotYPosition % this._cell_height)
      {
        this._scrollTo 
          (this._active_slot,
          Math.round(elem.slotYPosition / this._cell_height) *
            this._cell_height, 100);
      }

      return false;
    }

    scrollDur = e.timeStamp - this.scrollStartTime;

    newDur = (2 * scrollDist / scrollDur) / this._friction;
    scrollDist = (this._friction / 2) * (newDur * newDur);
    
    if (newDur < 0)
    {
      newDur = -newDur;
      scrollDist = -scrollDist;
    }

    newPos = elem.slotYPosition + scrollDist;
 
    if (newPos > 0)
    {
      // Prevent the slot to be dragged outside the visible area (top margin)
      newPos /= 2;
      newDur /= 3;

      if (newPos > this.view.clientHeight / 4)
      {
        newPos = this.view.clientHeight / 4;
      }
    }
    else if (newPos < elem.slotMaxScroll)
    {
      // Prevent the slot to be dragged outside the visible area (bottom margin)
      newPos = (newPos - elem.slotMaxScroll) / 2 + elem.slotMaxScroll;
      newDur /= 3;
      
      if (newPos < elem.slotMaxScroll - this.view.clientHeight / 4)
      {
        newPos = elem.slotMaxScroll - this.view.clientHeight / 4;
      }
    }
    else
    {
      newPos = Math.round (newPos / this._cell_height) * this._cell_height;
    }

    this._scrollTo
      (this._active_slot, Math.round (newPos), Math.round (newDur));
 
    return true;
  },

  /**
   * @protected
   * @function
   */
  getSlotMaxScroll : function (ul)
  {
    switch (this._mode)
    {
      case Application.CSS_DEFAULT:
      default:
        return this.view.clientHeight - ul.clientHeight - 66;
      break;
      
      case Application.CSS_IOS:
        return this.view.clientHeight - ul.clientHeight - 86;
      break;
      
      case Application.CSS_SYMBIAN:
        return this.view.clientHeight - ul.clientHeight - 80;
      break;
      
      case Application.CSS_BLACKBERRY:
        return this.view.clientHeight - ul.clientHeight - 93;
      break;
      
      case Application.CSS_WP7:
        return this.view.clientHeight - ul.clientHeight - 103;
      break;
      
      case Application.CSS_ANDROID:
        return this.view.clientHeight - ul.clientHeight - 121;
      break;
    }
    
    return 0;
  },
  
  /**
   * @protected
   * @function
   */
  _backWithinBoundaries: function (e)
  {
    var elem = e.target;
    elem.removeEventListener (vs.TRANSITION_END, this, false);
    
    slotMaxScroll = this.getSlotMaxScroll (elem);

    this._scrollTo
      (elem.slotPosition, elem.slotYPosition > 0 ? 0 : slotMaxScroll, 150);
    
    return false;
  }
};
util.extendClass (Picker, View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (Picker, {
  'delegate': {
    /** 
     * Set the delegate.
     * It should implements following methods
     *  <ul>
     *    <li/>pickerViewSelectRow : function (vs.ui.Picker the view)
     *  </ul>
     * @name vs.ui.Picker#delegate 
     * @type {Object}
     */ 
    set : function (v)
    {
      this._delegate = v;
    }
  },
  
  'data': {
    /** 
     * Sets the Picker datas
     * 
     * Data is a array of object <values, type, default_value>:
     * <ul>
     * <li/>Values is in the form of: < key: value >. Keys are the identifiers
     * that won’t be shown in the picker.<br/>
     *
     * <li/>Styles is a list of space separated predefined styles to be applied
     * to the slot. The available values are:
     * <ul>
     *  <li />right, align text inside the slot to the right;
     *  <li />readonly, the slot can’t be spun;
     *  <li />shrink, shrink the slot width to the minimum possible.
     * </ul>
     * 
     * <li/>Default value, a value include in values field
     * </ul>
     *
     * @example
     *  var sizePicker = new vs.ui.Picker ();
     *  
     *  sizePicker.data = [
     *     {values: vs.ui.Picker.NUMBERS, style: 'right shrink'},
     *     {values: vs.ui.Picker.NUMBERS, style: 'right shrink'},
     *     {values: vs.ui.Picker.NUMBERS, style: 'right shrink'}];
     * 
     * @name vs.ui.Picker#data 
     * @type {boolean|number}
     */ 
    set : function (v)
    {
      var data, values, style, defaultValue, i;
      if (!util.isArray (v))
      { return; }
      
      this.removeAllSlots ();
      
      for (i = 0; i < v.length; i++)
      {
        data = v [i];
        values = data.values
        style = data.style
        defaultValue = data.defaultValue
        
        if (!values) { continue; }
        
        this.addSlot (values, style, defaultValue);
      }
    }
  },
  
  'selectedKeys': {
    /** 
     * Get the selected slot keys
     * @name vs.ui.Picker#selectedKeys 
     * @type {Array}
     */ 
    get : function ()
    {
      if (!this._current_values)
      {
        this.getSelectedValues ();
      }
      return this._selected_keys;
    }
  },
  
  'selectedValues': {
    /** 
     * Get the selected slot values
     * @name vs.ui.Picker#selectedValues 
     * @type {Array}
     */ 
    get : function ()
    {
      if (!this._current_values)
      {
        this.getSelectedValues ();
      }
      return this._selected_values;
    }
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.Picker = Picker;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and
  contributors. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.ui.SVGView class
 *
 *  @extends vs.ui.View
 *  @class
 *  An vs.ui.SVGView embeds an svg view into your application.
 *
 *  @example
 *  var svg = vs.ui.SVGView (config).init ();
 *  svg.href = 'image.svg';
 *  // or
 *  svg.href = 'image.svg#id';
 *  // or
 *  svg.contentData = "<svg.... ";
 *
 *  @author David Thevenin
 * @name vs.ui.SVGView
 *
 *  @constructor
 *   Creates a new vs.ui.SVGView.
 *
 * @param {Object} config the configuration structure [mandatory]
*/
function SVGView (config)
{
  this.parent = View;
  this.parent (config);
  this.constructor = SVGView;
}

var SVG_DOCUMENTS = {};
var SVG_DOCUMENTS_TO_LOAD = {};
var SVG_DEFS = null;

function load_svg_doc (path, id, svg_obj)
{
  if (!path || !svg_obj) return;

  var handlers = SVG_DOCUMENTS_TO_LOAD [path];
  if (handlers)
  {
    // register new handler
    handlers.push ({ elem_id: id, svg_obj : svg_obj });
  }
  else
  {
    // create handlers and register new handler
    handlers = [];
    handlers.push ({ elem_id: id, svg_obj : svg_obj });

    SVG_DOCUMENTS_TO_LOAD [path] = handlers;

    // load document
    var object = document.createElement ('object');
    object.data = path;
    object.type = "image/svg+xml";
    object.width = "0";
    object.height = "0";
    object.style.visibility = "hidden";

    object.onload = function () {

      var doc = object.getSVGDocument ();
      if (!doc) return;
      var svg_doc = doc.querySelector ('svg');
      if (!SVG_DEFS)
      {
        var svg = document.createElementNS ("http://www.w3.org/2000/svg", 'svg');
        svg.setAttribute ("width", "0");
        svg.setAttribute ("height", "0");
        document.body.appendChild (svg);
        
        SVG_DEFS = document.createElementNS ("http://www.w3.org/2000/svg", 'defs');
        svg.appendChild (SVG_DEFS);
      }
      SVG_DEFS.appendChild (svg_doc);
      document.body.removeChild (object);

      SVG_DOCUMENTS [path] = svg_doc;

      var handlers = SVG_DOCUMENTS_TO_LOAD [path];
      if (!handlers) return;
      delete (SVG_DOCUMENTS_TO_LOAD [path]);

      for (var i = 0; i < handlers.length; i++)
      {
        var handler = handlers [i];
        handler.svg_obj.__set_svg_doc (svg_doc, handler.elem_id);
      }
    };
    document.body.appendChild (object);
  }
}

SVGView.prototype = {

  /**
   * The svg url
   * @private
   * @type {string}
   */
  _href: null,

  /**
   * The svg view box
   * @private
   * @type {array}
   */
  _view_box: null,

  /*****************************************************************
   *
   ****************************************************************/
  __set_svg_doc : function (svg_doc, elem_id)
  {
    if (!svg_doc) return;

    var svg = document.createElementNS ("http://www.w3.org/2000/svg", 'svg');

    util.removeAllElementChild (this.view);
    this.view.appendChild (svg);
    if (this._view_box) this.viewBox = this._view_box;

    function create_use (elem_id)
    {
      var use_elem = document.createElementNS ("http://www.w3.org/2000/svg", 'use');
      use_elem.setAttributeNS ("http://www.w3.org/1999/xlink", "href", "#" + elem_id);
      return use_elem;
    }

    if (elem_id)
    {
      svg.appendChild (create_use (elem_id));
    }
    else
    {
      var nodes = svg_doc.childNodes;
      for (var i = 0; i < nodes.length; i++)
      {
        var node = nodes [i];
        if (node.nodeType === 1 && node.nodeName !== 'defs')
        {
          elem_id = node.getAttribute ('id');
          if (!elem_id)
          {
            elem_id = vs.core.createId ();
            node.setAttribute ('id', elem_id);
          }
          svg.appendChild (create_use (elem_id));
        }
      }
    }
  }
};
util.extendClass (SVGView, View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (SVGView, {
  'href': {
    /**
     * Set the image url
     * @name vs.ui.SVGView#src
     * @type {string}
     */
    set : function (v)
    {
      if (!util.isString (v)) { return; }

      this._href = v;
      var href, elem_id;

      if (v.indexOf ("#") !== -1)
      {
        href = v.substr (0, v.indexOf ("#"));
        elem_id = v.substring (v.indexOf ("#") + 1);
      }
      else
      {
        href = this._href;
      }

      var svg_doc = SVG_DOCUMENTS [href];
      if (svg_doc) this.__set_svg_doc (svg_doc, elem_id);
      else load_svg_doc (href, elem_id, this);
    },

    /**
     * Get the image url
     * @ignore
     * @return {string}
     */
    get : function ()
    {
      return this._href;
    }
  },

  'contentData': {
    /**
     * Set the image url
     * @name vs.ui.SVGView#contentData
     * @type {string}
     */
    set : function (v)
    {
      if (!util.isString (v)) { return; }

      util.removeAllElementChild (this.view);
      if (this.__object)
      {
        delete (this.__object);
      }

      util.safeInnerHTML (this.view, v);
      this._href = undefined;
    }
  },

  'viewBox': {
    /**
     * Set the image url
     * @name vs.ui.SVGView#viewBox
     * @type {array}
     */
    set : function (v)
    {
      if (!util.isArray (v) || v.length != 4) { return; }

      this._view_box = v;

      var svg_doc = this.view.querySelector ('svg');
      if (!svg_doc) return;

      svg_doc.setAttribute ('width', v[2]);
      svg_doc.setAttribute ('height', v[3]);
      svg_doc.setAttribute ('viewBox', v.join (' '));
    }
  }
});
/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.SVGView = SVGView;
/*
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/


/**
 *  The vs.ui.SegmentedButton class
 *
 *  @extends vs.ui.View
 *  @class
 *  The vs.ui.SegmentedButton class is a subclass of vs.ui.View that intercepts
 *  pointer-down events and sends an 'select' event to a target object when
 *  it’s clicked or pressed.
 *  <br />
 *  The widget displays horizontally a set of button. Only one button can be
 *  selected.
 *  <br />
 *  Events:
 *  <ul>
 *    <li /> select: Fired after a button is pressed. {index, item}
 *  </ul>
 *  <p>
 *  @example
 *  // Simple example: (the button will have the platform skin)
 *
 *  var segButton = vs.ui.SegmentedButton ({
 *    items : ['test1', 'test2', 'test3'],
 *    size : [280, 30],
 *    style : vs.ui.SegmentedButton.BAR_STYLE
 *  }).init ();
 * <p>
 *
 *  @author David Thevenin
 * @name vs.ui.SegmentedButton
 *
 *  @constructor
 *   Creates a new vs.ui.SegmentedButton.
 * @name s.ui.SegmentedButton
 *
 * @param {Object} config the configuration structure
*/
function SegmentedButton (config)
{
  this.parent = View;
  this.parent (config);
  this.constructor = SegmentedButton;
}

/**
 * default type
 * @name vs.ui.SegmentedButton.DEFAULT_TYPE
 * @const
 */
SegmentedButton.DEFAULT_TYPE = 'default';;

/**
 * bar type
 * @name vs.ui.SegmentedButton.BAR_TYPE
 * @const
 */
SegmentedButton.BAR_TYPE = 'bar';;

/** 
 * Horizontal constant to configure a SegmentedButton.
 * <p/>A SegmentedButton can be horizontal or vertical.
 * Set the orientation property with this constant for a horizontal SegmentedButton.
 * By default a SegmentedButton is horizontal.
 * @see vs.ui.SegmentedButton#orientation
 * @name vs.ui.SegmentedButton.HORIZONTAL
 * @const
 */
SegmentedButton.HORIZONTAL = 0;

/** 
 * Vertical constant to configure a SegmentedButton.
 * <p/>A SegmentedButton can be horizontal or vertical.
 * Set the orientation property with this constant for a vertical SegmentedButton.
 * By default a SegmentedButton is horizontal.
 * @see vs.ui.SegmentedButton#orientation
 * @name vs.ui.SegmentedButton.VERTICAL
 * @const
 */
SegmentedButton.VERTICAL = 1;

SegmentedButton.prototype = {
  
  /*****************************************************************
   *               private/protected members
   ****************************************************************/
   
  /**
   *
   * @protected
   * @type {number}
   */
  _type: SegmentedButton.DEFAULT_TYPE,

  /**
   *
   * @protected
   * @type {number}
   */
  _is_toggle_buttons: true,

  /**
   *
   * @protected
   * @type {array.<string>}
   */
  _items: null,

  /**
   *
   * @protected
   * @type {number}
   */
  _selected_index: -1,

  /**
   *
   * @private
   * @type {array.<HtmlDivElement>}
   */
  _div_list: null,

  /**
   * SegmentedButton orientation (0: horizontal, 1: vertical)
   * @protected
   * @type {number}
   */
  _orientation : SegmentedButton.HORIZONTAL,

  /*****************************************************************
   *               General methods
   ****************************************************************/
    
  /**
   * @protected
   * @function
   */
  destructor : function ()
  {
    this._cleanButtons ();
    View.prototype.destructor.call (this);
  },

  /**
   * @protected
   * @function
   */
  _cleanButtons : function (v)
  {
    if (!this.view) { return; }
    
    util.removeAllElementChild (this.view);
    
    while (this._div_list.length)
    {
      var div = this._div_list [0];
      vs.removePointerListener (div, core.POINTER_START, this);
      
      this._div_list.remove (0);
    }
  },
  
  /**
   * @protected
   * @function
   */
  _renderButtons : function (v)
  {
    if (!this.view) { return; }
    
    this._cleanButtons ();
    var width = "";
    var os_device = window.deviceConfiguration.os;
    if (this._items.length && os_device == DeviceConfiguration.OS_WP7)
      width = Math.floor (100 / this._items.length);
      
    var subView = document.createElement ('div');
    this.view.appendChild (subView)
    
    for (var i = 0, l = this._items.length; i < l; i++)
    {
      var div = document.createElement ('div');
      div._index = i;
      util.setElementInnerText (div, this._items [i]);
      
      // WP7 does not manage box model (then use inline-block instead of)
      if (width) util.setElementStyle (div, {"width": width + '%'});

      vs.addPointerListener (div, core.POINTER_START, this);
      
      this._div_list.push (div);
      subView.appendChild (div);
    }
    this.orientation = this._orientation;
  },
  
  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    View.prototype.initComponent.call (this);
    this._items = new Array ();
    this._div_list = new Array ();

    this._renderButtons ();
    this.selectedIndex = this._selected_index;
    this.type = this._type;
  },
  
  /**
   * @protected
   * @function
   */
  handleEvent: function (e)
  {
    var target;
    if (e.type === core.POINTER_START)
    {
      // prevent multi touch events
      if (e.nbPointers > 1) { return; }
      
      // hack to retrieve the correct source (the bug occurs on iOS)
      target = e.target;
      if (!target.tagName)
      {
        target = target.parentElement;
      }
      if (this._selected_index === target._index)
      { return false; }
      
      e.stopPropagation ();
      e.preventDefault ();

      this.selectedIndex = target._index;
      this.propagate ('select', {
        index: this._selected_index,
        item: this._items [this._selected_index]
      });
      
      this.outPropertyChange ();
      
      return false;
    }
  }
};
util.extendClass (SegmentedButton, View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (SegmentedButton, {
  'items': {
    /** 
     * Getter|Setter for text. Allow to get or change the text draw
     * by the button
     * @name vs.ui.SegmentedButton#text 
     * @type String
     */ 
    set : function (v)
    {
      var i, l;
      if (!util.isArray (v) || !v.length) { return; }
      
      this._items.removeAll ();
      for (var i = 0, l = v.length; i < l; i++)
      {
        if (!v [i]) { continue; }
        
        this._items.push (v [i].toString ());
      }
      
      this._renderButtons ();
      if (this._is_toggle_buttons) this.selectedIndex = this._selected_index;
    },
  
    /** 
     * @ignore
     * @return {string}
     */ 
    get : function ()
    {
      return this._text;
    }
  },
  'selectedIndex': {
    /** 
     * Getter|Setter for select one of button
     * @name vs.ui.SegmentedButton#selectedIndex 
     * @type number
     */ 
    set : function (v)
    {
      if (!util.isNumber (v)) { return; }
      if (v < 0 || v >= this._div_list.length) { return; }
          
      var div = this._div_list [this._selected_index];
      if (div)
      {
        util.removeClassName (div, 'selected'); 
      }
      
      this._selected_index = v;
      var div = this._div_list [this._selected_index];
      if (div)
      {
        util.addClassName (div, 'selected'); 
      }
      if (!this._is_toggle_buttons)
      {
        var self = this;
        this.__button_time_out = setTimeout (function ()
        {
          util.removeClassName (div, 'selected');
          self.__button_time_out = 0;
          self._selected_index = -1;
        }, View.UNSELECT_DELAY);
      }
    },
  
    /** 
     * @ignore
     * @return {number}
     */ 
    get : function ()
    {
      return this._selected_index;
    }
  },
  'type': {
    /** 
     * Getter|Setter for the widget type (for instance default, bar, ...)
     * @name vs.ui.SegmentedButton#type 
     * @type {string}
     */ 
    set : function (v)
    {
      if (!util.isString (v)) { return; }
      if (this._type)
      {
        this.removeClassName (this._type);
      }
      this._type = v;
      this.addClassName (this._type);
    },
  
    /** 
     * @ignore
     * @return {string}
     */ 
    get : function ()
    {
      return this._type;
    }
  },
  'isToggleButtons': {
    /** 
     * Getter|Setter to configure the buttons as toggle buttons or not.
     * By default SegmentedButton are toggle buttons
     * @name vs.ui.SegmentedButton#isToggleButtons 
     * @type {boolean}
     */ 
    set : function (v)
    {
      if (v) this._is_toggle_buttons = true;
      else this._is_toggle_buttons = false;
    },
  
    /** 
     * @ignore
     * @return {string}
     */ 
    get : function ()
    {
      return this._is_toggle_buttons;
    }
  },
  'orientation':{
    /**
     * Property to configure the SegmentedButton orientation.
     * <p/>A SegmentedButton can be horizontal or vertical.
     *  Use the vs.ui.SegmentedButton.HORIZONTAL
     * or vs.ui.SegmentedButton.VERTICAL constant to configure the
     * SegmentedButton.
     * <p/>By default a SegmentedButton is horizontal.
     * @name vs.ui.SegmentedButton#orientation 
     * @type number
     */
    set : function (v)
    {
      if (v !== SegmentedButton.HORIZONTAL && v !== SegmentedButton.VERTICAL)
      { return; }
      
      this._orientation = v;
      
      if (this._orientation === 0)
      {
        this.removeClassName ('vertical');
        this.addClassName ('horizontal');
      }
      else
      {
        this.addClassName ('vertical');
        this.removeClassName ('horizontal');
      }
    },
  
    /**
     * @ignore
     */
    get : function ()
    {
      return this._orientation;
    }
  }
});
/********************************************************************
                      Export
*********************************************************************/
/** @private */
ui.SegmentedButton = SegmentedButton;

View.prototype.html_template = "\
<div class='vs_ui_view' x-hag-hole='children'></div>\
";

SplitView.prototype.html_template = "\
<div class='vs_ui_splitview'>\
  <div x-hag-hole='second_panel'></div>\
  <div x-hag-hole='main_panel'></div>\
</div>\
";

ScrollView.prototype.html_template = "\
<div class='vs_ui_scrollview'>\
  <div x-hag-hole='top_bar'></div>\
  <div class='content' x-hag-hole='children'></div>\
  <div x-hag-hole='bottom_bar'></div>\
</div>\
";

ScrollImageView.prototype.html_template = "\
<div class='vs_ui_scrollimageview'><img class='content'/></div>\
";

TextArea.prototype.html_template = "\
<textarea class='vs_ui_textarea'></textarea>\
";

Button.prototype.html_template = "\
<div class='vs_ui_button'><div></div></div>\
";

List.prototype.html_template = "\
<div class='vs_ui_list'><ul x-hag-hole='item_children'/></div>\
";

NavigationBar.prototype.html_template = "\
<div class='vs_ui_navigationbar' x-hag-hole='children'></div>\
";

ToolBar.prototype.html_template = "\
<div class='vs_ui_toolbar'>\
  <div x-hag-hole='children'></div>\
</div>\
";

Canvas.prototype.html_template = "\
<div class='vs_ui_canvas'><canvas class='canvas_inner'></canvas></div>\
";

ProgressBar.prototype.html_template = "\
<div class='vs_ui_progressbar'><div></div></div>\
";

TextLabel.prototype.html_template = "\
<div class='vs_ui_textlabel'></div>\
\
";

RadioButton.prototype.html_template = "\
<div class='vs_ui_radiobutton'><fieldset x-hag-hole='item_children' /></div>\
";

ComboBox.prototype.html_template = "\
<div class='vs_ui_combobox'></div>\
";

CheckBox.prototype.html_template = "\
<div class='vs_ui_checkbox'><fieldset x-hag-hole='item_children' /></div>\
";

Slider.prototype.html_template = "\
<div class='vs_ui_slider'><div class='handle'></div></div>\
";

ImageView.prototype.html_template = "\
<img class='vs_ui_imageview'></img>\
";

InputField.prototype.html_template = "\
<div class='vs_ui_inputfield'><input type='text' value='' placeholder='type ...' incremental='incremental'/><div class='clear_button'/>\
</div>\
";

PopOver.prototype.html_template = "\
<div class='vs_ui_popover'>\
  <div class='header' x-hag-hole='header'></div>\
  <div class='center' x-hag-hole='children'></div>\
  <div class='footer' x-hag-hole='footer'></div>\
  <div class='arrow'></div>\
</div>\
";

Switch.prototype.html_template = "\
<div class='vs_ui_switch'>\
  <div>\
    <div class='toggle_on'></div>\
    <div class='toggle_off'></div> \
    <div class='switch'></div> \
  </div>\
</div>\
";

Picker.prototype.html_template = "\
<div class='vs_ui_picker'>\
  <div class='slots'></div>\
  <div class='frame'></div>\
</div>\
";

SegmentedButton.prototype.html_template = "\
<div class='vs_ui_segmentedbutton'></div>\
";

SVGView.prototype.html_template = "\
<div class='vs_ui_svgview'></div>\
";
util.defineProperty (document, 'preventScroll', {
  get : function ()
  {
    return document._preventScroll;
  },
  
  set : function (preventScroll)
  {
    document._preventScroll = preventScroll;
    if (preventScroll)
    {
      // for android
      document.addEventListener ("touchstart", preventBehavior, false);
      // for android and other
      document.addEventListener ("touchmove", preventBehavior, false);
      document.addEventListener ("scroll", preventBehavior, false);
      window.scrollTo (0, 0);
    }
    else
    {
      // for android
      document.removeEventListener ("touchstart", preventBehavior, false);
      // for android and other
      document.removeEventListener ("touchmove", preventBehavior, false);
      document.removeEventListener ("scroll", preventBehavior, false);
    }
  }
});

})(window);/** @license
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

(function (window, undefined) {

var document = window.document;

/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/********************************************************************
                   
*********************************************************************/
/** @private */
var vs = window.vs,
  util = vs.util,
  core = vs.core,
  ui = vs.ui,
  fx = vs.fx,
  setElementTransform = util.setElementTransform,
  getElementTransform = util.getElementTransform,
  SUPPORT_3D_TRANSFORM = vs.SUPPORT_3D_TRANSFORM;
  
vs.CSS_VENDOR

function createProperty (name)
{
  if (!vs.CSS_VENDOR) return name;
  return '-' + vs.CSS_VENDOR.toLowerCase () + '-' + name;
}

/** 
 * CSS property specifies the length of time that an animation should take to
 * complete one cycle
 * @name vs.ANIMATION_DURATION
 * @type {String}
 * @const
 */ 
var ANIMATION_DURATION = createProperty ("animation-duration");

/** 
 * CSS property specifies when the animation should start. This lets the
 * animation sequence begin some time after it's applied to an element
 * @name vs.ANIMATION_DELAY
 * @type {String}
 * @const
 */ 
var ANIMATION_DELAY = createProperty ("animation-delay");

/** 
 * CSS property specifies a list of animations that should be applied to the
 * selected element.
 * @name vs.ANIMATION_NAME
 * @type {String}
 * @const
 */ 
var ANIMATION_NAME = createProperty ("animation-name");

/** 
 * CSS property specifies how a CSS animation should progress over the duration
 * of each cycle
 * @name vs.ANIMATION_TIMING_FUNC
 * @type {String}
 * @const
 */ 
var ANIMATION_TIMING_FUNC = createProperty ("animation-timing-function");

/** 
 * CSS property specifies how a CSS animation should apply styles to its target
 * before and after it is executing.
 * @name vs.ANIMATION_FILL_MODE
 * @type {String}
 */ 
var ANIMATION_FILL_MODE = createProperty ("animation-fill-mode");


/** 
 * CSS property specifies the number of seconds or milliseconds a transition
 * animation should take to complete
 * @name vs.TRANSITION_DURATION
 * @type {String}
 * @const
 */ 
var TRANSITION_DURATION = createProperty ("transition-duration");

/** 
 * CSS property specifies the length of time that an animation should take to
 * complete one cycle
 * @name vs.TRANSITION_DELAY
 * @type {String}
 * @const
 */ 
var TRANSITION_DELAY = createProperty ("transition-delay");

/** 
 * CSS property specifies the amount of time to wait between a change bein
 * requested to a property that is to be transitioned and the start of the
 * transition effect
 * @name vs.TRANSITION_TIMING_FUNC
 * @type {String}
 * @const
 */ 
var TRANSITION_TIMING_FUNC = createProperty ("transition-timing-function");

/** 
 * CSS property is used to specify the names of CSS properties to which a
 * transition effect should be applied
 * @name vs.TRANSITION_PROPERTY
 * @type {String}
 * @const
 */ 
var TRANSITION_PROPERTY = createProperty ("transition-property");


/** 
 * CSS property lets you modify the origin for transformations of an element.
 * @name vs.TRANSFORM_ORIGIN
 * @type {String}
 * @const
 */ 
var TRANSFORM_ORIGIN = createProperty ("transform-origin");

/** 
 * CSS property defines the number of times an animation cycle should be played
 * before stopping
 * @name vs.ITERATION_COUNT
 * @type {String}
 * @const
 */ 
var ITERATION_COUNT = createProperty ("animation-iteration-count");

/** 
 * CSS property lets you modify the coordinate space of the CSS visual
 * formatting model
 * @name vs.TRANSFORM
 * @type {String}
 * @const
 */ 
var TRANSFORM = createProperty ("transform");

/** 
 * CSS at-rule lets authors control the intermediate steps in a CSS animation
 * sequence
 * @name vs.KEY_FRAMES
 * @type {String}
 * @const
 */ 
var KEY_FRAMES = createProperty ("keyframes");


/** 
 * The vs.ANIMATION_END event is fired when a CSS animation has completed.
 * @name vs.ANIMATION_END
 * @type {String}
 */ 
var ANIMATION_END = "animationend";

/** 
 * The vs.TRANSITION_END event is fired when a CSS transition has completed
 * @name vs.TRANSITION_END
 * @type {String}
 */ 
var TRANSITION_END = "transitionend";

if (vs.CSS_VENDOR === 'webkit')
{
  ANIMATION_END = "webkitAnimationEnd";
  TRANSITION_END = "webkitTransitionEnd";
}  
else if (vs.CSS_VENDOR === 'ms')
{
  ANIMATION_END = "msAnimationEnd";
  TRANSITION_END = "msTransitionEnd";
}  
else if (vs.CSS_VENDOR === 'moz')
{
  ANIMATION_END = "Mozanimationend";
  TRANSITION_END = "Moztransitionend";
}

util.extend (vs, {
  ANIMATION_DURATION:        ANIMATION_DURATION,
  ANIMATION_DELAY:           ANIMATION_DELAY,
  ANIMATION_NAME:            ANIMATION_NAME,
  ANIMATION_TIMING_FUNC:     ANIMATION_TIMING_FUNC,
  ANIMATION_FILL_MODE:       ANIMATION_FILL_MODE,

  TRANSITION_DURATION:       TRANSITION_DURATION,
  TRANSITION_PROPERTY:       TRANSITION_PROPERTY,
  TRANSITION_DELAY:          TRANSITION_DELAY,
  TRANSITION_TIMING_FUNC:    TRANSITION_TIMING_FUNC,

  TRANSFORM_ORIGIN:          TRANSFORM_ORIGIN,
  ITERATION_COUNT:           ITERATION_COUNT,
  TRANSFORM:                 TRANSFORM,
  KEY_FRAMES:                KEY_FRAMES,

  ANIMATION_END:             ANIMATION_END,
  TRANSITION_END:            TRANSITION_END
});
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and
  contributors. All rights reserved

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @private
 * @const
 */
var AnimationWidthRegExp = new RegExp (/\$width/g);
/**
 * @private
 * @const
 */
var AnimationHeightRegExp = new RegExp (/\$height/g);
/**
 * @private
 * @const
 */
var AnimationXRegExp = new RegExp (/\$x/g);
/**
 * @private
 * @const
 */
var AnimationYRegExp = new RegExp (/\$y/g);
/**
 * @private
 * @const
 */
var AnimationVariableRegExp = new RegExp (/\$\{([\w]+)\}/g);

/**
 *  Cancel a playing animation
 * @name vs.fx.cancelAnimation
 * @param {String} id the animation id return par vs.fx.Animation.process ();
 */
function cancelAnimation (anim_id)
{
  if (!anim_id) { return false; }
  var anim_name, cssAnimation, anim_id, data;

  data = Animation.__css_animations [anim_id];
  if (data && data.length === 2)
  {
    if (!data[1] || !data[1].getStyle || !data [0]) { return false; }

    anim_name = data[1].getStyle (ANIMATION_NAME);
    if (!anim_name) { return false; }

    anim_name = anim_name.replace (anim_id, '');
    data[1].setStyle (ANIMATION_NAME, anim_name);

    try {
      document.getElementsByTagName("head")[0].removeChild (data [0]);
    }
    catch (e)
    {
      if (e.stack) console.log (e.stack)
      console.error (e);
      return false;
    }
    delete (Animation.__css_animations [anim_id]);
  }
  else { return false; }

  return true;
}

/**
 *  @private
 *
 * @param {vs.fx.View} comp the component the view will be animated
 * @param {vs.fx.Animation} animation the animation
 * @param {Function} clb an optional callback to call at the end of animation
 * @param {Object} ctx an optional execution context associated to the clb
 * @return {String} return the identifier of the animation process. You can
 *       use it to stop the animation for instance.
 */
var procesAnimation = function (comp, animation, clb, ctx, now)
{
  if (!animation || !comp || !comp.view)
  {
    console.error ('procesAnimation: invalid component parameter!');
    return;
  }

  function parseValue (v, data) {
    var matches, i, props = [], prop;

    if (util.isNumber (v)) { return v; }

    if (util.isString (v))
    {
      v = v.replace (AnimationWidthRegExp, comp.size [0] + 'px');
      v = v.replace (AnimationHeightRegExp, comp.size [1] + 'px');
      v = v.replace (AnimationXRegExp, comp.position [0] + 'px');
      v = v.replace (AnimationYRegExp, comp.position [1] + 'px');

      var matches = AnimationVariableRegExp.exec (v);
      while (matches && matches.length === 2)
      {
        props.push (matches [1]);
        matches = AnimationVariableRegExp.exec (v);
      }
      for (var i = 0; i < props.length; i++)
      {
        prop = props [i];
        if (typeof data[prop] !== 'undefined')
        { v = v.replace ('${' + prop + '}', data[prop]); }
        else if (typeof animation[prop] !== 'undefined')
        { v = v.replace ('${' + prop + '}', animation[prop]); }
      }

      return v;
    }

    console.warn
      ("vs.fx.Animation._parseValue. Unknown value's type: " + v);
    return 0;
  };

  function cloneParams (animation)
  {
    var params = {}, key, data;

    if (animation.properties) {
      params.properties = animation.properties.slice ();
    }
    else {
      params.properties = [];
    }
    if (animation.values) {
      params.values = animation.values.slice ();
    }
    else {
      params.values = [];
    }
    if (animation.durations) {
      params.durations = animation.durations;
    }
    if (animation.timings) {
      params.timings = animation.timings.slice ();
    }
    else {
      params.timings = [];
    }
    if (animation.origin) {
      params.origin = animation.origin.slice ();
    }

    params.iterationCount = animation.iterationCount;
    params.delay = animation.delay;
    params.additive = animation.additive;

    params.keyFrames = {};
    if (!animation.keyFrames ['100%']) {
      animation.keyFrames ['100%'] = animation;
    }

    var new_data;
    for (key in animation.keyFrames)
    {
      data = animation.keyFrames [key];
      if (util.isArray (data)) {
        new_data = [];
        for (var i = 0; i < data.length; i++)
        {
          value = data [i];
          if (value == null || typeof value == 'undefined') continue;
          new_data [i] = parseValue (value, animation);
        }
        params.keyFrames [key] = new_data;
      }
      else
      {
        for (i = 0; i < animation.properties.length; i++){
          params.values [i] = parseValue (animation.values [i], data);
        }
        params.keyFrames [key] = {};
      }
    }

    return params;
  }

  var anim_params = cloneParams (animation);
  
  return _procesAnimation (comp, animation, anim_params, clb, ctx, now);
};

/**
 *  @private
 *
 * @param {vs.fx.View} comp the component the view will be animated
 * @param {Object} anim_params the animation's parameters copy
 * @param {vs.fx.Animation} animation the animation
 * @param {Function} clb an optional callback to call at the end of animation
 * @param {Object} ctx an optional execution context associated to the clb
 * @return {String} return the identifier of the animation process. You can
 *       use it to stop the animation for instance.
 */
var _procesAnimation = function (comp, animation, anim_params, clb, ctx, now)
{
  if (!anim_params || !comp || !comp.view)
  {
    console.error ('procesAnimation: invalid component parameter!');
    return;
  }

  function isComplexAnimation ()
  {
    if (anim_params.keyFrames ['0%']) { return true; }
    return false;
  }

  var
    cssAnimation, anim_id = core.createId (),
    isComplex = isComplexAnimation (),
    forceCallback = false, self = this;

  function initWithParameters ()
  {
    var property;
    if (isComplex)
    { property = ANIMATION_DURATION; }
    else { property = TRANSITION_DURATION; }

    if (util.isArray (anim_params.origin) && anim_params.origin.length === 2)
    {
      var value = anim_params.origin [0] + '% ' + anim_params.origin [1] + '%';
      comp.setStyle (TRANSFORM_ORIGIN, value);
    }

    if (now)
    {
      comp.setStyle (property, 0);
    }
    else if (util.isString (anim_params.durations))
    {
      comp.setStyle (property, anim_params.durations);
    }
    else if (util.isArray (anim_params.durations))
    {
      comp.setStyle (property, anim_params.durations.join (', '));
    }
    else
    {
      comp.setStyle (property, Animation.DEFAULT_DURATION);
    }

    if (isComplex) { property = ANIMATION_DELAY; }
    else { property = TRANSITION_DELAY; }

    if (!now && util.isNumber (anim_params.delay))
    {
      comp.setStyle (property, anim_params.delay + 'ms');
    }
    else
    { comp.setStyle (property, '0'); }

    if (isComplex) property = ANIMATION_TIMING_FUNC;
    else property = TRANSITION_TIMING_FUNC;

    if (util.isString (anim_params.timings))
    {
      comp.setStyle (property, anim_params.timings);
    }
    else if (util.isArray (anim_params.timings))
    {
      comp.setStyle (property, anim_params.timings.join (', '));
    }
    else
    {
      comp.setStyle (property, Animation.EASE);
    }

    if (isComplex)
    {
      if (anim_params.iterationCount === 'infinite')
      {
        comp.setStyle (ITERATION_COUNT, 'infinite');
      }
      else if (!anim_params.iterationCount ||
               !util.isNumber (anim_params.iterationCount))
      {
        comp.setStyle (ITERATION_COUNT, '1');
      }
      else
      {
        comp.setStyle (ITERATION_COUNT, anim_params.iterationCount);
      }
      
      comp.setStyle (ANIMATION_FILL_MODE, "forwards");
    }
  };

  function applySimpleAnimation ()
  {
    initWithParameters ();
    var callback, i, dur;

    callback = function (event)
    {
      // do nothing if that event just bubbled from our target's sub-tree
      if (event.currentTarget !== comp.view) { return; }

      if (!forceCallback)
        comp.view.removeEventListener (TRANSITION_END, callback, false);

      // clear transition parameters
      comp.view.style.removeProperty (TRANSITION_DURATION);
      comp.view.style.removeProperty (TRANSITION_DELAY);

      if (animation.delegate && animation.delegate.taskDidEnd) {
        try {
          animation.delegate.taskDidEnd (anim_params)
        }
        catch (e) {
          if (e.stack) console.log (e.stack)
          console.error (e);
        }
      }

      if (clb) { clb.call (ctx?ctx:self); }
    }

    // if durations is egal to 0, no event is generated a the end.
    // Then use a small time
    dur = parseFloat (comp.view.style.getPropertyValue (TRANSITION_DURATION));
    if (now || dur === 0) forceCallback = true;

    if (!forceCallback)
      comp.view.addEventListener (TRANSITION_END, callback, false);
    else vs.scheduleAction (function () {
      callback ({currentTarget: comp.view});
    });

    applyStyleTo ();
  };

  function applyStyleTo ()
  {
    var
      transform = '',
      property, properties = [], value;

    for (i = 0; i < anim_params.properties.length; i++)
    {
      property = anim_params.properties [i];
      value = anim_params.values [i];
      if (property === 'rotate')
      { transform += 'rotate(' + value + ') '; property = TRANSFORM;}
      else if (property === 'skew')
      { transform += 'skew(' + value + ') '; property = TRANSFORM;}
      else if (SUPPORT_3D_TRANSFORM && property === 'translate')
      { transform += 'translate3d(' + value + ') '; property = TRANSFORM;}
      else if (property === 'translate')
      { transform += 'translate(' + value + ') '; property = TRANSFORM;}
      else if (property === 'translateX')
      { transform += 'translateX(' + value + ') '; property = TRANSFORM;}
      else if (property === 'translateY')
      { transform += 'translateY(' + value + ') '; property = TRANSFORM;}
      else if (property === 'rotateX')
      { transform += 'rotateX(' + value + ') '; property = TRANSFORM;}
      else if (property === 'rotateY')
      { transform += 'rotateY(' + value + ') '; property = TRANSFORM;}
      else if (property === 'scale')
      { transform += 'scale(' + value + ') '; property = TRANSFORM;}
      else
      { comp.setStyle (property, value); }

      if (properties.indexOf (property) == -1) properties.push (property);
    }
    if (transform)
    {
      if (anim_params.additive) {
        var matrix = comp.getCTM ();
        transform = matrix.toString () + ' ' + transform;
      }
      setElementTransform (comp.view, transform);
    }

    comp.setStyle (TRANSITION_PROPERTY, properties.join (','));
  }

  function runComplexAnimation ()
  {
    initWithParameters ();

    var i, callback, value, anim_name, dur,

    callback = function (event)
    {
      // do nothing if that event just bubbled from our target's sub-tree
      if (event.currentTarget !== comp.view) { return; }

      if (!forceCallback)
        comp.view.removeEventListener (ANIMATION_END, callback, false);

      // apply the last state
      if (isComplex) { applyStyleTo (); }

      // clear animations parameters
      comp.view.style.removeProperty (ANIMATION_DURATION);
      comp.view.style.removeProperty (ANIMATION_DELAY);

      // clean the animation
      anim_name = comp.getStyle (ANIMATION_NAME);
      if (anim_name)
      {
        anim_name = anim_name.replace (anim_id, '');
        comp.setStyle (ANIMATION_NAME, anim_name);
      }

      try
      {
        data = Animation.__css_animations [anim_id];
        if (data && data.length === 2)
        {
          document.getElementsByTagName("head")[0].removeChild (data [0]);
          delete (Animation.__css_animations [anim_id]);
        }
      }
      catch (e)
      {
        if (e.stack) console.log (e.stack)
        console.error (e);
        return false;
      }

      if (animation.delegate && animation.delegate.taskDidEnd) {
        try {
          animation.delegate.taskDidEnd (anim_params)
        }
        catch (e) {
          if (e.stack) console.log (e.stack)
          console.error (e);
        }
      }

      if (clb) { clb.call (ctx?ctx:self); }
    }

    // if durations is egal to 0, no event is generated a the end.
    // Then use a small time
    dur = parseFloat (comp.view.style.getPropertyValue (ANIMATION_DURATION));
    if (now || dur === 0) forceCallback = true;

    if (!forceCallback)
      comp.view.addEventListener (ANIMATION_END, callback, false);
    else vs.scheduleAction (function () {
      callback ({currentTarget: comp.view});
    });

    anim_name = comp.getStyle (ANIMATION_NAME);

    if (!anim_name) { anim_name = anim_id; }
    else { anim_name += ', ' + anim_id; }

    comp.setStyle (ANIMATION_NAME, anim_name);
  }

  function applyComplexAnimation ()
  {
    var data, key, style, i, property, transform, value,
    cssAnimation = document.createElement('style');
    cssAnimation.type = 'text/css';

    var rules_str = '';
    for (key in anim_params.keyFrames)
    {
      transform = '';
      data = anim_params.keyFrames [key];
      style = '';
      if (util.isArray (data))
      {
        for (var i = 0; i < data.length; i++)
        {
          value = data [i];
          if (value == null || typeof value == 'undefined') continue;
          property = anim_params.properties [i];
          if (!property) { continue; }
          if (property === 'rotate')
          { transform += 'rotate(' + value + ') '; }
          else if (property === 'skew')
          { transform += 'skew(' + value + ') '; }
          else if (SUPPORT_3D_TRANSFORM && property === 'translate')
          { transform += 'translate3d(' + value + ') '; }
          else if (property === 'translate')
          { transform += 'translate(' + value + ') '; }
          else if (property === 'translateX')
          { transform += 'translateX(' + value + ') '; }
          else if (property === 'translateY')
          { transform += 'translateY(' + value + ') '; }
          else if (property === 'rotateX')
          { transform += 'rotateX(' + value + ') '; }
          else if (property === 'rotateY')
          { transform += 'rotateY(' + value + ') '; }
          else if (property === 'scale')
          { transform += 'scale(' + value + ') '; }
          else if (property === 'perspective')
          { transform += 'perspective(' + value + ') '; }
          else
          { style += property + ':' + value + ';'; }
        }
      }
      else
      {
        for (i = 0; i < anim_params.properties.length; i++)
        {
          value = anim_params.values [i];
          property = anim_params.properties [i];
          if (!property) { continue; }
          if (property === 'rotate')
          { transform += 'rotate(' + value + ') '; }
          else if (property === 'skew')
          { transform += 'skew(' + value + ') '; }
          else if (SUPPORT_3D_TRANSFORM && property === 'translate')
          { transform += 'translate3d(' + value + ') '; }
          else if (property === 'translate')
          { transform += 'translate(' + value + ') '; }
          else if (property === 'translateX')
          { transform += 'translateX(' + value + ') '; }
          else if (property === 'translateY')
          { transform += 'translateY(' + value + ') '; }
          else if (property === 'rotateX')
          { transform += 'rotateX(' + value + ') '; }
          else if (property === 'rotateY')
          { transform += 'rotateY(' + value + ') '; }
          else if (property === 'scale')
          { transform += 'scale(' + value + ') '; }
          else if (property === 'perspective')
          { transform += 'perspective(' + value + ') '; }
          else
          { style += property + ':' + value + ';'; }
        }
      }
      if (transform)
      {
        if (anim_params.additive) {
          var matrix = comp.getCTM ();
          transform = matrix.toString () + ' ' + transform;
        }
        style += TRANSFORM + ': ' + transform + ';';
      }

      rules_str += key + ' { ' + style + ' } ';
    }

    var rules = document.createTextNode
      ('@' + KEY_FRAMES + ' ' + anim_id + ' { ' + rules_str + ' }');

    cssAnimation.appendChild (rules);
    document.getElementsByTagName("head")[0].appendChild(cssAnimation);

    Animation.__css_animations [anim_id] = [cssAnimation, comp];

    runComplexAnimation ();
  }

  if (isComplex) { vs.scheduleAction (applyComplexAnimation); }
  else { vs.scheduleAction (applySimpleAnimation); }

  return anim_id;
};

/**
 *  @class
 *  An vs.fx.Animation object, contains information for animate a vs.fx.View
 *  component.
 *  <p>
 *  It specifies the css properties to animate and the values for each
 *  properties.
 *  You can define one transformation or a set of transformation
 *  for your animation. In case of multiple transformation the developer
 *  an specify a duration for each transformation.
 *  <p>
 *  <u>Predefined animations</u>: {@link vs.fx.TranslateAnimation},
 *  {@link vs.fx.RotateAnimation}, {@link vs.fx.RotateXYZAnimation},
 *  {@link vs.fx.ScaleAnimation}, {@link vs.fx.SkewAnimation}
 *
 *  @see vs.fx.TranslateAnimation
 *  @see vs.fx.RotateAnimation
 *  @see vs.fx.RotateXYZAnimation
 *  @see vs.fx.ScaleAnimation
 *  @see vs.fx.SkewAnimation
 *
 *  @example
 *  // animate with a constant
 *  a = new vs.fx.Animation (['rotate', '30deg']);​
 *  a.process (comp);
 *
 *  // animate with a predefined variable
 *  a = new vs.fx.Animation (['translate', '$width']);​
 *  a.process (comp);
 *
 *  // animate with a generic variable
 *  a = new vs.fx.Animation (['rotate', '${r}deg']);​
 *  a.r = 50;
 *  a.process (comp);
 *
 * @example
 * // example of multiple transformations an durations
 * // define a animation with two transformations
 * animation = new vs.fx.Animation ([‘width’, '100px'], ['opacity', '0'])
 * // set duration for each
 * animation.durations = ['1s', '2s'];
 *
 * @example
 * // Defining a complex animation with key frames"
 * var translate = new vs.fx.TranslateAnimation (130, 150);
 * translate.durations = '3s';
 * translate.iterationCount = 3;
 *
 * translate.addKeyFrame ('from', {x:0, y: 0, z:0});
 * translate.addKeyFrame (20, {x:50, y: 0, z: 0});
 * translate.addKeyFrame (40, {x:50, y: 50, z: 0});
 *
 * translate.process (myObject);
 *
 *  @author David Thevenin
 * @name vs.fx.Animation
 *  @extends vs.core.Task
 *
 *  @constructor
 *  Main constructor
 *
 * @param {Array.<string>} animations The array of <property, value> to animate
*/
function Animation (animations)
{
  this.parent = core.Task;
  this.parent ();
  this.constructor = Animation;

  if (arguments.length)
  {
    this.setAnimations (arguments);
    this.keyFrames ['100%'] = this;
  }
};

/**
 * @private
 */
Animation.__css_animations = {};

Animation.DEFAULT_DURATION = '0.3s';
Animation.DEFAULT_TIMING = Animation.EASE;

Animation.prototype = {

  /**
   * The css properties to animate
   * @type {Array.<string>}
   * @name vs.fx.Animation#properties
   */
  properties: null,

  /**
   * The css values for each properties
   * @type {Array.<string>}
   * @name vs.fx.Animation#values
   */
  values: null,

  /**
   * The duration for each transformation. For setting only one duration,
   * use a string (ex anim.duration = '3s')
   * @type Array.<string>
   * @name vs.fx.Animation#durations
   */
  durations: null,

  /**
   * Specifies how the intermediate values used during a transition are
   * calculated. <p />Use the constants to specify preset points of the curve:
   * ({@link vs.fx.Animation.EASE},
   * {@link vs.fx.Animation.LINEAR}, {@link vs.fx.Animation.EASE_IN},
   * {@link vs.fx.Animation.EASE_OUT}, {@link vs.fx.Animation.EASE_IN_OUT})
   * or the cubic-bezier function to specify your own points.
   * <p />
   * Specifies a cubic Bézier curve : cubic-bezier(P1x,P1y,P2x,P2y) <br />
   * Parameters: <br />
   * - First point in the Bézier curve : P1x, P1y <br />
   * - Second point in the Bézier curve : P2x, P2y <br />
   *
   * @type Array.<string>
   * @name vs.fx.Animation#timings
   */
  timings: null,

  /**
   * Specifies the number of times an animation iterates.
   * The transformations establishes the origin for transforms applied to
   * your component with respect to its border box. By default the value
   * is 50%, 50%.
   * <p>The values is express as an array of percentages of the element’s size,
   * origin [0] => pos X, origin [1] => pos Y
   * @type {Array.<int>}
   * @name vs.fx.Animation#origin
   */
  origin: null,

  /**
   * Sets the origin for the transformations
   * By default it is set to 1.
   * For infinite interation, use 'infinite' value.
   * @type {{number | string}}
   * @name vs.fx.Animation#iterationCount
   */
  iterationCount: 1,

  /**
   * The time to begin executing an animation after it is applied. <br/>
   * If 0, the animation executes as soon as it is applied. <br/>
   * If positive, it specifies an offset from the moment the animation is
   * applied, and the animation delays execution by that offset. <br/>
   * If negative, the animation executes the moment the property changes but
   * appears to begin at the specified negative offset—that is, begins part-way
   * through the animation. <br/>
   * The unit is milliseconds.  <br/>
   * By default it is set to 0.
   * @type number
   * @name vs.fx.Animation#delay
   */
  delay: 0,

  /**
   * @private
   * @type Object
   * @name vs.fx.Animation#keyFrames
   */
  keyFrames: null,
  
  /**
   * An animation can manipulate the transform property. If you have applied
   * your own transformation to the component, then the animation transform
   * is added to the component's transformation.<br/>
   * But if want the component to use only the animation transformation, then
   * set up your animation with the property "additive" set to "false".<br/>
   * By default it is set to true.
   * @type boolean
   * @name vs.fx.Animation#additive
   */
  additive: true,

  /**
   *  Defines the properties to animate.
   *  <p>
   *  When you call the method you redefines your animation, and all
   *  animation options are set to default value.
   *
   * @example
   * // define a animation with two transformations
   * animation = new vs.fx.Animation ()
   * animation.setAnimations ([[‘width’, '100px'], ['opacity', '0']]);
   *
   * @name vs.fx.Animation#setAnimations
   * @function
   * @param {Array.<Array>} animations The array of [property, value]
   *         to animate
   */
  setAnimations : function (animations)
  {
    var i, prop, value, option;

    this.properties = [];
    this.values = [];
    this.timings = [];
    this.keyFrames = {};
    this.origin = null;
    this.durations = null;
    this.timings = null;

    for (i = 0 ; i < animations.length; i++)
    {
      option = animations [i];
      if (!util.isArray (option) || option.length !== 2)
      {
        console.warn ('vs.fx.Animation, invalid animations');
        continue;
      }
      prop = option [0]; value = option [1];
      if (!util.isString (prop) || !util.isString (value))
      {
        console.warn ('vs.fx.Animation, invalid constructor argument option: [' +
          prop + ', ' + value + ']');
        continue;
      }

      this.properties.push (prop);
      this.values.push (value);
    }
  },

  /**
   *  Add an animation Key frames.
   *  By default an animation does not have key frames. But you can
   *  define a complexe animation with key frames.
   *  <br />
   *  You have to define at least two key frames 'from' and 'to'.
   *  Other frames are define as percentage value of the animation.
   *  <p />
   *  @example
   *  var translate = new vs.fx.TranslateAnimation (130, 150);
   *
   *  translate.addKeyFrame ('from', {x:0, y: 0, z:0});
   *  translate.addKeyFrame (20, {x:50, y: 0, z: 0});
   *  translate.addKeyFrame (40, {x:50, y: 50, z: 0});
   *
   *  @example
   *  var translate = new vs.fx.Animation (['translateY','100px'],['opacity', '0']);
   *
   *  translate.addKeyFrame ('from', ['0px', '1']);
   *  translate.addKeyFrame (20, ['50px', '1']);
   *  translate.addKeyFrame (40, ['80px', '1']);
   *
   * @name vs.fx.Animation#addKeyFrame
   * @function
   * @param {string | number} pos The percentage value of animation
   * @param {Object | Array} values the object containing values for
   *         the animation
   */
  addKeyFrame : function (pos, values)
  {
    if (!values) { return; }
    if (pos === 'from')
    {
      this.keyFrames ['0%'] = values;
      return;
    }
    if (pos === 'to')
    {
      this.keyFrames ['100%'] = values;
      return;
    }
    if (!util.isNumber (pos) || pos < 0 || pos > 100) { return; }

    this.keyFrames [pos+'%'] = values;
  },

  /**
   *  Use this function for animate your graphic object.
   *  <p>
   *  You can set a callback function that will be call at the end of animation.
   *  Associated to the callback you can defined a runtime context. This context
   *  could be a object.
   *
   *  @example
   *  obj.prototype.endAnimation = function (event)
   *  { ... }
   *
   *  obj.prototype.animate = function ()
   *  {
   *    myAnimation.process (a_gui_object, this.endAnimation, this);
   *  }
   *
   * @name vs.fx.Animation#process
   * @function
   * @param {vs.fx.View} comp The component the view will be animated
   * @param {Function} clb an optional callback to call at the end of animation
   * @param {Object} ctx an optional execution context associated to the
   *          callback
   * @param {boolean} now an optional parameter use to apply a animation without
   *          delay or duration. It useful for configuring the initial position
   *          of UI component.
   * @return {String} return the identifier of the animation process. You can
   *       use it to stop the animation for instance.
   */
  process : function (comp, clb, ctx, now)
  {
    return procesAnimation (comp, this, clb, ctx, now);
  },

/********************************************************************
                  Task implementation
********************************************************************/

  /**
   * @name vs.core.Animation#_clone
   * @function
   * @private
   *
   * @param {vs.core.Object} obj The cloned object
   * @param {Object} map Map of cloned objects
   */
  _clone : function (obj, cloned_map)
  {
    core.Object.prototype._clone.call (this, obj, cloned_map);
    
    var key, data;
    obj.keyFrames = {};
    obj.keyFrames ['100%'] = obj;

    if (this.properties)
    { obj.properties = this.properties.slice (); }
    else { obj.properties = []; }
    if (this.values)
    { obj.values = this.values.slice (); }
    else { obj.values = []; }
    if (this.durations)
    { obj.durations = this.durations; }
    if (this.timings)
    { obj.timings = this.timings.slice (); }
    else { obj.timings = []; }
    if (this.origin)
    { obj.origin = this.origin.slice (); }
    if (this.keyFrames)
    {
      for (key in this.keyFrames)
      {
        if (key === '100%') { continue; }
        data = this.keyFrames [key];
        if (util.isArray (data)) { obj.keyFrames [key] = data.slice (); }
        else { obj.keyFrames [key] = vs.util.clone (data); }
      }
    }

    obj.iterationCount = this.iterationCount;
    obj.delay = this.delay;
  },

/********************************************************************
                  Task implementation
********************************************************************/

  /**
   *  Starts the task
   *
   * @name vs.fx.Animation#start
   * @function
   * @param {any} param any parameter (scalar, Array, Object)
   * @return {String} return the identifier of the animation process. You can
   *       use it to stop the animation for instance.
   */
  start: function (param)
  {
    return this.process (param);
  }
};
util.extendClass (Animation, core.Task);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (Animation, {
  'duration': {
    /**
     * Getter/Setter for animation duration
     * @name vs.fx.Animation#duration
     *
     * @type {String}
     */
    set : function (v)
    {
      if (!v) { return; }

      this.durations = [v];
    },

    /**
     * @ignore
     */
    get : function ()
    {
      if (this.durations && this.durations.length)
      { return this.durations [0]; }
      else
      { return Animation.DEFAULT_DURATION; }
    },
  },
  'timing': {
    /**
     * Getter/Setter for animation timing
     * @name vs.fx.Animation#timing
     *
     * @type {String}
     */
    set : function (v)
    {
      if (!v) { return; }

      this.timings = [v];
    },

    /**
     * @ignore
     */
    get : function ()
    {
      if (this.timings && this.timings.length)
      { return this.timings [0]; }
      else
      { return Animation.EASE; }
    }
  }
});

/*************************************************************
                Timing Function
*************************************************************/

/**
 * The ease timing function
 * Equivalent to cubic-bezier(0.25, 0.1, 0.25, 1.0)
 * @name vs.fx.Animation.EASE
 * @const
 */
Animation.EASE = 'ease'

/**
 * The linear timing function
 * Equivalent to cubic-bezier(0.0, 0.0, 1.0, 1.0)
 * @name vs.fx.Animation.LINEAR
 * @const
 */
Animation.LINEAR = 'linear'

/**
 * The ease in timing function
 * Equivalent to cubic-bezier(0.42, 0, 1.0, 1.0)
 * @name vs.fx.Animation.EASE_IN
 * @const
 */
Animation.EASE_IN = 'ease-in'

/**
 * The ease out timing function
 * Equivalent to cubic-bezier(0, 0, 0.58, 1.0)
 * @name vs.fx.Animation.EASE_OUT
 * @const
 */
Animation.EASE_OUT = 'ease-out'

/**
 * The ease in out timing function
 * Equivalent to cubic-bezier(0.42, 0, 0.58, 1.0)
 * @name vs.fx.Animation.EASE_IN_OUT
 * @const
 */
Animation.EASE_IN_OUT = 'ease-in-out'

/*************************************************************
                Specifics animations
*************************************************************/

/**
 *  @class
 *  Animation for translate a object view over x, y, and z axes.
 *  <p>
 *
 *  @example
 *  // declare the animation
 *  var translate = new vs.fx.TranslateAnimation (50, 50, 0);
 *  translate.process (comp);
 *
 *  // reconfigure the animation
 *  translate.x = 40;
 *  translate.y = 140;
 *  translate.process (comp);
 *
 *  @author David Thevenin
 * @name vs.fx.TranslateAnimation
 *
 *  @constructor
 *  Main constructor
 *  @extends vs.fx.Animation
 *
 * @param {number} x The translation value along the X axis
 * @param {number} y The translation value along the Y axis
 * @param {number} z The translation value along the Z axis if 3d css transform is possible
*/
TranslateAnimation = function (x, y, z)
{
  this.parent = Animation;
  if (!arguments.length)
  {
    this.parent ();
  }
  else
  {
    if (SUPPORT_3D_TRANSFORM)
      this.parent (['translate', '${x}px,${y}px,${z}px']);
    else
      this.parent (['translate', '${x}px,${y}px']);

    if (util.isNumber (x)) { this.x = x; }
    if (util.isNumber (y)) { this.y = y; }
    if (util.isNumber (z)) { this.z = z; }
  }
  this.constructor = TranslateAnimation;
}

TranslateAnimation.prototype = {

  /**
   * The translation value along the X axis
   * @public
   * @type {number}
   * @name vs.fx.TranslateAnimation#x
   */
  x: 0,

  /**
   * The translation value along the Y axis
   * @public
   * @type {number}
   * @name vs.fx.TranslateAnimation#y
   */
  y: 0,

  /**
   * The translation value along the Z axis
   * @public
   * @type {number}
   * @name vs.fx.TranslateAnimation#z
   */
  z: 0,
  
  /**
   * @name vs.core.TranslateAnimation#_clone
   * @function
   * @private
   *
   * @param {vs.core.Object} obj The cloned object
   * @param {Object} map Map of cloned objects
   */
  _clone : function (obj, cloned_map)
  {
    Animation.prototype._clone.call (this, obj, cloned_map);
    
    obj.x = this.x;
    obj.y = this.y;
    obj.z = this.z;    
  }
};
util.extendClass (TranslateAnimation, Animation);

/**
 *  @class
 *  Rotate your object any number of degrees along the Z axis.
 *  <p>
 *
 *  @example
 *  // declare the animation
 *  var rotation = new vs.fx.RotateAnimation (50);
 *  rotation.process (comp);
 *
 *  // reconfigure the animation
 *  rotation.deg = 40;
 *  rotation.process (comp);
 *
 *  @author David Thevenin
 * @name vs.fx.RotateAnimation
 *
 *  @constructor
 *  Main constructor
 *  @extends vs.fx.Animation
 *
 * @param {number} deg The rotation value along the Z axis
*/
RotateAnimation = function (deg)
{
  this.parent = Animation;
  if (!arguments.length)
  {
    this.parent ();
  }
  else
  {
    this.parent (['rotate', '${deg}deg']);

    if (util.isNumber (deg)) { this.deg = deg; }
  }
  this.constructor = RotateAnimation;
}

RotateAnimation.prototype = {

  /**
   * The rotation value along the Z axis
   * @public
   * @type {number}
   * @name vs.fx.RotateAnimation#deg
   */
  deg: 0,
  
  /**
   * @name vs.core.RotateAnimation#_clone
   * @function
   * @private
   *
   * @param {vs.core.Object} obj The cloned object
   * @param {Object} map Map of cloned objects
   */
  _clone : function (obj, cloned_map)
  {
    Animation.prototype._clone.call (this, obj, cloned_map);
    
    obj.deg = this.deg;    
  }
};
util.extendClass (RotateAnimation, Animation);

/**
 *  @class
 *  Rotate your object any number of degrees over the X, Y and Z axes.
 *  <p>
 *
 *  @example
 *  // declare the animation
 *  var rotation = new vs.fx.RotateXYZAnimation (50, 50, 10);
 *  rotation.process (comp);
 *
 *  @author David Thevenin
 * @name vs.fx.RotateXYZAnimation
 *
 *  @constructor
 *  Main constructor
 *  @extends vs.fx.Animation
 *
 * @param {number} degX The rotation value along the X axis
 * @param {number} degY The rotation value along the Y axis
 * @param {number} degZ The rotation value along the Z axis
*/
RotateXYZAnimation = function (degX, degY, degZ)
{
  this.parent = Animation;
  if (!arguments.length)
  {
    this.parent ();
  }
  else
  {
    this.parent (['rotateX', '${degX}deg'],
      ['rotateY', '${degY}deg'], ['rotate' ,'${degZ}deg']);

    if (util.isNumber (degX)) { this.degX = degX; }
    if (util.isNumber (degY)) { this.degY = degY; }
    if (util.isNumber (degZ)) { this.degZ = degZ; }
  }
  this.constructor = RotateXYZAnimation;
}

RotateXYZAnimation.prototype = {

  /**
   * The rotation value along the X axis
   * @public
   * @type {number}
   * @name vs.fx.RotateXYZAnimation#degX
   */
  degX: 0,

  /**
   * The rotation value along the Y axis
   * @public
   * @type {number}
   * @name vs.fx.RotateXYZAnimation#degY
   */
  degY: 0,

  /**
   * The rotation value along the Z axis
   * @public
   * @type {number}
   * @name vs.fx.RotateXYZAnimation#degZ
   */
  degZ: 0,
  
  /**
   * @name vs.core.RotateXYZAnimation#_clone
   * @function
   * @private
   *
   * @param {vs.core.Object} obj The cloned object
   * @param {Object} map Map of cloned objects
   */
  _clone : function (obj, cloned_map)
  {
    Animation.prototype._clone.call (this, obj, cloned_map);
    
    obj.degX = this.degX;
    obj.degY = this.degY;
    obj.degZ = this.degZ;    
  }
};
util.extendClass (RotateXYZAnimation, Animation);

/**
 *  @class
 *  Scale your object over the X and Y axes
 *  <p>
 *  If the second parameter is not provided, it is takes a value equal to
 *  the first.
 *
 *  @example
 *  // declare the animation
 *  var scale = new vs.fx.ScaleAnimation (0.5, 1);
 *  scale.process (comp);
 *
 *  @author David Thevenin
 *
 *  @constructor
 *  Main constructor
 *  @extends vs.fx.Animation
 *
 * @name vs.fx.ScaleAnimation
 * @param {number} sx The scale value along the X axis
 * @param {number} sy The scale value along the Y axis
 * @param {number} sz The scale value along the Z axis
*/
ScaleAnimation = function (sx, sy, sz)
{
  this.parent = Animation;
  if (!arguments.length)
  {
    this.parent ();
  }
  else
  {
    if (!util.isNumber (sy) && !util.isNumber (sy))
    {
      // scale on X and Y axies
      this.parent (['scale', '${sx}']);
      this.sx = sx;
      this.sy = sx;
    }
    else
    {
      this.parent (
        ['scaleX', '${sx}'], ['scaleY', '${sy}'], ['scaleZ' ,'${sz}']
      );

      if (util.isNumber (sx)) { this.sx = sx; }
      if (util.isNumber (sy)) { this.sy = sy; }
      if (util.isNumber (sz)) { this.sz = sz; }
    }
  }
  this.constructor = ScaleAnimation;
}

ScaleAnimation.prototype = {

  /**
   * The scale value along the X axis
   * @public
   * @type {number}
   * @name vs.fx.ScaleAnimation#sx
   */
  sx: 1,

  /**
   * The scale value along the Y axis
   * @public
   * @type {number}
   * @name vs.fx.ScaleAnimation#sy
   */
  sy: 1,

  /**
   * The scale value along the Z axis
   * @public
   * @type {number}
   * @name vs.fx.ScaleAnimation#sz
   */
  sz: 1,
  
  /**
   * @name vs.core.ScaleAnimation#_clone
   * @function
   * @private
   *
   * @param {vs.core.Object} obj The cloned object
   * @param {Object} map Map of cloned objects
   */
  _clone : function (obj, cloned_map)
  {
    Animation.prototype._clone.call (this, obj, cloned_map);
    
    obj.sx = this.sx;
    obj.sy = this.sy;
    obj.sz = this.sz;    
  }
};
util.extendClass (ScaleAnimation, Animation);


/**
 *  @class
 *  Skew your object over the X and Y axes
 *  <p>
 *  If the second parameter is not provided, it is takes a value equal to
 *  the first.
 *
 *  @example
 *  // declare the animation
 *  var scale = new vs.fx.SkewAnimation (0.5, 1);
 *  scale.process (comp);
 *
 *  @author David Thevenin
 *
 *  @constructor
 *  Main constructor
 *  @extends vs.fx.Animation
 * @name vs.fx.SkewAnimation
 *
 * @param {number} x The scale value along the X axis
 * @param {number} y The scale value along the Y axis
*/
SkewAnimation = function (ax, ay)
{
  this.parent = Animation;
  if (!arguments.length)
  {
    this.parent ();
  }
  else
  {
    this.parent (['skew', '${ax}deg,${ay}deg']);

    if (util.isNumber (ax)) { this.ax = ax; }
    if (util.isNumber (ay)) { this.ay = ay; }
  }
  this.constructor = SkewAnimation;
}

SkewAnimation.prototype = {

  /**
   * Specifies a skew transformation along the X axis by the given angle.
   * @public
   * @type {number}
   * @name vs.fx.SkewAnimation#ax
   */
  ax: 0,

  /**
   *Specifies a skew transformation along the X axis by the given angle.
   * @public
   * @type {number}
   * @name vs.fx.SkewAnimation#ay
   */
  ay: 0,
  
  /**
   * @name vs.core.SkewAnimation#_clone
   * @function
   * @private
   *
   * @param {vs.core.Object} obj The cloned object
   * @param {Object} map Map of cloned objects
   */
  _clone : function (obj, cloned_map)
  {
    Animation.prototype._clone.call (this, obj, cloned_map);
    
    obj.ax = this.ax;
    obj.ay = this.ay;
  }
};
util.extendClass (SkewAnimation, Animation);

/**
 *  @class
 *  Animate the object' opacity
 *
 *  @example
 *  // declare the pulseo opacity animation
 *  var pulse = new vs.fx.OpacityAnimation (1);
 *  pulse.addKeyFrame ('from', {value: 1});
 *  pulse.addKeyFrame (12, {value: 0.5});
 *  pulse.addKeyFrame (25, {value: 1});
 *  pulse.addKeyFrame (37, {value: 0.5});
 *  pulse.addKeyFrame (50, {value: 1});
 *  pulse.addKeyFrame (62, {value: 0.5});
 *  pulse.addKeyFrame (75, {value: 1});
 *  pulse.addKeyFrame (87, {value: 0.5});
 *  pulse.durations = '7s';
 *  pulse.timings = vs.fx.Animation.LINEAR;
 *
 *  @author David Thevenin
 *
 *  @constructor
 *  Main constructor
 *  @extends vs.fx.Animation
 * @name vs.fx.OpacityAnimation
 *
 * @param {number} value The opacity value
*/
OpacityAnimation = function (value)
{
  this.parent = Animation;
  if (!arguments.length)
  {
    this.parent ();
  }
  else
  {
    this.parent (['opacity', '${value}']);

    if (util.isNumber (value)) { this.value = value; }
  }
  this.constructor = OpacityAnimation;
}

OpacityAnimation.prototype = {

  /**
   * Specifies the opacity value
   * @public
   * @name vs.fx.OpacityAnimation#value
   * @type {number}
   */
  value: 1,
  
  /**
   * @name vs.core.OpacityAnimation#_clone
   * @function
   * @private
   *
   * @param {vs.core.Object} obj The cloned object
   * @param {Object} map Map of cloned objects
   */
  _clone : function (obj, cloned_map)
  {
    Animation.prototype._clone.call (this, obj, cloned_map);
    
    obj.value = this.value;    
  }
};
util.extendClass (OpacityAnimation, Animation);

/*************************************************************
                Predefined animation
*************************************************************/

/**
 *  Slide a object to right.
 * @name vs.fx.Animation.SlideOutRight
 *  @type vs.fx.Animation
 */
Animation.SlideOutRight = new Animation (['translateX', '$width']);
Animation.SlideOutRight.addKeyFrame (0, ['0px']);
/**
 *  Slide a object to left.
 * @name vs.fx.Animation.SlideOutLeft
 *  @type vs.fx.Animation
 */
Animation.SlideOutLeft = new Animation (['translateX', '-$width']);
Animation.SlideOutLeft.addKeyFrame (0, ['0px']);

/**
 *  Slide a object to top.
 * @name vs.fx.Animation.SlideOutTop
 *  @type vs.fx.Animation
 */
Animation.SlideOutTop = new Animation (['translateY', '-$height']);
Animation.SlideOutTop.addKeyFrame (0, ['0px']);

/**
 *  Slide a object to left.
 * @name vs.fx.Animation.SlideOutBottom
 *  @type vs.fx.Animation
 */
Animation.SlideOutBottom = new Animation (['translateY', '$height']);
Animation.SlideOutBottom.addKeyFrame (0, ['0px']);

/**
 *  Slide a object to right.
 * @name vs.fx.Animation.SlideInRight
 *  @type vs.fx.Animation
 */
Animation.SlideInRight = new Animation (['translateX', '0px']);
Animation.SlideInRight.addKeyFrame (0, ['$width']);

/**
 *  Slide a object to left.
 * @name vs.fx.Animation.SlideInLeft
 *  @type vs.fx.Animation
 */
Animation.SlideInLeft = new Animation (['translateX', '0px']);
Animation.SlideInLeft.addKeyFrame (0, ['-$width']);

/**
 *  Slide a object to top.
 * @name vs.fx.Animation.SlideInTop
 *  @type vs.fx.Animation
 */
Animation.SlideInTop = new Animation (['translateY', '0px']);
Animation.SlideInTop.addKeyFrame (0, ['-$height']);

/**
 *  Slide a object to left.
 * @name vs.fx.Animation.SlideInBottom
 *  @type vs.fx.Animation
 */
Animation.SlideInBottom = new Animation (['translateY', '0px']);
Animation.SlideInBottom.addKeyFrame (0, ['$height']);

/**
 *  Fade in an object.
 * @name vs.fx.Animation.FadeIn
 *  @type vs.fx.Animation
 */
Animation.FadeIn = new Animation (['opacity', '1']);
Animation.FadeIn.addKeyFrame (0, ['0']);

/**
 *  Fade out an object.
 * @name vs.fx.Animation.FadeOut
 *  @type vs.fx.Animation
 */
Animation.FadeOut = new Animation (['opacity', '0']);
Animation.FadeOut.addKeyFrame (0, ['1']);

/********************************************************************
                      Export
*********************************************************************/
/** @private */
fx.Animation = Animation;
fx.cancelAnimation = cancelAnimation;
fx.TranslateAnimation = TranslateAnimation;
fx.RotateAnimation = RotateAnimation;
fx.RotateXYZAnimation = RotateXYZAnimation;
fx.ScaleAnimation = ScaleAnimation;
fx.SkewAnimation = SkewAnimation;
fx.OpacityAnimation = OpacityAnimation;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The Generic vs.fx.Controller class
 *
 *  @see vs.fx.SwipeController
 *  @see vs.fx.CardController
 *  @see vs.fx.NavigationController
 *  @extends vs.core.EventSource
 *
 *  @class
 *  This class can be used to implement your custom GUI controller.
 *  <p/>
 *  Before developing your own controller you can try the SwipeController
 *  or the NavigationController witch match most situations.
 *
 *  <p>
 *  Delegate:
 *  <ul>
 *    <li/>controllerViewWillChange : function (from vs.ui.View, to vs.ui.View, controller),
 *         Called when the view changed
 *    <li/>controllerAnimationDidEnd : function (from vs.ui.View, to vs.ui.View, controller), Called just after 
 *         the animation ended
 *  </ul>
 *  <p>
 *  Example:
 *  <pre class="code">
 * 
 *   // 1 create and init the controller
 *   this.controller = new vs.fx.Controller (this);
 *   this.controller.init ();
 *   
 *   // 2.1 put a first view into the controller
 *   this.controller.add (this.firstView);
 *   // 2.2 set the first view as the initial view
 *   this.controller.initialComponent = this.firstView.id;
 *  
 *   // 3.1 create, configure and put the second view into the controller
 *   var comp = this.createAndAddComponent ('PanelOne');
 *   comp.position = [0, 44];
 *   comp.translation = [320, 0];
 *   this.controller.add (comp);
 *   
 *   // 3.2 declare transitions (with animations) between states
 *   // translateOutLeft is play on firstView when we leave the firstView
 *   // translateInRight is play on comp when we enter into comp
 *   this.controller.addTransition (this.firstView.id, comp.id, 'goToOne',
 *                                  translateOutLeft, translateInRight);
 *   this.controller.addTransition (comp.id, this.firstView.id, 'back',
 *                                  translateOutRight, translateInLeft);
 *  
 *   // 4 create, configure and put the third view into the controller
 *   comp = this.createAndAddComponent ('PanelTwo');
 *   comp.position = [0, 44];
 *   comp.translation = [320, 0];
 *   this.controller.add (comp);
 *   
 *   this.controller.addTransition (this.firstView.id, comp.id, 'goToTwo',
 *                                  translateOutLeft, translateInRight);
 *   this.controller.addTransition (comp.id, this.firstView.id, 'back',
 *                                  translateOutRight, translateInLeft);
 *  
 *   // 5 create, configure and put the fourth view into the controller
 *   var comp = this.createAndAddComponent ('PanelThree');
 *   comp.position = [0, 44];
 *   comp.translation = [320, 0];
 *   this.controller.add (comp);
 *   
 *   this.controller.addTransition (this.firstView.id, comp.id, 'goToThree',
 *                                  translateOutLeft, translateInRight);
 *   this.controller.addTransition (comp.id, this.firstView.id, 'back',
 *                                  translateOutRight, translateInLeft);
 *  
 *  </pre>
 *  @author David Thevenin
 * @name vs.fx.Controller
 *
 *  @constructor
 *   Creates a new vs.fx.Controller.
 *
 * @param {vs.ui.View} owner the View using this controller [mandatory]
 */
function Controller (owner)
{
  this.parent = core.EventSource;
  this.parent ();
  this.constructor = Controller;

  if (owner)
  {
    this._fsm = new core.Fsm (this);
  
    // fsm goTo surcharge
    this._fsm.goTo = this.goTo;
    this._owner = owner;
  }
}

Controller.prototype = {

   /**
   * @protected
   * @type {Object}
   */
  _delegate: null,

   /**
   * @protected
   * @type {Object}
   */
  _owner: null,

   /**
   * @protected
   * @type {vs.core.Fsm}
   */
  _fsm: null,

   /**
   * @protected
   * @type {String}
   */
  _initial_component: null,

 /**********************************************************************

  *********************************************************************/

  /**
   * @protected
   * @function
   */
  destructor : function ()
  {
    if (this._owner)
    {
      this._owner.__controller__ = undefined;
      
      this._owner.remove = this._owner._ab_controller_remove;
      this._owner._ab_controller_remove = undefined;
    }
    
    this._delegate = undefined;

    util.free (this._fsm);
    core.EventSource.prototype.destructor.call (this);
  },

  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    core.EventSource.prototype.initComponent.call (this);

    if (this._fsm) this._fsm.init ();
    
    if (!this._owner)
    {
      console.error ("Invalid vs.fx.Controller, owner is null vs.fx.Controller.id = '" + this._id + "'");
      return;
    }
    if (this._owner.__controller__)
    {
      console.error ("The owner already use a controller");
      return;
    }
    this._owner.__controller__ = this;
    
    this._owner._ab_controller_remove = this._owner.remove;
    this._owner.remove = this.ab_controller_remove;
  },
  

/*********************************************************
 *                 behavior update
 *********************************************************/
  
  /**
   * @protected
   * @function
   */
  ab_controller_remove : function (child)
  {
    if (!child) { return; }
    
    state = this.__controller__._fsm._list_of_state [child.id];
    if (state)
    {
      this.__controller__.remove (child);
    }
    else
    {
      this._ab_controller_remove (child);
    }
    // XXX should remove the component from the FSM etc...
  },

/*********************************************************
 *                  State Management
 *********************************************************/
 
  /**
   *  Return true if the state already exists
   *
   * @name vs.fx.Controller#isStateExit
   * @function
   * 
   * @return boolean
   */
  isStateExit : function (id)
  {
    if (!this._fsm) return false;
    
    if (this._fsm._list_of_state [id])
    { return true; }
    
    return false;
  },
 
  /**
   * @private
   * @function
   * @deprecated
   */
  add : function (comp, data, extension, bindings)
  {
    console.warn ('vs.fx.Controller.add is deprecated. Use vs.fx.Controller.push'); 
    return this.push (comp, data, extension, bindings);
  },

  /**
   *  Add the a child component to the Controller Manager
   *  <p>
   *  The component must be a graphic component (vs.ui.View).
   *  It will be instantiated, init and added automaticaly
   *  <p>
   *  The component instantiation is a lazy algorithm. The component will
   *  be instantiated and add into the DOM tree only when it has to be show
   *  to the user.
   *  <p>
   *  @example
   *  var myComp = new MyComp (conf);
   *  myComp.layer = new vs.fx.Controller (myComp);
   *  myComp.layer.push ('AComponent1', data1);
   *  myComp.layer.push ('AComponent1', data2);
   *  myComp.layer.push ('AComponent2', data3);
   *
   * @name vs.fx.Controller#push
   * @function
   *
   * @param {String | vs.ui.View} comp The GUI component name to instanciate or 
   *    the instance of the component  
   * @param {Object} config Configuration structure need to build the 
   *     component [optional]
   * @param {Array} bindings Bindings configuration [[spec, observer, method], ...]
   */
  push : function (comp, data, extension, bindings)
  {
    if (!comp || !this._fsm) { return; }
    if (!data) { data = {}; }
    
    var state_id = null, binding, i, state;
    if (util.isString (comp) && data.id)
    { state_id = data.id; }
    else if (!util.isString (comp) && comp.id)
    { state_id = comp.id; }
    else { state_id = core.createId (); }
    
    if (this.isStateExit (state_id))
    { return; }
    
    this._fsm.addState (state_id);
    state = this._fsm._list_of_state [state_id];
    state.bindings = {};
    
    if (bindings && bindings.length)
    {
      for (i = 0; i < bindings.length; i++)
      {
        binding = bindings [i];
        if (!binding || binding.length !== 3)
        {
          console.warn ('vs.fx.Controller.push: invalid binding information');
          continue;
        }
        this.componentBind (state_id, binding[0], binding[1], binding[2]);
      }
    }
    
    this.setStateComponentInformation (state_id, comp, extension, data);
    
    return state_id;
  },

  /**
   *  Remove a child component to the Slider Manager
   *  <p>
   *  The component can be specified as an Object or an id.
   *  <p>
   *  @example
   *  layer.remove (myComp);
   *  layer.remove (myComp.id);
   *
   * @name vs.fx.Controller#remove
   * @function
   *
   * @param {vs.ui.View | String} comp The GUI component or the component id
   */
  remove : function (comp)
  {
    if (!comp || !this._owner || !this._fsm) { return; }
    
    var state_id = null;
    if (util.isString (comp))
    { state_id = comp; }
    else if (!util.isString (comp))
    { state_id = comp.id; }
    
    var state = this._fsm._list_of_state [state_id];
    if (state && state.comp)
    {
      this._owner._ab_controller_remove (state.comp);
    }
    this._fsm.removeState (state_id);
  },

  /**
   * Set the component associated to a state
   *
   * @name vs.fx.Controller#setStateComponentInformation
   * @function
   *
   * @private
   * @param {String} state_id the state's name 
   * @param {{String | vs.ui.View}} comp The GUI component name to instanciate or 
   *    the instance of the component  
   * @param {Object} init_data Optional data for the component 
   *                   constructor [optional]
   */
  setStateComponentInformation : function (state_id, comp, extension, init_data)
  {
    if (!state_id || !this._fsm || !this._fsm.existState (state_id)) { return; }
    if (!comp || !this._owner) { return; }
    
    if (!init_data) { init_data = {}; }
    else { init_data = util.clone (init_data); }
    
    var state = this._fsm._list_of_state [state_id];
    state.init_data = init_data;
    
    if (util.isString (comp))
    {
      state.comp_name = comp;
      state.comp = undefined;
    }
    else
    {
      state.comp_name = "";
      state.comp = comp;
      if (!this._owner.isChild (comp))
      {
        this._owner.add (comp, extension);
      }
    }
  },

/*********************************************************
 *                  Animation setting
 *********************************************************/

  /**
   *   Add a new transition from the view "from" to the view "to".
   *
   * @name vs.fx.Controller#addTransition
   * @function
   *
   * @param {String} from State from (component id)
   * @param {String} to State to (component id)
   * @param {String} on the input event name which cause the crossing of 
   *      transition
   * @param {vs.fx.Animation} animation_out the animation when exit from the
   *         state from. [optional]
   * @param {vs.fx.Animation} animation_in the animation when enter in the
   *         state to. [optional]
   */
  addTransition : function (from, to, on, animation_out, animation_in)
  {
    var key, t;
        
    if (!from || !this._fsm || !this._fsm.existState (from)) { return; }
    if (!to || !this._fsm.existState (to)) { return; }
    if (!on) { return; }
    
    if (!this._fsm.existInput (on))
    {
      this._fsm.addInput (on);
    }
    
    this._fsm.addTransition (from, to, on);

    for (key in this._fsm._list_of_state [from].transitionEvents)
    {
      t = this._fsm._list_of_state [from].transitionEvents [key];
      if (t.to !== to) { continue; }
      
      t.animation_out = animation_out;
      t.animation_in = animation_in;
    }
  },
  
  /**
   *  @private
   */
  _animateComponents :
    function (fromComp, toComp, animationOut, animationIn, animation_clb, instant)
  {
    var self = this, callback = function ()
    {
      try
      {
        if (animation_clb)
        {
          animation_clb.call (self._owner);
        }
        if (self._delegate && self._delegate.animationDidEnd)
        {
          console.warn ("animationDidEnd is deprecated. Please use 'controllerAnimationDidEnd'.");
          self._delegate.animationDidEnd (self);
        }
        if (self._delegate && self._delegate.controllerAnimationDidEnd)
        {
          self._delegate.controllerAnimationDidEnd (fromComp, toComp, self);
        }
      }
      catch (e) {
        if (e.stack) console.log (e.stack);
        console.error (e); 
      }
    },
    runAnimation = function ()
    {
      try
      {
        toComp.show ();
        if (!animationIn && !animationOut)
        {
          callback.call (self);
          return;
        }
        if (instant)
        {
          if (animationIn)
          {
            var inDurations = animationIn.durations;
            animationIn.durations = '0s';
          }
          if (animationOut)
          {
            var outDurations = animationOut.durations;
            animationOut.durations = '0s';
          }
        }
        if (animationIn && !animationOut)
        {
          animationIn.process (toComp, callback, self);
        }
        else if (!animationIn && animationOut)
        {
          animationOut.process (fromComp, callback, self);
        }
        else
        {
          if (animationIn) animationIn.process (toComp, callback, self);
          if (animationOut) animationOut.process (fromComp); 
        }
        if (instant)
        {
          if (animationIn) animationIn.durations = inDurations;
          if (animationOut) animationOut.durations = outDurations;
        }
      }
      catch (e) {
        if (e.stack) console.log (e.stack);
        console.error (e);
      }
    };
    vs.scheduleAction (function () {runAnimation ();});
  },


/*********************************************************
 *                 Component Event management
 *********************************************************/
 
  /**
   *  The event bind method to listen events
   *  <p>
   *  When you want listen an event generated by a component, you can
   *  bind your object (the observer) to this object using 'componentBind' 
   *  method.
   *
   * @name vs.fx.Controller#componentBind
   * @function
   *
   * @param {string} comp_id the component id [mandatory]
   * @param {string} spec the event specification [mandatory]
   * @param {vs.core.Object} obj the object interested to catch the event [mandatory]
   * @param {string} func the name of a callback. If its not defined
   *        notify method will be called [optional]
   */
  componentBind: function (comp_id, event, obj, func)
  {
    if (!this._fsm) return;
    
    var state = this._fsm._list_of_state [comp_id], a;
    
    if (!state) { return; }
    
    a = state.bindings [event];
    if (!a)
    {
      a = [];
      state.bindings [event] = a;
    }
    
    a.push ([obj, func]);
    if (comp_id === this._current_state)
    {
      state.comp.bind (event, obj, func);
    }
  },
  
  /**
   * @protected
   * @function
   */
  refresh: function ()
  {},

/*********************************************************
 *                 FSM management
 *********************************************************/
 
  /**
   * returns the currents state_id which is the current visible
   * component id.
   *
   * @name vs.fx.Controller#getCurrentState
   * @function
   *
   * @return {string} the current state id
   */
  getCurrentState : function ()
  {
    if (!this._fsm) return;
    
    return this._fsm._current_state;
  },
 
  /**
   * @protected
   * @function
   */
  configureNewComponent : function (comp)
  {
  },

  /**
   * @protected
   * @function
   */
  _beforeStateEnter : function (state, data)
  {
    if (!state || !(state.comp_name || state.comp)) { return; }
    
    var spec, events, i, key, e, new_data;
  
    ////////////////////////////////////////////////////
    // 1) build the component if its need
    if (!state.comp)
    {
      state.comp = this._owner.createAndAddComponent
        (state.comp_name, state.init_data, state.extension);
        
      state.comp.configure (state.init_data);
      if (state.comp && state.comp.propertiesDidChange) 
      { 
        state.comp.propertiesDidChange ();
      }
      state.comp.propertyChange ();
      this.configureNewComponent (state.comp);
    }
    
    ////////////////////////////////////////////////////
    // 2) data adaptation and init
    new_data = data;
    // 2.1) data adaptation
    if (state.data_adaptation_func)
    {
      new_data = state.data_adaptation_func (data);
    }
    // 2.2) component data init
    if (new_data)
    {
      // 2.2.1) set data
      for (key in new_data)
      {
        if (!state.comp.__lookupSetter__ (key) &&
            !state.comp.hasOwnProperty (key))
        {
          continue;
        }
        state.comp [key] = new_data [key];
      }
      
      // 2.2.1) dataflow propagation
      state.comp.propertyChange ();
    }
    
    ////////////////////////////////////////////////////
    // 3) events binding
    for (spec in state.bindings)
    {
      events = state.bindings [spec];
      if (!events) { continue; }
      
      for (i = 0; i < events.length; i ++)
      {
        e = events [i];
        if (!e) { continue; }
        if (e[1]) { state.comp.bind (spec, e[0], e[1]); }
        else { state.comp.bind (spec, e[0]); }
      }
    }
  },

  /**
   * @protected
   * @function
   */
  _beforeStateExit : function (state)
  {
    if (!state || !state.comp) { return; }
    
    var spec, events, i, e;
      
    ////////////////////////////////////////////////////
    // 1) events unbinding
    for (spec in state.bindings)
    {
      events = state.bindings [spec];
      if (!events) { continue; }
      
      for (i = 0; i < events.length; i ++)
      {
        e = events [i];
        if (!e) { continue; }
        if (e[1]) { state.comp.unbind (spec, e[0], e[1]); }
        else { state.comp.bind (spec, e[0]); }
      }
    }
  },

  /**
   *  Private method use by the fsm to cross a transition.
   *  @note for the moment only one ouput lexem can be generation when
   *  crossing a transition
   *  @private
   *
   * @name vs.fx.Controller#goTo
   * @function
   *
   * @param {String} id_sate the id of target state.
   * @param {String} output
   * @param {Object} event the event
   * @param {Boolean} instant make the transition visualy instantly [Optional]
   * @return {Boolean} is the transition was reached or not
   */
  goTo : function (state_id, output, event, instant)
  {
    // manage output
    // TODO WARNING
    var state_from, state_to, transition = null;
    
    if (!state_id || !this._list_of_state [state_id])
    {
      console.warn ("vs.fx.Controller.goTo unknown State id:" + state_id);
      return false;
    }

    // hide old states view
    if (this._current_state)
    {
      if (event)
      {
        transition =
          this._list_of_state [this._current_state].transitionEvents [event.on];
      }
      state_from = this._list_of_state [this._current_state];
      this.owner._beforeStateExit (state_from);
    }
    
    ///
    this._current_state = state_id;
    
    // show new states view
    state_to = this._list_of_state [this._current_state];
    this.owner._beforeStateEnter (state_to, event?event.data:null);
    
    if (state_from && state_from.comp && state_from.comp.viewWillDisappear)
    {
      state_from.comp.viewWillDisappear ();
    }
    if (state_to.comp.viewWillAppear)
    {
      state_to.comp.viewWillAppear ();
    }
    
    if (transition)
    {
      this.owner._animateComponents (
        state_from.comp, state_to.comp,
        transition.animation_out, transition.animation_in,
        null, instant);
    }
    else
    {
      state_to.comp.show ();
    }
    
    if (this.owner._delegate && this.owner._delegate.controllerViewWillChange)
    {
      if (state_from)
      {
        this.owner._delegate.controllerViewWillChange
          (state_from.comp, state_to.comp, this.owner);
      }
      else
      {
        this.owner._delegate.controllerViewWillChange
          (null, state_to.comp, this.owner);
      }
    }

    if (output && this._output_action [output])
    {
      var clb = this._output_action [output];
      if (util.isFunction (clb))
      {
        clb.call (this._owner, event);
      }
      else if (util.isString (clb))
      {
        this._owner [this._output_action [output]] (event);
      }
    }
    
    return true;
  },

  /**
   * @protected
   * @function
   */
  notify : function (event, instant)
  {
    if (!this._fsm || !event || !event.type) { return; }
    this._fsm.fsmNotify (event.type, event.data, instant);
  },

/*********************************************************
 *                  Controller clear
 *********************************************************/

  /**
   * Clear the vs.fx.Controller.
   * All state, event and binding are deleted
   *
   * @name vs.fx.Controller#clear
   * @function
   */
  clear : function ()
  {
    if (!this._fsm) return;
    
    this._fsm.clear ();
  }
};
util.extendClass (Controller, core.EventSource);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (Controller, {
  'initialComponent': {
    /*****************************************************************
     *     Properties declaration
     ****************************************************************/
  
    /**
     * Define the initiale component
     * Generate a exception if the component was not already registered
     *
     * @name vs.fx.Controller#initialComponent 
     * @param {string} state_id the state
     */
    set : function (comp_id)
    {
      if (!this._fsm || !comp_id)
      {
        this._initial_component = undefined;
        return;
      }
     
      if (!this._fsm.existState (comp_id)) { return; }
  
      // set initial state and go to it   
      this._initial_component = comp_id;
      this._fsm.initialState = comp_id;
      
      this._fsm.goTo (comp_id);
    },
    
    /**
     * @ignore
     */
    get : function ()
    {
      return this._initial_component;
    }
  },
  'delegate': {
  
    /** 
     * Set the delegate.
     * It should implements following methods
     * <ul>
     *   <li/>controllerViewWillChange :function
     *           (from vs.ui.View, to vs.ui.View, controller),
     *           Called when the view changed
     *   <li/>controllerAnimationDidEnd : function
     *           (from vs.ui.View, to vs.ui.View, controller), Called just after 
     *         the animation ended
     * </ul>
     *
     * @name vs.fx.Controller#delegate 
     * @type {Object}
     */ 
    set : function (v)
    {
      this._delegate = v;
    }
  }
});
/********************************************************************
                      Export
*********************************************************************/
/** @private */
fx.Controller = Controller;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.fx.StackController class <br />
 * 
 *  @see vs.fx.SwipeController
 *  @see vs.fx.CardController
 *
 *  @extends vs.fx.Controller
 *  @class
 *  The vs.fx.StackController class <br />
 *  This an abstract layer controller and it should no be instanciated.
 *  Use {@link vs.fx.SliderController} or {@link vs.fx.CardController} layers.
 *  @abstract
 * 
 *  @author David Thevenin
 * @name vs.fx.StackController
 *
 *  @constructor
 *   Creates a new vs.fx.StackController.
 *
 * @param {vs.ui.View} owner the View using this Layer [mandatory]
 * @param {String} extension The hole into the vs.fx.View will be inserted. 
 *     ['children' by default]
 */
function StackController (owner)
{
  this.parent = Controller;
  this.parent (owner);
  this.constructor = StackController;
  
  if (!arguments.length) return;

  this._fsm.addInput (StackController.NEXT);
  this._fsm.addInput (StackController.PRED);
  this._fsm.addInput (StackController.FIRST);

  this._states_array = new Array ();
}

/**
 * The duration of the animation between two views
 * @name vs.fx.StackController.ANIMATION_DURATION
 */
StackController.ANIMATION_DURATION = 350;

/**
 * @private
 * @name vs.fx.StackController.NEXT
 * @const
 */
StackController.NEXT = 'next';

/**
 * @private
 * @name vs.fx.StackController.PRED
 * @const
 */
StackController.PRED = 'pred';

/**
 * @private
 * @name vs.fx.StackController.FIRST
 * @const
 */
StackController.FIRST = 'first';

/**
 * @private
 * @name vs.fx.StackController.LAST
 * @const
 */
StackController.LAST = 'last';

StackController.prototype = {

/********************************************************************
                  protected members declarations
********************************************************************/

  /**
   * @protected
   * @function
   */
  _is_tactile : false,

  /**
   * @protected
   * @function
   */
  _owner_handler_event_extended : false,

  /**
   * @protected
   * @function
   */
  _owner_handler_event : null,

  /**
   * @protected
   * @function
   */
  _animation_duration: StackController.ANIMATION_DURATION, 
  
  /**
   * @protected
   * @function
   */
  _last_comp_id : null,
  
  /**
   * @protected
   * @function
   */
  _states_array : null,
  
  /**
   * @protected
   * @type {number}
   */
  __nb_panels : 0,

  /**
   *
   * @protected
   * @type {Array}
   */
  _view_size: null,
  
/********************************************************************

********************************************************************/

  /**
   * @protected
   * @function
   */
  destructor : function ()
  {
    delete (this._states_array);
    
    Controller.prototype.destructor.call (this);
  },

  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    Controller.prototype.initComponent.call (this);
    
    this.isTactile = this._is_tactile;
    this._updateViewSize ();
  },
  

/********************************************************************

********************************************************************/

  /**
   *  Add a child component to the Slider Manager
   *  <p>
   *  The component must be a graphic component (vs.ui.View).
   *  It will be instantiated, init and added automaticaly
   *  <p>
   *  The component instantiation is a lazy algorithm. The component will
   *  be instantiated and add into the DOM tree only when it has to be show
   *  to the user.
   *  <p>
   *  @example
   *  var myController = new vs.fx.StackController (this | myView);
   *  myController.init ();
   *  myController.push ('AComponent1', data1);
   *  myController.push ('AComponent1', data2);
   *  myController.push ('AComponent2', data3);
   *
   * @name vs.fx.StackController#push
   * @function
   *
   * @param {vs.ui.View | String} comp The GUI component or the component
   *     name to instanciate   
   * @param {Object} config Configuration structure need to build the component.
   * @param {Array} bindings Bindings configuration [[spec, observer, method], ...]
   */
  push : function (comp, data, extension, bindings)
  {
    if (!comp) { return; }
    if (!data) { data = {}; }
    
    var state_id = Controller.prototype.push.call
      (this, comp, data, extension, bindings);
    if (!state_id) { return; }
    
    this._states_array.push (state_id);
    this.__nb_panels ++; 

    // first item
    if (this.__nb_panels === 1)
    {
      this.initialComponent = state_id;
      this._last_comp_id = state_id;

      return state_id;
    }
    
    this.addTransition (this._last_comp_id, state_id, StackController.NEXT);
    this.addTransition (state_id, this._last_comp_id, StackController.PRED);
    this.addTransition 
      (state_id, this._initial_component, StackController.FIRST);
 
    this._last_state = state_id;
    
    // create the second view 
    if (this._last_comp_id === this._initial_state)
    {
      state = this._fsm._list_of_state [state_id];
      if (!state)
      {
        console.error ("Unknown error in vs.fx.StackController.push");
        return;
      }
      if (!state.comp)
      {
        state.comp = this._owner.createAndAddComponent
          (state.comp_name, state.init_data, extension);
          
        state.comp.configure (state.init_data);
        state.comp.setStyle ('position', 'absolute');
        if (state.comp && state.comp.propertiesDidChange) 
        { 
          state.comp.propertiesDidChange ();
        }
        state.comp.propertyChange ();
      }
      
      state.comp.show ();
    }
    
    this._last_comp_id = state_id;
    return state_id;
  },
  
  /**
   * @protected
   * @function
   */
  _updateViewSize : function ()
  {},

  /**
   *  Remove a child component to the Slider Manager
   *  <p>
   *  The component can be specified as an Object or an id.
   *  <p>
   *  @example
   *  myComp.layer.remove (myComp);
   *  myComp.layer.remove (myComp.id);
   *
   * @name vs.fx.StackController#remove
   * @function
   *
   * @param {vs.ui.View | String} comp The GUI component or the component id
   */
  remove : function (comp)
  {
    if (!comp) { return; }
    
    var state_id = null;
    if (util.isString (comp))
    { state_id = comp; }
    else if (!util.isString (comp))
    { state_id = comp.id; }
    
    var pos = this._states_array.findItem (state_id);
    if (pos === -1) { return; }
    
    this._fsm.removeTransitionTo (state_id, StackController.NEXT);
    this._fsm.removeTransitionFrom (state_id, StackController.PRED);
    this._fsm.removeTransitionFrom (state_id, StackController.FIRST);

    this._states_array.remove (pos);

    this.__nb_panels --; 
    var state = this._fsm._list_of_state [state_id];
    
    if (pos === 0 && this.__nb_panels > 0)
    {
      this._initial_component = this._states_array [0];
      
      // re configure all to FIRST transition
      for (var state_id_temp in this._states_array)
      {
        if (state_id_temp === state_id) { continue; }
        if (state_id_temp === this._initial_component) { continue; }

        this._fsm.removeTransitionFrom (state_id_temp, StackController.FIRST);
        this.addTransition
          (state_id_temp, this._initial_component, StackController.FIRST);
      }
    }
    if (this.__nb_panels === 0)
    {
      this._initial_component = undefined;
      this._fsm._current_state = undefined;
    }
    
    if (this._initial_component)
    {
      if (this._fsm._current_state === state_id)
      {
        if (pos === 0)
        {
          this._fsm.goTo (this._initial_component);
        }
        else
        {
          if (pos === this._states_array.length) { pos --; }
          this._fsm.goTo (this._states_array [pos]);
        }
      }
      else
      {
        this._fsm.goTo (this._fsm._current_state);
      }
    }
    Controller.prototype.remove.call (this, comp);
  },

  /**
   * @protected
   * @function
   *
   * @param {number} orientation = {0, 180, -90, 90}
   */
  orientationDidChange: function (orientation)
  { 
    this._updateViewSize ();
  },

/*********************************************************
 *                  Event management
 *********************************************************/
  
  /**
   * Go to the view specified by its id if it exist.
   *
   * @name vs.fx.StackController#goToViewId
   * @function
   * 
   * @param {String} id The state id (component id)
   * @param {Function} clb a function reference, will be called at the end
   *                   of transition
   * @param {boolean} instant Force a transition without animation
   */
  goToViewId : function (id, clb, instant)
  {
    var pos = this._states_array.findItem (id);
    if (pos === -1) { return false; }
    
    this.goToViewAt (pos, clb, instant);
  },

  /**
   *  Go to the view specified by its position (index start at 0)
   *
   * @name vs.fx.StackController#goToViewAt
   * @function
   *
   * @param {number} index The component index
   * @param {Function} clb a function reference, will be called at the end
   *                   of transition
   * @param {boolean} instant Force a transition without animation
   */
  goToViewAt : function (pos, clb, instant)
  {
    if (pos < 0) { return false; }
    if (pos > this._states_array.length) { return false; }
    
    var current_pos = this._states_array.findItem (this._fsm._current_state);
    if (current_pos === pos) { return true; }
    
    var state_from = this._fsm._list_of_state [this._fsm._current_state];
    if (pos > current_pos)
    {
      while (current_pos < pos - 1)
      {
        this._fsm.fsmNotify (StackController.NEXT, null, true);
        current_pos ++;
      }
      this._fsm.fsmNotify (StackController.NEXT, null, true);
      
      var state_to = this._fsm._list_of_state [this._fsm._current_state];
      this._stackAnimateComponents (1, state_from.comp, state_to.comp, clb, instant);
    }
    else
    {
      while (pos + 1 < current_pos )
      {
        this._fsm.fsmNotify (StackController.PRED, null, true);
        current_pos --;
      }
      this._fsm.fsmNotify (StackController.PRED, null, true);

      var state_to = this._fsm._list_of_state [this._fsm._current_state];
      this._stackAnimateComponents (-1, state_from.comp, state_to.comp, clb, instant);
    }
  },

  /**
   *  @protected
   */
  _stackAnimateComponents : function (order, fromComp, toComp, clb, instant)
  {},
  
  /**
   *  do nothing, will be managed by _stackAnimateComponents
   *  @protected
   */
  _animateComponents :
    function (fromComp, toComp, animationOut, animationIn, animation_clb, instant)
  {},
  
  /**
   * Go to the next view if it exist.
   *
   * @name vs.fx.StackController#goToNextView
   * @function
   * 
   * @param {Function} clb a function reference, will be called at the end
   *                   of transition
   * @param {boolean} instant Force a transition without animation
   * @return true if the transition is possible, false if not (no view exists)
   */
  goToNextView : function (clb, instant)
  {
    var state_from = this._fsm._list_of_state [this._fsm._current_state],
      r = this._fsm.fsmNotify (StackController.NEXT, null, true),
      state_to = this._fsm._list_of_state [this._fsm._current_state];

    if (r) this._stackAnimateComponents (1, state_from.comp, state_to.comp, clb, instant);
    return r;
  },

  /**
   * Go to the previous view if it exist.
   *
   * @name vs.fx.StackController#goToPreviousView
   * @function
   * 
   * @param {Function} clb a function reference, will be called at the end
   *                   of transition
   * @param {boolean} instant Force a transition without animation
   * @return true if the transition is possible, false if not (no view exists)
   */
  goToPreviousView : function (clb, instant)
  {
    var state_from = this._fsm._list_of_state [this._fsm._current_state],
      r = this._fsm.fsmNotify (StackController.PRED, null, true),
      state_to = this._fsm._list_of_state [this._fsm._current_state];

    if (r) this._stackAnimateComponents (-1, state_from.comp, state_to.comp, clb, instant);
    return r;
  },

  /**
   * Go to the first view
   *
   * @name vs.fx.StackController#goToFirstView
   * @function
   * 
   * @param {Function} clb a function reference, will be called at the end
   *                   of transition
   * @param {boolean} instant Force a transition without animation
   * @return true if the transition is possible
   */
  goToFirstView : function (clb, instant, order)
  {
    var state_from = this._fsm._list_of_state [this._fsm._current_state],
      r = this._fsm.fsmNotify (StackController.FIRST, null, true),
      state_to = this._fsm._list_of_state [this._fsm._current_state];

    if (r) this._stackAnimateComponents (order?order:-1, state_from.comp, state_to.comp, clb, instant);
    return r;
  },


  /**
   * Go to the last first
   *
   * @name vs.fx.StackController#goToLastView
   * @function
   * 
   * @param {Function} clb a function reference, will be called at the end
   *                   of transition
   * @param {boolean} instant Force a transition without animation
   * @return true if the transition is possible
   */
  goToLastView : function (clb, instant, order)
  {
    var
      state_from = this._fsm._list_of_state [this._fsm._current_state],
      r = this._fsm.goTo (
        this._last_state, null, {
          on: StackController.LAST,
          data: null
        }, instant),
      state_to = this._fsm._list_of_state [this._fsm._current_state];
    

    if (r) this._stackAnimateComponents (order?order:1, state_from.comp, state_to.comp, clb, instant);
    return r;
  },

  /**
   * @protected
   * @function
   */
  handleEvent : function (event)
  {}
};
util.extendClass (StackController, Controller);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (StackController, {

  'viewSize': {
   /** 
     * Getter|Setter for view size.
     * @name vs.fx.StackController#viewSize 
     *
     * @type {Array.<number>}
     */ 
    set : function (v)
    {
      if (!v) { return; } 
      if (!util.isArray (v) || v.length !== 2) { return; }
      if (!util.isNumber (v[0]) || !util.isNumber(v[1])) { return; }
      
      if (!this._view_size)
      { this._view_size = []; }
      
      this._view_size [0] = v [0];
      this._view_size [1] = v [1];
      
      this._updateViewSize ();
    },
  
    /**
     * @ignore
     * @type {Array.<number>}
     */
    get : function ()
    {
      if (!this._view_size)
      {
        return this._owner.size;
      }
      return this._view_size.slice ();
    }
  },
  'isTactile': {
    /** 
     * Getter|Setter for the tab bar style
     * @name vs.fx.StackController#isTactile 
     * @type {boolean}
     */ 
    set : function (v)
    {
      if (v)
      {
        this._is_tactile = true;
        if (!this._owner || !this._owner.view) return;
  
        if (!this._owner_handler_event_extended)
        {
          this._owner_handler_event = this._owner.handleEvent;
          this._owner.handleEvent = this.handleEvent;
          vs.addPointerListener (this._owner.view, core.POINTER_START, this._owner, false);
        }
        this._owner_handler_event_extended = true;
      }
      else
      {
        this._is_tactile = false;
        if (!this._owner || !this._owner.view) return;
        
        if (this._owner_handler_event_extended)
        {
          vs.removePointerListener (this._owner.view, core.POINTER_START, this._owner, false);
          this._owner.handleEvent = this._owner_handler_event;
          
          this._owner_handler_event_extended = false;
        }
      }
    },
  
    /** 
     * @ignore
     * @return {boolean}
     */ 
    get : function ()
    {
      return this._is_tactile;
    }
  },
  'animationDuration': {
    /** 
     * Set the animation/transition temporisation (in millisecond)
     * @name vs.fx.StackController#animationDuration 
     * @type {number}
     */ 
    set : function (time)
    {
      if (!time) { time = 0; }
      if (!util.isNumber (time)) { return };
      
      this._animation_duration = time;
    }
  }
});
/********************************************************************
                      Export
*********************************************************************/
/** @private */
fx.StackController = StackController;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.fx.SlideController class <br />
 *  This layer manage a list of children using a horizontal layout.
 *
 *  Children can be slided horizontally (right <-> left) or vertically 
 *  (top <-> bottom) using a pointing device (mouse, touch screen, ...),
 *  or using methods goToNextView and goToPreviousView.
 *  <p />
 *  By default the slider is horizontal, but you can change it using the 
 *  property "orientation".
 *  <p />
 *  The following example shows a typical example with panels
 *  (components 1 to 4) that are shows sequentially according user touch slide.
 *
 *  <pre>
 *                   (*)
 *                ⎡ˉˉˉˉˉˉˉˉˉˉˉˉ⎤
 *   ⎡ˉˉˉˉˉˉ⎤    ⎢ ⎡ˉˉˉˉˉˉ⎤ ⎢   ⎡ˉˉˉˉˉˉ⎤   ⎡ˉˉˉˉˉˉ⎤
 *   ⎟      ⎢    ⎢ ⎢      ⎢ ⎢   ⎟      ⎢   ⎟      ⎢
 *   ⎟  (1) ⎢    ⎢ ⎢  (2) ⎢ ⎢   ⎟  (3) ⎢   ⎟  (4) ⎢
 *   ⎟      ⎢    ⎢ ⎢      ⎢ ⎢   ⎟      ⎢   ⎟      ⎢
 *   ⎣______⎦    ⎢ ⎣______⎦ ⎢   ⎣______⎦   ⎣______⎦
 *                ⎣____________⎦
 *
 *
 *  (*) : device screen
 *  (1, ... ,4) : components managed by the SliderLayer
 *
 *   </pre>
 *
 *  <p>
 *  Delegate:
 *  <ul>
 *    <li/>controllerViewWillChange : function (from vs.ui.View, to vs.ui.View,
 *         controller), Called when the view changed
 *    <li/>controllerAnimationDidEnd : function (from vs.ui.View, to vs.ui.View, 
 *         controller), Called just after the animation ended
 *  </ul>
 *  <p>
 *  @example
 *  var layer = new vs.fx.SlideController (myComp);
 *
 *  layer.push ('APanel', {id: '1', data: {...}});
 *  layer.push ('APanel', {id: '2', data: {...}});
 *  layer.push ('APanel', {id: '3', data: {...}});
 *  layer.push ('APanel', {id: '4', data: {...}});
 *
 *  @extends vs.fx.StackController
 * @name vs.fx.SlideController
 *  @class
 * 
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.fx.SlideController.
 *
 * @param {vs.ui.View} owner the View using this Layer [mandatory]
 */
var SlideController = vs.core.createClass ({

  parent: vs.fx.StackController,
  
  /********************************************************************
                    protected members declarations
  ********************************************************************/
  /**
   *
   * @protected
   * @type {number}
   */
  _delta : 0,
  
  /**
   *
   * @protected
   * @type {number}
   */
  _orientation : 0,
    
  /**
   *
   * @protected
   * @type {vs.fx.TranslateAnimation}
   */
  _transition_out_left : null,
  
  /**
   *
   * @protected
   * @type {vs.fx.TranslateAnimation}
   */
  _transition_out_right : null,
    
  /**
   *
   * @protected
   * @type {vs.fx.TranslateAnimation}
   */
  _transition_in : null,

  /**
   *
   * @protected
   * @type {number}
   */
  _animation_mode : 0,

  /********************************************************************
                    Define class properties
  ********************************************************************/

  properties: {
    'orientation': {
      /** 
       * Getter|Setter for page slide orientation. It can take the value
       * vs.fx.SlideController.HORIZONTAL or vs.fx.SlideController.VERTICAL.
       * By default the slider is horizontal.
       * @name vs.fx.SlideController#orientation 
       * @type String
       */ 
      set : function (v)
      {
        var state, state_id, i = 0, pos = 0;
      
        if (v !== SlideController.HORIZONTAL &&
            v !== SlideController.VERTICAL) { return; }
      
        this._orientation = v;
        this._updateViewSize ();
      },
  
      /** 
       * @ignore
       * @return {String}
       */ 
      get : function ()
      {
        return this._orientation;
      }
    },
    
    'animationDuration': {
      /** 
       * Set the animation/transition temporisation (in millisecond)
       * @name vs.fx.SlideController#animationDuration 
       * @type {number}
       */ 
      set : function (v)
      {
        if (!v) { v = 0; }
        if (!util.isNumber (v)) { return };
      
        this._animation_duration = v;
        this._transition_out_left.duration = this._animation_duration + 'ms';
        this._transition_out_right.duration = this._animation_duration + 'ms';
        this._transition_in.duration = this._animation_duration + 'ms';
      }
    },
    
    'animationMode': {
      /** 
       * Set XXX
       * @name vs.fx.SlideController#animationMode 
       * @type {number}
       */ 
      set : function (v)
      {
        if (!v) { v = 0; }
        if (v !== SlideController.POURCENTAGE &&
            v !== SlideController.PIXEL) return;
        if (this._animation_mode === v) return;
        
        this._animation_mode = v;
        
        util.free (this._transition_out_right);
        util.free (this._transition_out_left);
        
        this._setUpAnimations ();
        this._updateViewSize ();
      }
    }
  },

  constructor : function (owner)
  {
    this._super (owner);
    
    this._orientation = SlideController.HORIZONTAL;

    if (!arguments.length) return;
  
    this._setUpAnimations ();
    this._transition_in = new Animation (['translate', '0,0,0']);
 
    this.animationDuration = SlideController.ANIMATION_DURATION;
  },

  /*********************************************************
   *                 behavior update
   *********************************************************/
  /**
   * @protected
   * @function
   */
  _setUpAnimations : function ()
  {
    switch (this._animation_mode)
    {
      case SlideController.POURCENTAGE:
        this._transition_out_left = new Animation (['translate', '${x}%,${y}%,0']);
        this._transition_out_right = new Animation (['translate', '${x}%,${y}%,0']);
      break;

      case SlideController.PIXEL:
        this._transition_out_left = new Animation (['translate', '${x}px,${y}px,0']);
        this._transition_out_right = new Animation (['translate', '${x}px,${y}px,0']);
      break;
    }

    this._transition_out_left.x = 0;
    this._transition_out_left.y = 0;
    this._transition_out_left.duration = this._animation_duration + 'ms';
    this._transition_out_right.duration = this._animation_duration + 'ms';
  },
  
  /**
   * @protected
   * @function
   */
  _updateViewSize : function ()
  {
    var i, state_id, state, transform, delta, size;
    switch (this._animation_mode)
    {
      case SlideController.POURCENTAGE:
        delta = 100;
        delta_str = delta + "%";
      break;

      case SlideController.PIXEL:
        size = this._owner.size;
        
        if (this._orientation === SlideController.HORIZONTAL)
        {
          delta = size [0];
        }
        else if (this._orientation === SlideController.VERTICAL)
        {
          delta = size [1];
        }
        delta_str = delta + "px";
      break;
    }

    if (this._orientation === SlideController.HORIZONTAL)
    {
      this._transition_out_left.x = -delta;
      this._transition_out_left.y = 0;
      this._transition_out_right.x = delta;
      this._transition_out_right.y = 0;
    }
    else if (this._orientation === SlideController.VERTICAL)
    {
      this._transition_out_left.x = 0;
      this._transition_out_left.y = -delta;
      this._transition_out_right.x = 0;
      this._transition_out_right.y = delta;
    }
    
    // define transformation for view before current one
    if (this._orientation === SlideController.HORIZONTAL)
    {
      transform = "translate3D(-" + delta_str + ",0,0)";
    }
    else if (this._orientation === SlideController.VERTICAL)
    {
      transform = "translate3D(0,-" + delta_str + ",0)";
    }
    
    for (i = 0; i < this._states_array.length; i++)
    {
      state_id = this._states_array [i];
      state = this._fsm._list_of_state [state_id];
      
      if (!state || !state.comp) { continue; }
      
      if (this._fsm._current_state === state_id)
      {
        // define transformation for view after current one
        if (this._orientation === SlideController.HORIZONTAL)
        {
          transform = "translate3D(" + delta_str + ",0,0)";
        }
        else if (this._orientation === SlideController.VERTICAL)
        {
          transform = "translate3D(0," + delta_str + ",0)";
        }
        
        // set no transformation for the current one
        state.comp.view.style.webkitTransitionDuration = '0';
        setElementTransform (state.comp.view, "translate3D(0,0,0)");
        continue;
      }
      
      state.comp.view.style.webkitTransitionDuration = '0';
      setElementTransform (state.comp.view, transform);
    } 
  },
  
  /**
   *  Add a child component to the Slider Manager
   *  <p>
   *  The component must be a graphic component (vs.ui.View).
   *  It will be instantiated, init and added automaticaly
   *  <p>
   *  The component instantiation is a lazy algorithm. The component will
   *  be instantiated and add into the DOM tree only when it has to be show
   *  to the user.
   *  <p>
   *  @example
   *  var myController = new vs.fx.SlideController (this | myView);
   *  myController.init ();
   *  myController.push ('AComponent1', data1);
   *  myController.push ('AComponent1', data2);
   *  myController.push ('AComponent2', data3);
   *
   * @name vs.fx.SlideController#push
   * @function
   *
   * @param {vs.ui.View | String} comp The GUI component or the component
   *     name to instanciate   
   * @param {Object} config Configuration structure need to build the component.
   * @param {Array} bindings Bindings configuration [[spec, observer, method], ...]
   */
  push : function (comp, data, extension, bindings)
  {
    if (!comp) { return; }
    if (!data) { data = {}; }
    
    var state_id = Controller.prototype.push.call
      (this, comp, data, extension, bindings);
    if (!state_id) { return; }
    
    this._states_array.push (state_id);
    this.__nb_panels ++; 

    // first item
    if (this.__nb_panels === 1)
    {
      this.initialComponent = state_id;
      this._last_comp_id = state_id;

      return state_id;
    }
    
    this.addTransition (this._last_comp_id, state_id, StackController.NEXT);
    this.addTransition (state_id, this._last_comp_id, StackController.PRED);
    
    // create the second view 
    state = this._fsm._list_of_state [state_id];
    if (!state)
    {
      console.error ("Unknown error in vs.fx.StackController.push");
      return;
    }
    if (this._last_comp_id === this._initial_component)
    {
      if (!state.comp)
      {
        state.comp = this._owner.createAndAddComponent
          (state.comp_name, state.init_data, extension);
          
        state.comp.configure (state.init_data);
        state.comp.setStyle ('position', 'absolute');
        if (state.comp && state.comp.propertiesDidChange) 
        { 
          state.comp.propertiesDidChange ();
        }
        state.comp.propertyChange ();
      }
      
      state.comp.show ();
      state.comp.setStyle ('z-index', this.__nb_panels);
      this.configureNewComponent (state.comp);
    }
    else
    {
      if (state.comp)
      {
        state.comp.setStyle ('z-index', this.__nb_panels);
        this.configureNewComponent (state.comp);
      }
    }
    
    this._last_comp_id = state_id;
    return state_id;
  },
  
  /**
   * @protected
   * @function
   */
  configureNewComponent : function (comp)
  {
    var transform, delta_str, size;
          
    switch (this._animation_mode)
    {
      case SlideController.POURCENTAGE:
        delta_str = "100%";
      break;

      case SlideController.PIXEL:
        size = this._owner.size;
        
        if (this._orientation === SlideController.HORIZONTAL)
        {
          delta_str = size [0] + "px";
        }
        else if (this._orientation === SlideController.VERTICAL)
        {
          delta_str = size [1] + "px";
        }
      break;
    }

    if (this._orientation === SlideController.HORIZONTAL)
    {
      transform = "translate3D(" + delta_str + ",0,0)";
    }
    else if (this._orientation === SlideController.VERTICAL)
    {
      transform = "translate3D(0," + delta_str + ",0)";
    }

    comp.view.style.webkitTransitionDuration = '0';
    setElementTransform (comp.view, transform);
    comp.hide ();
  },

  /*********************************************************
   *                  Event management
   *********************************************************/
  /**
   * @protected
   * @function
   */
  handleEvent : function (event)
  {
    var t_ok = false, size = this.size,
      duration = this.__controller__._animation_duration;
          
    if (event.type === core.POINTER_START)
    {
      if (this.__controller__._orientation === SlideController.HORIZONTAL)
      {
        if (event.changedTouches)
        {  this.__pos = event.changedTouches[0].clientX; }
        else
        {  this.__pos = event.clientX; }
      }
      else
      {
        if (event.changedTouches)
        {  this.__pos = event.changedTouches[0].clientY; }
        else
        {  this.__pos = event.clientY; }
      }

      vs.addPointerListener (document, core.POINTER_END, this, true);
      vs.addPointerListener (document, core.POINTER_MOVE, this, true);
      
      this.animationDuration = 0;
      this.__delta = 0;
    }
    else if (event.type === core.POINTER_MOVE)
    {
      event.preventDefault ();
      if (this.__controller__._orientation === SlideController.HORIZONTAL)
      {
        if (event.changedTouches)
        {  this.__delta =  event.changedTouches[0].clientX - this.__pos; }
        else
        {  this.__delta = event.clientX - this.__pos; }
      }
      else
      {
        if (event.changedTouches)
        {  this.__delta =  event.changedTouches[0].clientY - this.__pos; }
        else
        {  this.__delta = event.clientY - this.__pos; }
      }  
    }
    else if (event.type === core.POINTER_END)
    {
      if (this.__delta > 50)
      {
        t_ok = this.__controller__.goToPreviousView ();
      }
      else if (this.__delta < -50)
      {
        t_ok = this.__controller__.goToNextView ();
      }
      if (!t_ok)
      {
        if (this.__controller__._orientation === SlideController.HORIZONTAL)
        {
          duration = Math.floor (duration * this.__delta / size [0]);
          this.animationDuration = duration;
        }
        else
        {
          duration = Math.floor (duration * this.__delta / size [1]);
          this.animationDuration = duration;
        }
      }
      vs.removePointerListener (document, core.POINTER_END, this, true);
      vs.removePointerListener (document, core.POINTER_MOVE, this, true);
    }
  },
  
  /**
   * @protected
   * @function
   */
  refresh: function ()
  {
    StackController.prototype.refresh.call (this);
    this._updateViewSize ();
  },
  
  /**
   *  @protected
   */
  _stackAnimateComponents : function (order, fromComp, toComp, clb, instant)
  {
    var animationIn = this._transition_in, animationOut,
      setPosition, durations_tmp;
    if (order > 0)
    {
      setPosition = this._transition_out_right;
      animationOut = this._transition_out_left;
    }
    else
    {
      setPosition = this._transition_out_left;
      animationOut = this._transition_out_right;
    }
    
    durations_tmp = setPosition.durations;
    setPosition.durations = '0s';
    
    var self = this, callback = function ()
    {
      fromComp.hide ();
      try
      {
        if (self._delegate && self._delegate.controllerAnimationDidEnd)
        {
          self._delegate.controllerAnimationDidEnd (fromComp, toComp, self);
        }
        if (clb) clb.call (self._owner);
      } catch (e) { if (e.stack) console.log (e.stack);console.error (e); }
    },
    
    runAnimation = function ()
    {
      setPosition.durations = durations_tmp;
      try
      {
        toComp.show ();
        toComp.refresh ();
        vs.scheduleAction (function () {
          if (instant)
          {
            var inDurations = animationIn.durations;
            animationIn.durations = '0s';
            var outDurations = animationOut.durations;
            animationOut.durations = '0s';
          }
          animationIn.process (toComp, callback, self);
          animationOut.process (fromComp); 

          if (instant)
          {
            animationIn.durations = inDurations;
            animationOut.durations = outDurations;
          }
        });
      }
      catch (e) { if (e.stack) console.log (e.stack);console.error (e); }
    };
    setPosition.process (toComp, function () {
      vs.scheduleAction (function () {runAnimation ();});
    });
  } 
});

/**
 * The duration of the animation between two views
 *
 * @name vs.fx.SlideController.ANIMATION_DURATION
 */
SlideController.ANIMATION_DURATION = 300;

/**
 * Horizontal slide (defaut)
 *
 * @name vs.fx.SlideController.HORIZONTAL
 * @const
 */
SlideController.HORIZONTAL = 0;

/**
 * Vertical slide
 *
 * @name vs.fx.SlideController.VERTICAL
 * @const
 */
SlideController.VERTICAL = 1;


/**
 * Horizontal slide (defaut)
 *
 * @name vs.fx.SlideController.POURCENTAGE
 * @const
 */
SlideController.POURCENTAGE = 0;

/**
 * Vertical slide
 *
 * @name vs.fx.SlideController.PIXEL
 * @const
 */
SlideController.PIXEL = 1;

/********************************************************************
                      Export
*********************************************************************/
/** @private */
fx.SlideController = SlideController;/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.fx.SwipeController class <br />
 *  This layer manage a list of children using a horizontal layout.
 *
 *  Children can be slided horizontally (right <-> left) or vertically 
 *  (top <-> bottom) using a pointing device (mouse, touch screen, ...),
 *  or using methods goToNextView and goToPreviousView.
 *  <p />
 *  By default the slider is horizontal, but you can change it using the 
 *  property "orientation".
 *  <p />
 *  The following example shows a typical example with panels
 *  (components 1 to 4) that are shows sequentially according user touch slide.
 *
 *  <pre>
 *                   (*)
 *                ⎡ˉˉˉˉˉˉˉˉˉˉˉˉ⎤
 *   ⎡ˉˉˉˉˉˉ⎤    ⎢ ⎡ˉˉˉˉˉˉ⎤ ⎢   ⎡ˉˉˉˉˉˉ⎤   ⎡ˉˉˉˉˉˉ⎤
 *   ⎟      ⎢    ⎢ ⎢      ⎢ ⎢   ⎟      ⎢   ⎟      ⎢
 *   ⎟  (1) ⎢    ⎢ ⎢  (2) ⎢ ⎢   ⎟  (3) ⎢   ⎟  (4) ⎢
 *   ⎟      ⎢    ⎢ ⎢      ⎢ ⎢   ⎟      ⎢   ⎟      ⎢
 *   ⎣______⎦    ⎢ ⎣______⎦ ⎢   ⎣______⎦   ⎣______⎦
 *                ⎣____________⎦
 *
 *
 *  (*) : device screen
 *  (1, ... ,4) : components managed by the SliderLayer
 *
 *   </pre>
 *
 *  <p>
 *  Delegate:
 *  <ul>
 *    <li/>controllerViewWillChange : function (from vs.ui.View, to vs.ui.View, controller),
 *         Called when the view changed
 *    <li/>controllerAnimationDidEnd : function (from vs.ui.View, to vs.ui.View, controller), Called just after 
 *         the animation ended
 *  </ul>
 *  <p>
 *  @example
 *  var layer = new vs.fx.SwipeController (myComp);
 *
 *  layer.push ('APanel', {id: '1', data: {...}});
 *  layer.push ('APanel', {id: '2', data: {...}});
 *  layer.push ('APanel', {id: '3', data: {...}});
 *  layer.push ('APanel', {id: '4', data: {...}});
 *
 *  @extends vs.fx.StackController
 * @name vs.fx.SwipeController
 *  @class
 * 
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.fx.SwipeController.
 *
 * @param {vs.ui.View} owner the View using this Layer [mandatory]
 */
var SwipeController = vs.core.createClass ({

  parent: vs.fx.StackController,
  
  /********************************************************************
                    protected members declarations
  ********************************************************************/
  /**
   * @protected
   * @function
   */
  _is_circular: false,

  /**
   * @protected
   * @function
   */
  _is_continuous_swipe: false,

  /**
   *
   * @protected
   * @type {number}
   */
  __delta : 0,
  __current_pos : 0,
  
  
  /**
   *
   * @protected
   * @type {number}
   */
  _orientation : 0,

  /********************************************************************
                    Define class properties
  ********************************************************************/

  properties: {
    'orientation': {
      /** 
       * Getter|Setter for page slide orientation. It can take the value
       * vs.fx.SwipeController.HORIZONTAL or vs.fx.SwipeController.VERTICAL.
       * By default the slider is horizontal.
       * @name vs.fx.SwipeController#orientation 
       * @type String
       */ 
      set : function (v)
      {
        var state, state_id, i = 0, pos = 0;
      
        if (v !== SwipeController.HORIZONTAL &&
            v !== SwipeController.VERTICAL) { return; }
      
        this._orientation = v;
        this._updateViewSize ();
      },
  
      /** 
       * @ignore
       * @return {String}
       */ 
      get : function ()
      {
        return this._orientation;
      }
    },

    'isTactile': {
      /** 
       * Getter|Setter for the tab bar style
       * @name vs.fx.StackController#isTactile 
       * @type {boolean}
       */ 
      set : function (v)
      {
        if (v)
        {
          this._is_tactile = true;
          if (!this._owner || !this._owner.view) return;
    
          if (!this._owner_handler_event_extended)
          {
            if (!this.__drag_recognizer)
            {
              this.__drag_recognizer = new ui.DragRecognizer (this);
              this._owner.addPointerRecognizer (this.__drag_recognizer);
            }           
          }
          this._owner_handler_event_extended = true;
        }
        else
        {
          this._is_tactile = false;
          if (!this._owner || !this._owner.view) return;
          
          if (this._owner_handler_event_extended)
          {

            if (this.__drag_recognizer)
            {
              this._owner.removePointerRecognizer (this.__drag_recognizer);
              this.__drag_recognizer = null;
            }
            this._owner_handler_event_extended = false;
          }
        }
      },
    
      /** 
       * @ignore
       * @return {boolean}
       */ 
      get : function ()
      {
        return this._is_tactile;
      }
    },
      
    'isCircular': {
      /** 
       * Getter|Setter for circular swipe
       * @name vs.fx.SwipeController#isCircular 
       * @type {boolean}
       */ 
      set : function (v)
      {
        if (v)
        {
          this._is_circular = true;
        }
        else
        {
          this._is_circular = false;
        }
      },
    
      /** 
       * @ignore
       * @return {boolean}
       */ 
      get : function ()
      {
        return this._is_circular;
      }
    },
    
    'isContinuousSwipe': {
      /** 
       * Getter|Setter Continuous Swipe
       * @name vs.fx.SwipeController#isContinuousSwipe 
       * @type {boolean}
       */ 
      set : function (v)
      {
        if (v)
        {
          this._is_continuous_swipe = true;
        }
        else
        {
          this._is_continuous_swipe = false;
        }
      },
    
      /** 
       * @ignore
       * @return {boolean}
       */ 
      get : function ()
      {
        return this._is_continuous_swipe;
      }
    }
  },

  constructor : function (owner)
  {
    this._super (owner);
    
    this._orientation = SwipeController.HORIZONTAL;

    if (!arguments.length) return;
  
    this.animationDuration = SwipeController.ANIMATION_DURATION;
  },

  /*********************************************************
   *                 behavior update
   *********************************************************/
  
  /**
   * @protected
   * @function
   */
  _updateViewSize : function ()
  {
    var i, state_id, state, delta, size = this._owner.size;
    
    if (this._orientation === SwipeController.HORIZONTAL)
    {
      delta = size [0];
    }
    else if (this._orientation === SwipeController.VERTICAL)
    {
      delta = size [1];
    }

    for (i = 0; i < this._states_array.length; i++)
    {
      state_id = this._states_array [i];
      state = this._fsm._list_of_state [state_id];
      
      if (!state || !state.comp) { continue; }
      
      // define transformation for view after current one
      if (this._orientation === SwipeController.HORIZONTAL)
      {
        state.comp.translate ((delta * i), 0, 0);
      }
      else if (this._orientation === SwipeController.VERTICAL)
      {
        state.comp.translate (0, (delta * i), 0);
      }
    } 
  },
  
  /**
   *  Add a child component to the Slider Manager
   *  <p>
   *  The component must be a graphic component (vs.ui.View).
   *  It will be instantiated, init and added automaticaly
   *  <p>
   *  The component instantiation is a lazy algorithm. The component will
   *  be instantiated and add into the DOM tree only when it has to be show
   *  to the user.
   *  <p>
   *  @example
   *  var myController = new vs.fx.SwipeController (this | myView);
   *  myController.init ();
   *  myController.push ('AComponent1', data1);
   *  myController.push ('AComponent1', data2);
   *  myController.push ('AComponent2', data3);
   *
   * @name vs.fx.SwipeController#push
   * @function
   *
   * @param {vs.ui.View | String} comp The GUI component or the component
   *     name to instanciate   
   * @param {Object} config Configuration structure need to build the component.
   * @param {Array} bindings Bindings configuration [[spec, observer, method], ...]
   */
  push : function (comp, data, extension, bindings)
  {
    if (!comp) { return; }
    if (!data) { data = {}; }
    
    var state_id = Controller.prototype.push.call
      (this, comp, data, extension, bindings);
    if (!state_id) { return; }
    
    this._states_array.push (state_id);
    this.__nb_panels ++; 

    // first item
    if (this.__nb_panels === 1)
    {
      this.initialComponent = state_id;
      this._last_comp_id = state_id;

      return state_id;
    }
    
    this.addTransition (this._last_comp_id, state_id, StackController.NEXT);
    this.addTransition (state_id, this._last_comp_id, StackController.PRED);
    this.addTransition 
      (state_id, this._initial_component, StackController.FIRST);

    this._last_state = state_id;
    
    // create the second view 
    state = this._fsm._list_of_state [state_id];
    if (!state)
    {
      console.error ("Unknown error in vs.fx.StackController.push");
      return;
    }
    if (this._last_comp_id === this._initial_component)
    {
      if (!state.comp)
      {
        state.comp = this._owner.createAndAddComponent
          (state.comp_name, state.init_data, extension);
          
        state.comp.configure (state.init_data);
        state.comp.setStyle ('position', 'absolute');
        if (state.comp && state.comp.propertiesDidChange) 
        { 
          state.comp.propertiesDidChange ();
        }
        state.comp.propertyChange ();
      }
      
      state.comp.show ();
      state.comp.setStyle ('z-index', this.__nb_panels);
      this.configureNewComponent (state.comp);
    }
    else
    {
      if (state.comp)
      {
        state.comp.setStyle ('z-index', this.__nb_panels);
        this.configureNewComponent (state.comp);
      }
    }
    
    this._last_comp_id = state_id;
    return state_id;
  },
  
  /**
   * @protected
   * @function
   */
  configureNewComponent : function (comp)
  {
    var size = this._owner.size;
    
    if (this._orientation === SwipeController.HORIZONTAL)
    {
      state.comp.translate (size [0] * (this.__nb_panels - 1), 0, 0);
    }
    else if (this._orientation === SwipeController.VERTICAL)
    {
      state.comp.translate (0, size [1] * (this.__nb_panels - 1), 0);
    }
    
//    comp.hide ();
  },

  /*********************************************************
   *                  Event management
   *********************************************************/
  /**
   * @protected
   * @function
   */   
  didDrag : function (drag_info, event) {
    if (this._orientation === SwipeController.HORIZONTAL)
      this.__delta = drag_info.dx;
    else
      this.__delta = drag_info.dy;
      
    if (this._is_continuous_swipe) {
    
      var carousel_div = this._owner._holes.children;
      carousel_div.style.webkitTransitionDuration = "0ms";
      
      setElementTransform (carousel_div,
        "translate3D(" +
        (this.__delta + this.__current_pos)
        + "px,0,0)");
    }
  },
  
  /**
   * @protected
   * @function
   */   
  didDragEnd : function () {
    var t_ok, previous_state, next_state, self = this;
    
    function cancelDrag () {
      var carousel_div = self._owner._holes.children;
      
      carousel_div.style.webkitTransitionDuration =
        self._animation_duration + "ms";

      if (self._orientation === SwipeController.HORIZONTAL)
        setElementTransform (carousel_div,
          "translate3D(" + self.__current_pos + "px,0,0)");
      else
        setElementTransform (carousel_div,
          "translate3D(0," + self.__current_pos + "px,0)");
    }
    
    if (this.__delta > 50)
    {
      previous_state = this._fsm.getAccessibleStateOn (StackController.PRED);
      if (!previous_state && this._is_circular)
        t_ok = this.goToLastView (null, null, -1);
      else t_ok = this.goToPreviousView ();

      if (!t_ok) cancelDrag ();
    }
    else if (this.__delta < -50)
    {
      next_state = this._fsm.getAccessibleStateOn (StackController.NEXT);
      if (!next_state && this._is_circular)
        t_ok = this.goToFirstView (null, null, 1);
      else t_ok = this.goToNextView ();
      
      if (!t_ok) cancelDrag ();
    }
    else if (this._is_continuous_swipe) {
      cancelDrag ();
    }
  },
   
  /**
   * @protected
   * @function
   */
  refresh: function ()
  {
    StackController.prototype.refresh.call (this);
    this._updateViewSize ();
  },
  
  /**
   *  @protected
   */
  _stackAnimateComponents : function (order, fromComp, toComp, clb, instant)
  {
    var
      size = this._owner.size,
      carousel_div = this._owner._holes.children,
      pos = this._states_array.indexOf (toComp.id);
  
    carousel_div.style.webkitTransitionDuration = "0ms";

    if (this._orientation === SwipeController.HORIZONTAL)
      this.__current_pos = pos * -size[0];
    else
      this.__current_pos = pos * -size[1];

    var self = this, callback = function ()
    {
//      fromComp.hide ();
      try
      {
        if (self._delegate && self._delegate.controllerAnimationDidEnd)
        {
          self._delegate.controllerAnimationDidEnd (fromComp, toComp, self);
        }
        if (clb) clb.call (self._owner);
      } catch (e) { if (e.stack) console.log (e.stack);console.error (e); }
    };
    
    function runAnimation ()
    {
      try
      {
        toComp.show ();
        toComp.refresh ();
        vs.scheduleAction (function () {
          if (instant) {
            carousel_div.style.webkitTransitionDuration = "0ms";
          }
          else {
            carousel_div.style.webkitTransitionDuration =
              self._animation_duration + "ms";
          }

          if (self._orientation === SwipeController.HORIZONTAL)
            setElementTransform (carousel_div,
              "translate3D(" + self.__current_pos + "px,0,0)");
          else
            setElementTransform (carousel_div,
              "translate3D(0," + self.__current_pos + "px,0)");
        });
      }
      catch (e) { if (e.stack) console.log (e.stack);console.error (e); }
    };
    runAnimation ();
  } 
});
util.extend (SwipeController.prototype, ui.RecognizerManager);

/**
 * The duration of the animation between two views
 *
 * @name vs.fx.SwipeController.ANIMATION_DURATION
 */
SwipeController.ANIMATION_DURATION = 300;

/**
 * Horizontal slide (defaut)
 *
 * @name vs.fx.SwipeController.HORIZONTAL
 * @const
 */
SwipeController.HORIZONTAL = 0;

/**
 * Vertical slide
 *
 * @name vs.fx.SwipeController.VERTICAL
 * @const
 */
SwipeController.VERTICAL = 1;

/**
 * Vertical slide
 *
 * @name vs.fx.SwipeController.PIXEL
 * @const
 */
SwipeController.PIXEL = 1;

/********************************************************************
                      Export
*********************************************************************/
/** @private */
fx.SwipeController = SwipeController;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.fx.NavigationController class implements a controller for navigating
 *  on hierarchical contents.
 *
 *  @extends vs.fx.Controller
 *
 *  @class
 *  The vs.fx.NavigationController class implements a controller for navigating
 *  on hierarchical contents.
 *  <p/>
 *  The controller shows a first view (the initialComponent) and allows to
 *  navigate from this first view to a second view and a third ... and back
 *  to the previous one til the first view.
 *  <p/>
 *  The next picture shows a example of hierarchical contents navigation.
 *
 *  <pre>                 
 *                
 *   ⎡ˉˉˉˉˉˉ⎤    ⎡ˉˉˉˉˉˉ⎤   ⎡ˉˉˉˉˉˉ⎤
 *   ⎟      ⎢__> ⎢      ⎢__>⎟      ⎢ 
 *   ⎟  (1) ⎢    ⎢  (2) ⎢   ⎟  (3) ⎢
 *   ⎟      ⎢<__ ⎢      ⎢<__⎟      ⎢
 *   ⎣______⎦    ⎣______⎦   ⎣______⎦
 *        | |   
 *        | |    ⎡ˉˉˉˉˉˉ⎤   ⎡ˉˉˉˉˉˉ⎤
 *        | ⎣__>⎢      ⎢-->⎟      ⎢
 *        | |    ⎢  (4) ⎢   ⎟  (5) ⎢ 
 *        | |<___⎢      ⎢<__⎟      ⎢
 *        |      ⎣______⎦   ⎣______
 *        |            |   
 *        |            |    ⎡ˉˉˉˉˉˉ⎤
 *        |            ⎣__>⎢      ⎢
 *        |            |    ⎢  (6) ⎢
 *        |            |<___⎢      ⎢
 *        |                 ⎣______⎦
 *        |   
 *        |    ⎡ˉˉˉˉˉˉ⎤
 *        ⎣__>⎢      ⎢
 *        |    ⎢  (7) ⎢
 *        |<___⎢      ⎢
 *             ⎣______⎦
 *
 * 
 *  (1, ... ,7) : component's views managed by the SliderLayer
 *
 *  </pre>
 *  The controller can manage a navigation bar during the user navigates.
 *  For instance it can hides or shows components (button, label, ...) and/or
 *  reconfigurate them. (for instance change the text value of a label.
 *  <p/>
 *  Example:
 *  <pre class='code'>
 *  this.controller = new vs.fx.NavigationController (this, this.navBar);
 *  this.controller.init ();
 *  
 *  // 1.1 put the first view into the controller
 *  this.controller.push (this.firstView);
 *  // 1.2 configure the navigation bar for the first view (nothing)
 *  this.controller.configureNavigationBarState (this.firstView.id, []);
 *  // 1.3 finally configure the first view as the initial component
 *  this.controller.initialComponent = this.firstView.id;
 *  
 *  var backId = this.navBar.backButton.id;
 *  var titleId = this.navBar.title.id;
 *
 *  // 2.1 set the second view, with parameters
 *  var id = this.controller.push ('PanelOne', {position: [0, 44]});
 *  // 2.2 configure the navigation bar to show the back button, the title
 *  //  and set the text title
 *  this.controller.configureNavigationBarState
 *    (id, [{comp: backId}, 
 *          {comp: titleId, properties: {text: 'Panel One'}}]);    
 *  // 2.3 configure the transition between the first and second view
 *  this.controller.configureTransition (this.firstView.id, id, 'goToOne');
 *  
 *  // 3 set the third view
 *  id = this.controller.push ('PanelTwo', {position: [0, 44]});
 *  this.controller.configureNavigationBarState
 *    (id, [{comp: backId}, 
 *          {comp: titleId, properties: {text: 'Panel Two'}}]);    
 *  this.controller.configureTransition (this.firstView.id, id, 'goToTwo');
 *  
 *  // 3 set the last view
 *  id = this.controller.push ('PanelThree', {position: [0, 44]});
 *  this.controller.configureNavigationBarState
 *    (id, [{comp: backId}, 
 *          {comp: titleId, properties: {text: 'Panel Three'}}]);    
 *  this.controller.configureTransition (this.firstView.id, id, 'goToThree');
 * 
 *  </pre>
 * 
 *  @author David Thevenin
 * @name vs.fx.NavigationController
 *
 *  @constructor
 *   Creates a new vs.fx.NavigationController.
 *
 * @param {vs.ui.View} owner the View using this Layer [mandatory]
 * @param {String} extension The hole into the vs.ui.View will be inserted. 
 *     ['children' by default]
 * @param {number} animationType Select the animation use during transition. 
 *     [optional]
 */
function NavigationController (owner, navBar, type)
{
  this.parent = Controller;
  this.parent (owner);
  this.constructor = NavigationController;
  
  if (!arguments.length) return;
  
  if (type == NavigationController.NO_ANIMATION ||
      type == NavigationController.CARD_ANIMATION ||
      type == NavigationController.SLIDE_ANIMATION)
  { this._animation_type = type; }
  
  else
  { this._animation_type = NavigationController.DEFAULT_ANIMATION; }
     
  this.setNavigationBar (navBar);
  
  this.__nav_bar_states = {};
}

/**
 *  There is no animation during transition between two views.
 *  <br />
 *  If the platform you are targeting does not support animations or
 *  does not support accelerated animations, you should use this
 *  configuration.
 *
 * @name vs.fx.NavigationController.NO_ANIMATION
 */
NavigationController.NO_ANIMATION = 0;

/**
 * There is card animation during transition between two views.
 *
 * @name vs.fx.NavigationController.CARD_ANIMATION
 */
NavigationController.CARD_ANIMATION = 1;

/**
 * There is slide animation during transition between two views.
 *  <br />
 *  This is the default configuration
 *
 * @name vs.fx.NavigationController.SLIDE_ANIMATION
 */
NavigationController.SLIDE_ANIMATION = 2;

/**
 * Select the default animation configuration (Slide animations)
 *
 * @name vs.fx.NavigationController.DEFAULT_ANIMATION
 */
NavigationController.DEFAULT_ANIMATION =
  NavigationController.SLIDE_ANIMATION;

/**
 * @private
 */
NavigationController.BACK = 'back';

NavigationController.prototype = {

  /**
   * @protected
   * @function
   */
  _nav_bar : null,

  /**
   * @protected
   * @function
   */
  __nav_bar_states : null,

  /**
   * @protected
   * @function
   */
  _animation_type : NavigationController.DEFAULT_ANIMATION,

 /**********************************************************************

  *********************************************************************/

  /**
   * @protected
   * @function
   */
  destructor: function ()
  {
    Controller.prototype.destructor.call (this);
  },

  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    Controller.prototype.initComponent.call (this);
   
    var size = this._owner.size;
    

    this.__translate_in_right = new TranslateAnimation (0);
    this.__translate_out_right = new Animation (['translate', '100%,0,0']);
    this.__translate_out_left = new Animation (['translate', '-100%,0,0']);
    this.__translate_in_left = new TranslateAnimation (0);
  },

  /**
   *  Defines the Navigation Bar
   *
   * @name vs.fx.NavigationController#setNavigationBar
   * @function
   *
   * @param {vs.ui.NavigationBar} navBar the ab bar
   */
  setNavigationBar : function (navBar)
  {
    if (!navBar || !navBar instanceof ui.NavigationBar) { return; }
    
    this._nav_bar = navBar;
  },
  
  /**
   * @protected
   * @function
   */
  _updateViewSize : function ()
  {},
  
  /**
   *  Add the a child component to the Navigation Controller
   *  <p>
   *  The component must be a graphic component (vs.ui.View).
   *  It will be instantiated, init and added automaticaly
   *  <p>
   *  The component instantiation is a lazy algorithm. The component will
   *  be instantiated and add into the DOM tree only when it has to be show
   *  to the user.
   *  <p>
   *  @example
   *  var myComp = new MyComp (conf);
   *  myComp.controller = new vs.fx.NavigationController (myComp);
   *
   *  // push a component name (the component will be instanciated when needs)
   *  myComp.controller.push ('AComponent1', {id: 'comp1'});
   *
   *  // instanciate a component and push it 
   *  var comp2 = myComp.createAndAddComponent ('AComponent1', {id: 'comp2'});
   *  myComp.controller.push (comp2);
   *
   *  // create a button object and push it
   *  var comp3 = new vs.ui.Button ({id: 'comp3', text: 'hello'});
   *  myComp.controller.push (comp3);
   *  myComp.controller.initComponent = comp2.id;
   *
   * @name vs.fx.NavigationController#push
   * @function
   *
   * @param {String | vs.ui.View} comp The GUI component name to instanciate or 
   *    the instance of the component  
   * @param {Object} config Configuration structure need to build the 
   *     component [optional]
   * @param {Array} bindings Bindings configuration [[spec, observer, method], ...]
   */
  push : function (comp, data, bindings)
  {
    if (!comp) { return; }
    if (!data) { data = {}; }
    
    var size, state_id =
      Controller.prototype.push.call (this, comp, data, null, bindings);
    if (!state_id) { return; }

    var state = this._fsm._list_of_state [state_id];
    if (state && state.comp)
    {
      this.configureNewComponent (state.comp);
    }

    return state_id;
  },
  
  /**
   *
   * @param {String} state The state (component id)  
   * @param {Array} configurations configuration parameters 
   *     Structure have to follow : [{comp: vs.core.Object|String, properties:{prop_name: value}}
   *
   * @name vs.fx.NavigationController#configureNavigationBarState
   * @function
   */
  configureNavigationBarState : function (state_id, configurations)
  {
    var state = this._fsm._list_of_state [state_id], comp, i, l, conf,
      components = [], state_conf = {};
    if (!state || !configurations)
    { return; }
    
    for (i = 0, l = configurations.length; i < l; i++)
    {
      conf = configurations [i];
      if (!conf) { continue; }
      
      comp = conf.comp;
      if (!comp) { continue; }
      
      // component is specified by an id
      if (util.isString (comp))
      { comp = core.Object._obs [comp]; }
      
      if (!comp instanceof vs.ui.View)
      { continue; }
      
      components.push (comp);
      if (conf.properties)
      {
        state_conf [comp.id] = conf.properties;
      }
    }
    
    this.__nav_bar_states [state_id] = state_conf;
    if (this._nav_bar)
    {
      this._nav_bar.setStateItems (state_id, components);
    }
  },
  
  /**
   *   Add a new transition from the state "from" to the state "to".
   *   The states have to be already specified.
   *
   * @name vs.fx.NavigationController#configureTransition
   * @function
   *
   * @param {string} from State from
   * @param {string} to State to
   * @param {string} on input lexem which cause the crossing of transition
   * @param {string} output optional ouput lexem that will be produce by the 
   *                  transition
   * @param {string} anim optional animation name
   */
  configureTransition : function (from, to, on)
  {
    if (!from || !this._fsm.existState (from)) { return; }
    if (!to || !this._fsm.existState (to)) { return; }
    if (!on) { return; }
    
    if (!this._fsm.existInput (on)) { this._fsm.addInput (on); }
    
    if (this._animation_type === NavigationController.SLIDE_ANIMATION)
    {
      this.addTransition (from, to, on,
        this.__translate_out_left, this.__translate_in_right);
        
      this.addTransition (to, from, NavigationController.BACK,
        this.__translate_out_right, this.__translate_in_left);

      this.__translate_in_left.duration = "300ms" 
      this.__translate_out_left.duration = "300ms" 
      this.__translate_in_right.duration = "300ms" 
      this.__translate_out_right.duration = "300ms" 
    }
    else if (this._animation_type === NavigationController.CARD_ANIMATION)
    {
      this.addTransition (from, to, on,
        null, this.__translate_in_right);
                
      this.addTransition (to, from, NavigationController.BACK,
        this.__translate_out_right, null);

      this.__translate_in_right.duration = "300ms" 
      this.__translate_out_right.duration = "300ms" 
    }
    else // no animation
    {
      this.addTransition (from, to, on,
        null, this.__translate_in_right);
                
      this.addTransition (to, from, NavigationController.BACK,
        this.__translate_out_right, null);

      this.__translate_in_right.duration = "0" 
      this.__translate_out_right.duration = "0" 
    }
  },
  

  /*********************************************************
   *                 FSM management
   *********************************************************/

  /**
   * @protected
   * @function
   */
  configureNewComponent : function (comp)
  {
    var animation = this.__translate_out_right,
      duration = animation.duration;
    
    // apply the transformation without animation
    animation.process (comp, null, null, true);
  },

  /**
   *  Private method use by the fsm to cross a transition.
   *  @note for the moment only one ouput lexem can be generation when
   *  crossing a transition
   *  @private
   *
   * @name vs.fx.NavigationController#goTo
   * @function
   *
   * @param {String} id_sate the id of target state.
   * @param {String} output
   * @param {Object} event the event
   */
  goTo : function (state_id, output, event, instant)
  {
    var ok = 
      Controller.prototype.goTo.call (this, state_id, output, event, instant);
 
    if (ok && this.owner._nav_bar)
    {
      this.owner._nav_bar.changeState
        (state_id, this.owner.__nav_bar_states [state_id]);
    }
  },
  
  /**
   *  do nothing, will be managed by _stackAnimateComponents
   *  @protected
   */
  _animateComponents : fx.Controller.prototype._animateComponents
};
util.extendClass (NavigationController, StackController);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (NavigationController, {
  'viewSize': {
   /** 
     * Getter|Setter for view size.
     * @name vs.fx.NavigationController#viewSize 
     *
     * @type {Array.<number>}
     */ 
    set : function (v)
    {
      if (!v) { return; } 
      if (!util.isArray (v) || v.length !== 2) { return; }
      if (!util.isNumber (v[0]) || !util.isNumber(v[1])) { return; }
      
      if (!this._view_size)
      { this._view_size = []; }
      
      this._view_size [0] = v [0];
      this._view_size [1] = v [1];
      
      this._updateViewSize ();
    },
  
    /**
     * @ignore
     * @type {Array.<number>}
     */
    get : function ()
    {
      if (!this._view_size)
      {
        return this._owner.size;
      }
      return this._view_size.slice ();
    }
  },
  'initialComponent': {
    /**
     *  Define the initiale component
     *  Generate a exception if the component was not already registered
     *
     * @name vs.fx.NavigationController#initialComponent 
     * @param {string} state_id the state
     */
    set : function (comp_id)
    {
      if (!comp_id)
      {
        this._initial_component = undefined;
        return;
      }
      
      if (!this._fsm.existState (comp_id)) { return; }
  
      // set initial state and go to it   
      this._initial_component = comp_id;
      this._fsm.initialState = comp_id;
      
      this._fsm.goTo (comp_id);
      var state = this._fsm._list_of_state [comp_id],
        animation = this.__translate_in_right,
        duration = animation.duration;
          
      if (state && state.comp)
      {
        // apply the transformation without animation
        animation.process (state.comp, null, null, true);
      }
    },
    
    /**
     * @ignore
     */
    get : function ()
    {
      return this._initial_component;
    }
  }
});
/********************************************************************
                      Export
*********************************************************************/
/** @private */
fx.NavigationController = NavigationController;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.fx.CardController class <br />
 *  @class
 *  This layer manage a list of children using a card style animation.
 *  <p />
 *  Children can be slided horizontally (right <-> left) or vertically 
 *  (top <-> bottom) using a pointing device (mouse, touch screen, ...),
 *  or using methods goToNextView and goToPreviousView.
 *  <p />
 *  By default the card slide to left out. You can change it using the 
 *  property "direction". You can configure it with four directions:
 *  <ul>
 *    <li>vs.fx.CardController.LEFT_OUT
 *    <li>vs.fx.CardController.RIGHT_OUT
 *    <li>vs.fx.CardController.TOP_OUT
 *    <li>vs.fx.CardController.BOTTOM_OUT
 *  </ul>
 *  <p />
 *  The following example shows a typical example with panels
 *  (components 1 to 3).
 *
 *  <pre style="font-family:courier">
 *                   (*)
 *                ⎡ˉˉˉˉˉˉˉˉˉˉˉˉˉ⎤
 *   ⎡(1)ˉˉˉ⎤    ⎢ ⎡(2)ˉˉˉ⎤  ⎢
 *   ⎟      ⎢    ⎢ ⎢⎡(3)ˉ⎢ˉ⎤⎢
 *   ⎟      ⎢    ⎢ ⎢⎢    ⎢ ⎢⎢
 *   ⎟      ⎢    ⎢ ⎢⎢    ⎢ ⎢⎢
 *   ⎣______⎦    ⎢ ⎣______⎦ ⎢⎢
 *                ⎢   ⎣_______⎦⎢
 *                ⎣_____________⎦
 *
 *                   (*)
 *                ⎡ˉˉˉˉˉˉˉˉˉˉˉˉˉ⎤
 *   ⎡(2)ˉˉˉ⎤    ⎢ ⎡(3)ˉˉˉ⎤  ⎢
 *   ⎢⎡(1)ˉ⎢ˉ⎤ ⎢ ⎢       ⎢  ⎢
 *   ⎢⎢    ⎢ ⎢ ⎢ ⎢       ⎢  ⎢
 *   ⎢⎢    ⎢ ⎢ ⎢ ⎢       ⎢  ⎢
 *   ⎣______⎦ ⎢ ⎢ ⎣______⎦   ⎢
 *     ⎣______⎦  ⎢             ⎢
 *                ⎣_____________⎦
 *
 *
 *  (*) : device screen
 *  (1, ...,3) : components managed by the CardLayer
 *
 *   </pre>
 *
 *  <p>
 *  Delegate:
 *  <ul>
 *    <li/>controllerViewWillChange : function (from vs.ui.View, to vs.ui.View, controller),
 *         Called when the view changed
 *    <li/>controllerAnimationDidEnd : function (from vs.ui.View, to vs.ui.View, controller), Called just after 
 *         the animation ended
 *  </ul>
 *  <p>
 *  @example
 *  var myController = new vs.fx.CardController (myComp);
 *  myLayer.init ();
 *
 *  myController.push ('APanel', {id: '1', data: {...}});
 *  myController.push ('APanel', {id: '2', data: {...}});
 *  myController.push ('APanel', {id: '3', data: {...}});
 *  myController.push ('APanel', {id: '4', data: {...}});
 *
 *  @extends vs.fx.StackController
 * @name vs.fx.CardController
 * 
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.fx.CardController.
 *
 * @param {vs.ui.View} owner the View using this Layer [mandatory]
 * @param {String} extension The hole into the vs.ui.View will be inserted. 
 *     ['children' by default]
 */
var CardController = vs.core.createClass ({

  parent: vs.fx.StackController,

  /********************************************************************
                    protected members declarations
  ********************************************************************/
  
  /**
   *
   * @protected
   * @type {number}
   */
  _direction : 0,

  /**
   *
   * @protected
   * @type {vs.fx.TranslateAnimation}
   */
  _transition_out : null,
  
  /**
   *
   * @protected
   * @type {vs.fx.TranslateAnimation}
   */
  _transition_in : null,  

  /********************************************************************
                    Define class properties
  ********************************************************************/

  properties : {

    'direction': {
      /** 
       * Getter|Setter Card slide direction 
       * @name vs.fx.CardController#direction 
       * @type String
       */ 
      set : function (v)
      {
        var state, state_id, i = 0, pos = 0, index, transform = '';
      
        if (v !== CardController.LEFT_OUT &&
            v !== CardController.RIGHT_OUT &&
            v !== CardController.BOTTOM_OUT &&
            v !== CardController.TOP_OUT) { return; }
      
        this._direction = v;
        this._updateViewSize ();
      },
  
      /** 
       * @ignore
       * @return {String}
       */ 
      get : function ()
      {
        return this._direction;
      }
    },

    'animationDuration': {
      /** 
       * Set the animation/transition temporisation (in millisecond)
       * @name vs.fx.CardController#animationDuration 
       * @type {number}
       */ 
      set : function (v)
      {
        if (!v) { v = 0; }
        if (!util.isNumber (v)) { return };
      
        this._animation_duration = v;
        if (this._transition_out)
          this._transition_out.duration = this._animation_duration + 'ms';
        if (this._transition_in)
          this._transition_in.duration = this._animation_duration + 'ms';
      }
    }
  },
  
  constructor : function (owner)
  {
    this._super (owner);

    if (owner)
    {
      this._transition_out = new Animation (['translate', '${x}%,${y}%,0']);
      this._transition_out.x = 0;
      this._transition_out.y = 0;
      
      this._transition_in = new Animation (['translate', '${x}%,${y}%,0']);
      this._transition_in.x = 0;
      this._transition_in.y = 0;
  
      this.animationDuration = CardController.ANIMATION_DURATION;
    }

    this._direction = CardController.RIGHT_OUT;
  },

  /*********************************************************
   *                behavior update
   *********************************************************/
  
  /**
   * @protected
   * @function
   */
  _updateViewSize : function ()
  {
    if (!this._transition_out) return;
    
    if (this._direction === CardController.LEFT_OUT)
    {
      this._transition_out.x = -100;
      this._transition_out.y = 0;
    }
    else if (this._direction === CardController.RIGHT_OUT)
    {
      this._transition_out.x = 100;
      this._transition_out.y = 0;
    }
    else if (this._direction === CardController.BOTTOM_OUT)
    {
      this._transition_out.x = 0;
      this._transition_out.y = 100;
    }
    else
    {
      this._transition_out.x = 0;
      this._transition_out.y = -100;
    }
  },

  /*********************************************************
   *                  Event management
   *********************************************************/

  /**
   *  Add a child component to the Slider Manager
   *  <p>
   *  The component must be a graphic component (vs.ui.View).
   *  It will be instantiated, init and added automaticaly
   *  <p>
   *  The component instantiation is a lazy algorithm. The component will
   *  be instantiated and add into the DOM tree only when it has to be show
   *  to the user.
   *  <p>
   *  @example
   *  var myController = new vs.fx.CardController (this | myView);
   *  myController.init ();
   *  myController.push ('AComponent1', data1);
   *  myController.push ('AComponent1', data2);
   *  myController.push ('AComponent2', data3);
   *
   * @name vs.fx.CardController#push
   * @function
   *
   * @param {vs.ui.View | String} comp The GUI component or the component
   *     name to instanciate   
   * @param {Object} config Configuration structure need to build the component.
   * @param {Array} bindings Bindings configuration [[spec, observer, method], ...]
   */
  push : function (comp, data, extension, bindings)
  {
    if (!comp) { return; }
    if (!data) { data = {}; }
    
    var state_id = Controller.prototype.push.call
      (this, comp, data, extension, bindings);
    if (!state_id) { return; }
    
    this._states_array.push (state_id);
    this.__nb_panels ++; 

    // first item
    if (this.__nb_panels === 1)
    {
      this.initialComponent = state_id;
      this._last_comp_id = state_id;

      return state_id;
    }
    
    this.addTransition (this._last_comp_id, state_id, StackController.NEXT);
    this.addTransition (state_id, this._last_comp_id, StackController.PRED);
   
    // create the second view 
    state = this._fsm._list_of_state [state_id];
    if (!state)
    {
      console.error ("Unknown error in vs.fx.CardController.push");
      return;
    }
    if (this._last_comp_id === this._initial_component)
    {
      if (!state.comp)
      {
        state.comp = this._owner.createAndAddComponent
          (state.comp_name, state.init_data, extension);
          
        state.comp.configure (state.init_data);
        state.comp.setStyle ('position', 'absolute');
        if (state.comp && state.comp.propertiesDidChange) 
        { 
          state.comp.propertiesDidChange ();
        }
        state.comp.propertyChange ();
      }
      
      state.comp.show ();
      state.comp.setStyle ('z-index', this.__nb_panels);
      this.configureNewComponent (state.comp);
    }
    else
    {
      if (state.comp)
      {
        state.comp.setStyle ('z-index', this.__nb_panels);
        this.configureNewComponent (state.comp);
      }
    }
    
    this._last_comp_id = state_id;
    return state_id;
  },
  
  /**
   * @protected
   * @function
   */
  configureNewComponent : function (comp)
  {
    var transform;
    
    if (SUPPORT_3D_TRANSFORM) transform = "translate3d";
    else transform = "translate";
    if (this._direction === CardController.LEFT_OUT)
    {
      transform += "(-100%,0";
    }
    else if (this._direction === CardController.RIGHT_OUT)
    {
      transform += "(100%,0";
    }
    else if (this._direction === CardController.BOTTOM_OUT)
    {
      transform += "(0,100%";
    }
    else
    {
      transform += "(0,-100%";
    }
    if (SUPPORT_3D_TRANSFORM) transform += ",0)";
    else transform += ")";

    comp.view.style.webkitTransitionDuration = '0';
    setElementTransform (comp.view, transform);
  },

  /**
   * @protected
   * @function
   */
  handleEvent : function (event)
  {
    var t_ok = false, state, state_before_id, state_before, transform, index;
    
    if (event.type === core.POINTER_START)
    {
      if (this.__controller__._direction === CardController.LEFT_OUT ||
          this.__controller__._direction === CardController.RIGHT_OUT)
      {
        if (event.changedTouches)
        {  this.__pos = event.changedTouches[0].clientX; }
        else
        {  this.__pos = event.clientX; }
      }
      else
      {
        if (event.changedTouches)
        {  this.__pos = event.changedTouches[0].clientY; }
        else
        {  this.__pos = event.clientY; }
      }

      vs.addPointerListener (document, core.POINTER_END, this, true);
      vs.addPointerListener (document, core.POINTER_MOVE, this, true);
    }
    else if (event.type === core.POINTER_MOVE)
    {
      event.preventDefault ();
      state = this.__controller__._fsm._list_of_state 
        [this.__controller__._fsm._current_state];
      index = this.__controller__._states_array.indexOf 
        (this.__controller__._fsm._current_state)
      
      if (index > 0)
      { state_before_id = this.__controller__._states_array [index-1]; }
      
      if (this.__controller__._direction === CardController.LEFT_OUT ||
          this.__controller__._direction === CardController.RIGHT_OUT)
      {
        if (event.changedTouches)
        {  this.__delta =  event.changedTouches[0].clientX - this.__pos; }
        else
        {  this.__delta = event.clientX - this.__pos; }
      
        if (SUPPORT_3D_TRANSFORM)
        { transform = "translate3d("+this.__delta+"px,0px,0)"; }
        else transform = "translate("+this.__delta+"px,0px)";
      }
      else
      {
        if (event.changedTouches)
        { this.__delta =  event.changedTouches[0].clientY - this.__pos; }
        else
        { this.__delta = event.clientY - this.__pos; }
      
        if (SUPPORT_3D_TRANSFORM)
        { transform = "translate3d(0px,"+this.__delta+"px,0)"; }
        else transform = "translate(0px,"+this.__delta+"px)";
      }
      if (this.__controller__._direction === CardController.LEFT_OUT ||
          this.__controller__._direction === CardController.TOP_OUT)
      {
        if (this.__delta < 0)
        {
          state.comp.view.style.webkitTransitionDuration = 0;
          setElementTransform (state.comp.view, transform);
        }
        else if (state_before_id)
        {
          state_before =
            this.__controller__._fsm._list_of_state [state_before_id];
          if (state_before && state_before.comp)
          {
            if (this.__controller__._direction === CardController.LEFT_OUT ||
                this.__controller__._direction === CardController.RIGHT_OUT)
            {
              if (SUPPORT_3D_TRANSFORM)
              {
                transform = 
                  "translate3d("+(this.__delta-this._size[0])+"px,0px,0)";
              }
              else transform = 
                "translate("+(this.__delta-this._size[0])+"px,0px)";
            }
            else
            {
              if (SUPPORT_3D_TRANSFORM)
              {
                transform = 
                  "translate3d(0px,"+(this.__delta-this._size[1])+"px,0)";
              }
              else transform = 
                "translate(0px,"+(this.__delta-this._size[1])+"px)";
            }  
            state_before.comp.view.style.webkitTransitionDuration = 0;
            setElementTransform (state_before.comp.view, transform);
          }
        }
      }
      else
      {
        if (this.__delta > 0)
        {
          state.comp.view.style.webkitTransitionDuration = 0;
          setElementTransform (state.comp.view, transform);
        }
        else if (state_before_id)
        {
          state_before = this.__controller__._fsm._list_of_state [state_before_id];
          if (state_before && state_before.comp)
          {
            if (this.__controller__._direction === CardController.LEFT_OUT ||
                this.__controller__._direction === CardController.RIGHT_OUT)
            {
              if (SUPPORT_3D_TRANSFORM)
              {
                transform = 
                  "translate3d("+(this._size[0]+this.__delta)+"px,0px,0)";
              }
              else transform = 
                "translate("+(this._size[0]+this.__delta)+"px,0px)";
            }
            else
            {
              if (SUPPORT_3D_TRANSFORM)
              {
                transform = 
                  "translate3d(0px,"+(this._size[1]+this.__delta)+"px,0)";
              }
              else transform = 
                "translate(0px,"+(this._size[1]+this.__delta)+"px)";
            }  
            state_before.comp.view.style.webkitTransitionDuration = 0;
            setElementTransform (state_before.comp.view, transform);
          }
        }
      }
    }
    else if (event.type === core.POINTER_END)
    {
      state = this.__controller__._fsm._list_of_state   
        [this.__controller__._fsm._current_state];
      if (this.__controller__._direction === CardController.LEFT_OUT ||
          this.__controller__._direction === CardController.TOP_OUT)
      {
        if (this.__delta > 50)
        {
          t_ok = this.__controller__.goToPreviousView ();
        }
        else if (this.__delta < -50)
        {
          t_ok = this.__controller__.goToNextView ();
        }
      }
      else
      {
        if (this.__delta > 50)
        {
          t_ok = this.__controller__.goToNextView ();
        }
        else if (this.__delta < -50)
        {
          t_ok = this.__controller__.goToPreviousView ();
        }
      }
      if (!t_ok)
      {
        index = this.__controller__._states_array.indexOf (this.__controller__._fsm._current_state)
        
        if (index > 0)
        { state_before_id = this.__controller__._states_array [index-1]; }
        
        if ((this.__controller__._direction === CardController.LEFT_OUT ||
            this.__controller__._direction === CardController.TOP_OUT) &&
            this.__delta < 0)
        {
          if (SUPPORT_3D_TRANSFORM)
          { transform = "translate3d(0,0,0)"; }
          else transform = "translate(0,0)";

          state.comp.view.style.webkitTransitionDuration =
            this.__controller__._animation_duration + 'ms';
          setElementTransform (state.comp.view, transform);
        }
        else if ((this.__controller__._direction === CardController.RIGHT_OUT ||
            this.__controller__._direction === CardController.BOTTOM_OUT) &&
            this.__delta > 0)
        {
          if (SUPPORT_3D_TRANSFORM)
          { transform = "translate3d(0,0,0)"; }
          else transform = "translate(0,0)";

          state.comp.view.style.webkitTransitionDuration =
            this.__controller__._animation_duration + 'ms';
          setElementTransform (state.comp.view, transform);
        }
        else if (state_before_id)
        {
          state_before = this.__controller__._fsm._list_of_state [state_before_id];
          if (state_before && state_before.comp)
          {
            if (SUPPORT_3D_TRANSFORM) transform = "translate3d";
            else transform = "translate";

            if (this.__controller__._direction === CardController.LEFT_OUT)
            {
              transform = "(-100%,0px"; 
            }
            else if (this.__controller__._direction === CardController.RIGHT_OUT)
            {
              transform = "(100%,0px"; 
            }
            else if (this.__controller__._direction === CardController.BOTTOM_OUT)
            {
              transform = "(0px,100%"; 
            }
            else
            {
              transform = "(0px,-100%"; 
            }    
            if (SUPPORT_3D_TRANSFORM) transform += ",0)";
            else transform += ")";

            state_before.comp.view.style.webkitTransitionDuration =
              this.__controller__._animation_duration + 'ms';
            setElementTransform (state_before.comp.view, transform);
          }
        }
      }
      vs.removePointerListener (document, core.POINTER_END, this, true);
      vs.removePointerListener (document, core.POINTER_MOVE, this, true);
    }
  },
  
  /**
   *  @protected
   */
  _stackAnimateComponents : function (order, fromComp, toComp, clb, instant)
  {
    var animation, setInitialPosAnimation, durations_tmp,
      compToAnimate;

    if (order > 0)
    {
      animation = this._transition_in;
      compToAnimate = toComp;
    }
    else
    {
      animation = this._transition_out;
      setInitialPosAnimation = this._transition_in;
      compToAnimate = fromComp;
    }

    if (setInitialPosAnimation)
    {
      durations_tmp = setInitialPosAnimation.durations;
      setInitialPosAnimation.durations = '0s';
    }
    var self = this, callback = function ()
    {
      fromComp.hide ();
      try
      {
        if (self._delegate && self._delegate.controllerAnimationDidEnd)
        {
          self._delegate.controllerAnimationDidEnd (fromComp, toComp, self);
        }
        if (clb) clb.call (this.owner);
      }
      catch (e) {
        if (e.stack) console.log (e.stack);
        console.error (e);
      }
    },
    
    runAnimation = function ()
    {
      if (setInitialPosAnimation)
        setInitialPosAnimation.durations = durations_tmp;
      try
      {
        toComp.show ();
        if (instant)
        {
          var inDurations = animation.durations;
          animation.durations = '0s';
        }
        animation.process (compToAnimate, callback, self);

        if (instant)
        {
          animation.durations = inDurations;
        }
      }
      catch (e) {
        if (e.stack) console.log (e.stack);
        console.error (e);
      }
    };
    if (setInitialPosAnimation) setInitialPosAnimation.process (toComp, function () {
      vs.scheduleAction (function () {runAnimation ();});
    });
    else runAnimation ();
  } 
});

/**
 * The duration of the animation between two views
 * @name vs.fx.CardController.ANIMATION_DURATION
 */
CardController.ANIMATION_DURATION = 300;

/**
 * Left out card slide
 * @name vs.fx.CardController.LEFT_OUT
 * @const
 */
CardController.LEFT_OUT = 0;

/**
 * Right out card slide (defaut)
 * @name vs.fx.CardController.RIGHT_OUT
 * @const
 */
CardController.RIGHT_OUT = 1;

/**
 * Top out card slide
 * @name vs.fx.CardController.TOP_OUT
 * @const
 */
CardController.TOP_OUT = 2;

/**
 * Bottom out card slide
 * @name vs.fx.CardController.BOTTOM_OUT
 * @const
 */
CardController.BOTTOM_OUT = 3;

/********************************************************************
                      Export
*********************************************************************/
/** @private */
fx.CardController = CardController;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.fx.CubicController class <br />
 *  @class
 *  This layer manage a list of children using a card layout.
 *  <p />
 *  Children can be slided horizontally (right <-> left) or vertically 
 *  (top <-> bottom) using a pointing device (mouse, touch screen, ...),
 *  or using methods goToNextView and goToPreviousView.
 *  <p />
 *  By default the slider is horizontal, but you can change it using the 
 *  property "orientation".
 *  <p />
 *  The following example shows a typical example with panels
 *  (components 1 to 3).
 *
 *  <pre style="font-family:courier">
 *                   (*)
 *                ⎡ˉˉˉˉˉˉˉˉˉˉˉˉˉ⎤
 *   ⎡(1)ˉˉˉ⎤    ⎢ ⎡(2)ˉˉˉ⎤  ⎢
 *   ⎟      ⎢    ⎢ ⎢⎡(3)ˉ⎢ˉ⎤⎢
 *   ⎟      ⎢    ⎢ ⎢⎢    ⎢ ⎢⎢
 *   ⎟      ⎢    ⎢ ⎢⎢    ⎢ ⎢⎢
 *   ⎣______⎦    ⎢ ⎣______⎦ ⎢⎢
 *                ⎢   ⎣_______⎦⎢
 *                ⎣_____________⎦
 *
 *                   (*)
 *                ⎡ˉˉˉˉˉˉˉˉˉˉˉˉˉ⎤
 *   ⎡(2)ˉˉˉ⎤    ⎢ ⎡(3)ˉˉˉ⎤  ⎢
 *   ⎢⎡(1)ˉ⎢ˉ⎤ ⎢ ⎢       ⎢  ⎢
 *   ⎢⎢    ⎢ ⎢ ⎢ ⎢       ⎢  ⎢
 *   ⎢⎢    ⎢ ⎢ ⎢ ⎢       ⎢  ⎢
 *   ⎣______⎦ ⎢ ⎢ ⎣______⎦   ⎢
 *     ⎣______⎦  ⎢             ⎢
 *                ⎣_____________⎦
 *
 *
 *  (*) : device screen
 *  (1, ...,3) : components managed by the CardLayer
 *
 *   </pre>
 *
 *  <p>
 *  Delegate:
 *  <ul>
 *    <li/>controllerViewWillChange : function (from vs.ui.View, to vs.ui.View, controller), Called when the view
 *        changed
 *  </ul>
 *  <p>
 *  @example
 *  theApplicatioin.layer = new vs.fx.CubicController (myComp);
 *
 *  myComp.layer.push ('APanel', {id: '1', data: {...}});
 *  myComp.layer.push ('APanel', {id: '2', data: {...}});
 *  myComp.layer.push ('APanel', {id: '3', data: {...}});
 *  myComp.layer.push ('APanel', {id: '4', data: {...}});
 *
 *  @extends vs.fx.StackController
 * 
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.ui.View.
 *
 * @param {vs.ui.View} owner the View using this Layer [mandatory]
 * @param {String} extension The hole into the vs.ui.View will be inserted. 
 *     ['children' by default]
 */
function CubicController (owner, extension)
{
  this.parent = StackController;
  this.parent (owner, extension);
  this.constructor = CubicController;
  
  if (owner) owner.setStyle ('-webkit-transform-style', 'preserve-3d');
  
/********************************************************************
                  setter and getter declarations
********************************************************************/
}

CubicController._translate_animation = new RotateXYZAnimation (-90,0,0);
CubicController._translate_animation.init ();
CubicController._translate_animation.addKeyFrame ('from', {degX:0});
CubicController._translate_animation.addKeyFrame (50, {degX:-92});
CubicController._translate_animation.addKeyFrame (70, {degX:-84});
CubicController._translate_animation.addKeyFrame (80, {degX:-90});
CubicController._translate_animation.addKeyFrame (95, {degX:-88});
CubicController._translate_animation.durations = "2s";

/**
 * Horizontal slide (defaut)
 * @const
 */
CubicController.HORIZONTAL = 0;

/**
 * Vertical slide
 * @const
 */
CubicController.VERTICAL = 1;


CubicController.prototype = {

/********************************************************************
                  protected members declarations
********************************************************************/
  
  /**
   *
   * @protected
   * @type {number}
   */
  _orientation : CubicController.HORIZONTAL,

/********************************************************************

********************************************************************/
  
  /**
   *  Add a child component to the Slider Manager
   *  <p>
   *  The component must be a graphic component (vs.ui.View).
   *  It will be instantiated, init and added automaticaly
   *  <p>
   *  The component instantiation is a lazy algorithm. The component will
   *  be instantiated and add into the DOM tree only when it has to be show
   *  to the user.
   *  <p>
   *  @example
   *  var myComp = new MyComp (conf);
   *  myComp.layer = new vs.fx.StackController (myComp, 'children');
   *  myComp.layer.push ('AComponent1', data1);
   *  myComp.layer.push ('AComponent1', data2);
   *  myComp.layer.push ('AComponent2', data3);
   *
   * @name vs.fx.CubicController#push
   * @function
   *
   * @param {vs.ui.View | String} comp The GUI component or the component
   *     name to instanciate   
   * @param {Object} config Configuration structure need to build the component.
   * @param {Array} bindings Bindings configuration [[spec, observer, method], ...]
   */
  push : function (comp, data, bindings)
  {
    if (!comp) { return; }
    
    if (!util.isString (comp))
    {
      var index = this._states_array.length;
      comp.position = [0, 0];
      comp.setStyle ('z-index', 1000 - index);
    }
    return StackController.prototype.push.call
      (this, comp, data, bindings);
  },
  
/*********************************************************
 *                  Event management
 *********************************************************/
  /**
   * @protected
   * @function
   */
  handleEvent : function (event)
  {
    var t_ok = false, state, state_before_id, state_before, transform, index;
    
    if (event.type === core.POINTER_START)
    {
      if (this.__layer._orientation === CubicController.HORIZONTAL)
      {
        if (event.changedTouches)
        {  this.__pos = event.changedTouches[0].clientX; }
        else
        {  this.__pos = event.clientX; }
      }
      else
      {
        if (event.changedTouches)
        {  this.__pos = event.changedTouches[0].clientY; }
        else
        {  this.__pos = event.clientY; }
      }

      vs.addPointerListener (document, core.POINTER_END, this, true);
      vs.addPointerListener (document, core.POINTER_MOVE, this, true);
      
      this.animationDuration = 0;
    }
    else if (event.type === core.POINTER_MOVE)
    {
      event.preventDefault ();
      state = this.__layer._list_of_state [this.__layer._current_state];
      index = this.__layer._states_array.indexOf (this.__layer._current_state)
      
      if (index > 0) { state_before_id = this.__layer._states_array [index-1]; }
      
      if (this.__layer._orientation === CubicController.HORIZONTAL)
      {
        if (event.changedTouches)
        {  this.__delta =  event.changedTouches[0].clientX - this.__pos; }
        else
        {  this.__delta = event.clientX - this.__pos; }
      
        if (SUPPORT_3D_TRANSFORM)
        { transform = "translate3d("+this.__delta+"px,0px,0)"; }
        else transform = "translate("+this.__delta+"px,0px)";
      }
      else
      {
        if (event.changedTouches)
        {  this.__delta =  event.changedTouches[0].clientY - this.__pos; }
        else
        {  this.__delta = event.clientY - this.__pos; }
      
        if (SUPPORT_3D_TRANSFORM)
        { transform = "translate3d(0px,"+this.__delta+"px,0)"; }
        else transform = "translate(0px,"+this.__delta+"px)";
      }  
      if (this.__delta < 0)
      {
        state.comp.view.style.webkitTransitionDuration = 0;
        setElementTransform (state.comp.view, transform);
      }
      else if (state_before_id)
      {
        state_before = this.__layer._list_of_state [state_before_id];
        if (state_before && state_before.comp)
        {
          if (this.__layer._orientation === CubicController.HORIZONTAL)
          {
            if (SUPPORT_3D_TRANSFORM)
            {
              transform = 
                "translate3d("+(this.__delta-this._size[0])+"px,0px,0)";
            }
            else transform = 
              "translate("+(this.__delta-this._size[0])+"px,0px)";
          }
          else
          {
            if (SUPPORT_3D_TRANSFORM)
            {
              transform = 
                "translate3d(0px,"+(this.__delta-this._size[1])+"px,0)";
            }
            else transform = 
              "translate(0px,"+(this.__delta-this._size[1])+"px)";
          }  
          state_before.comp.view.style.webkitTransitionDuration = 0;
          setElementTransform (state_before.comp.view, transform);
        }
      }
    }
    else if (event.type === core.POINTER_END)
    {
      state = this.__layer._list_of_state [this.__layer._current_state];
      if (this.__delta > 50)
      {
        t_ok = this.__layer.goToPreviousView ();
      }
      else if (this.__delta < -50)
      {
        t_ok = this.__layer.goToNextView ();
      }
      if (!t_ok)
      {
        index = this.__layer._states_array.indexOf (this.__layer._current_state)
        
        if (index > 0)
        { state_before_id = this.__layer._states_array [index-1]; }
        
        if (this.__delta < 0)
        {
          if (SUPPORT_3D_TRANSFORM)
          { transform = "translate3d(0,0,0)"; }
          else transform = "translate(0,0)";

          state.comp.view.style.webkitTransitionDuration =
            this.__layer._animation_duration + 'ms';
          setElementTransform (state.comp.view, transform);
        }
        else if (state_before_id)
        {
          state_before = this.__layer._list_of_state [state_before_id];
          if (state_before && state_before.comp)
          {
            if (this.__layer._orientation === CubicController.HORIZONTAL)
            {
              if (SUPPORT_3D_TRANSFORM)
              {
                transform = 
                  "translate3d("+this._size[0]+"px,0px,0)";
              }
              else transform = 
                "translate("+this._size[0]+"px,0px)";
            }
            else
            {
              if (SUPPORT_3D_TRANSFORM)
              {
                transform = 
                  "translate3d(0px,-"+this._size[1]+"px,0)";
              }
              else transform = 
                "translate(0px,-"+this._size[1]+"px)";
            }  
            state_before.comp.view.style.webkitTransitionDuration =
              this.__layer._animation_duration + 'ms';
            setElementTransform (state_before.comp.view, transform);
          }
        }
      }
      vs.removePointerListener (document, core.POINTER_END, this, true);
      vs.removePointerListener (document, core.POINTER_MOVE, this, true);
    }
  },
  
  /**
   *  Private method use by the fsm to cross a transition.
   *  @note for the moment only one ouput lexem can be generation when
   *  crossing a transition
   *  @private
   *
   * @name vs.fx.CubicController#goTo
   * @function
   *
   * @param {String} id_sate the id of target state.
   * @param {String} output
   * @param {Object} event the event
   */
  goTo : function (state_id, output, event)
  {
    var state_to, index = this._states_array.indexOf (state_id), 
      state_from = this._list_of_state [this._current_state];
    // manage output
    // TODO WARNING
        
    StackController.prototype.goTo.call (this, state_id, output, event);
    if (!state_id) { return; }

    this.owner.animationDuration = this._animation_duration;

    state_to = this._list_of_state [this._current_state];
    state_to.comp.setStyle ('position', 'absolute');
    state_to.comp.position = [0, 0];
    state_to.comp.setStyle ('z-index', 1000 - index);
    
    if (state_from && state_to)
    {
      state_from.comp.setStyle ('-webkit-transform', 'scale3d(.835,.835,.835) translateZ(200px)');
      
      state_to.comp.setStyle ('-webkit-transform', 'scale3d(.835,.835,.835) rotateX(90deg) translateZ(200px)');
    }

    function initState (index)
    {
      var state_id = this._states_array [index],
          state = this._list_of_state [state_id];
      
      if (!state) { return; }

      if (!state.comp)
      {
        state.comp = this.owner.createAndAddComponent
          (state.comp_name, state.init_data, state.extension);
          
        state.comp.configure (state.init_data);
        state.comp.style ('position', 'absolute');
        if (state.comp && state.comp.propertiesDidChange) 
        { 
          state.comp.propertiesDidChange ();
        }
        state.comp.propertyChange ();
      }
      if (state.view)
      {
        __setPos (state.view, 0, 0);
      }
      else
      {
        state.comp.position = [0, 0];
      }
      state.comp.show ();
      state.comp.style ('z-index', 1000 - index);
    }
    
    /// left/top component 
    if (index > 0) { initState.call (this, index - 1); }

    /// right/bottom component 
    if (index < this._states_array.length - 1)
    { initState.call (this, index + 1); }
     
    if (event && event.on === StackController.NEXT && state_from)
    {
      if (this._orientation === CubicController.HORIZONTAL)
      {
        CubicController._translate_animation.process (this.owner);
      }
      else
      {
        CubicController._translate_animation.process (this.owner);
      }
    }
    else if (event && event.on === StackController.PRED && state_to)
    {
      CubicController._translate_animation.x = 0;
      CubicController._translate_animation.y = 0;
      CubicController._translate_animation.process (state_to.comp);
    }

    if (output && this._output_action [output])
    {
      var clb = this._output_action [output];
      if (util.isFunction (clb))
      {
        clb.call (this.owner, event);
      }
      else if (util.isString (clb))
      {
        this.owner [this._output_action [output]] (event);
      }
    }
  }
};
util.extendClass (CubicController, StackController);

/********************************************************************
                      Export
*********************************************************************/
/** @private */
fx.CubicController = CubicController;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.fx.OpacityController class <br />
 *  @class
 *  This layer manage a list of children using a card layout.
 *  <p />
 *  Children can be slided horizontally (right <-> left) or vertically 
 *  (top <-> bottom) using a pointing device (mouse, touch screen, ...),
 *  or using methods goToNextView and goToPreviousView.
 *  <p />
 *  By default the slider is horizontal, but you can change it using the 
 *  property "orientation".
 *  <p />
 *  The following example shows a typical example with panels
 *  (components 1 to 3).
 *
 *  <pre style="font-family:courier">
 *                   (*)
 *                ⎡ˉˉˉˉˉˉˉˉˉˉˉˉˉ⎤
 *   ⎡(1)ˉˉˉ⎤    ⎢ ⎡(2)ˉˉˉ⎤  ⎢
 *   ⎟      ⎢    ⎢ ⎢⎡(3)ˉ⎢ˉ⎤⎢
 *   ⎟      ⎢    ⎢ ⎢⎢    ⎢ ⎢⎢
 *   ⎟      ⎢    ⎢ ⎢⎢    ⎢ ⎢⎢
 *   ⎣______⎦    ⎢ ⎣______⎦ ⎢⎢
 *                ⎢   ⎣_______⎦⎢
 *                ⎣_____________⎦
 *
 *                   (*)
 *                ⎡ˉˉˉˉˉˉˉˉˉˉˉˉˉ⎤
 *   ⎡(2)ˉˉˉ⎤    ⎢ ⎡(3)ˉˉˉ⎤  ⎢
 *   ⎢⎡(1)ˉ⎢ˉ⎤ ⎢ ⎢       ⎢  ⎢
 *   ⎢⎢    ⎢ ⎢ ⎢ ⎢       ⎢  ⎢
 *   ⎢⎢    ⎢ ⎢ ⎢ ⎢       ⎢  ⎢
 *   ⎣______⎦ ⎢ ⎢ ⎣______⎦   ⎢
 *     ⎣______⎦  ⎢             ⎢
 *                ⎣_____________⎦
 *
 *
 *  (*) : device screen
 *  (1, ...,3) : components managed by the CardLayer
 *
 *   </pre>
 *
 *  <p>
 *  Delegate:
 *  <ul>
 *    <li/>controllerViewWillChange : function (from vs.ui.View, to vs.ui.View, controller), Called when the view
 *        changed
 *  </ul>
 *  <p>
 *  @example
 *  theApplicatioin.layer = new vs.fx.OpacityController (myComp);
 *
 *  myComp.layer.push ('APanel', {id: '1', data: {...}});
 *  myComp.layer.push ('APanel', {id: '2', data: {...}});
 *  myComp.layer.push ('APanel', {id: '3', data: {...}});
 *  myComp.layer.push ('APanel', {id: '4', data: {...}});
 *
 *  @extends vs.fx.StackController
 * @name vs.fx.OpacityController
 * 
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.ui.View.
 *
 * @param {vs.ui.View} owner the View using this Layer [mandatory]
 * @param {String} extension The hole into the vs.ui.View will be inserted. 
 *     ['children' by default]
 */
function OpacityController (owner, extension)
{
  this.parent = StackController;
  this.parent (owner, extension);
  this.constructor = OpacityController;

  this.animationDuration = OpacityController.ANIMATION_DURATION;
}

/** @private */
OpacityController._opacity_animation = new OpacityAnimation (1);
OpacityController._opacity_animation.init ();
OpacityController._opacity_animation.durations = "0.2s";

/**
 * The duration of the animation between two views
 * @name vs.fx.OpacityController.ANIMATION_DURATION
 */
OpacityController.ANIMATION_DURATION = 500;

OpacityController.prototype = {

/********************************************************************
                  protected members declarations
********************************************************************/

/********************************************************************

********************************************************************/
  
  /**
   *  Add a child component to the Slider Manager
   *  <p>
   *  The component must be a graphic component (vs.ui.View).
   *  It will be instantiated, init and added automaticaly
   *  <p>
   *  The component instantiation is a lazy algorithm. The component will
   *  be instantiated and add into the DOM tree only when it has to be show
   *  to the user.
   *  <p>
   *  @example
   *  var myComp = new MyComp (conf);
   *  myComp.layer = new vs.fx.StackController (myComp, 'children');
   *  myComp.layer.push ('AComponent1', data1);
   *  myComp.layer.push ('AComponent1', data2);
   *  myComp.layer.push ('AComponent2', data3);
   *
   * @name vs.fx.OpacityController#push
   * @function
   *
   * @param {vs.ui.View | String} comp The GUI component or the component
   *     name to instanciate   
   * @param {Object} config Configuration structure need to build the component.
   * @param {Array} bindings Bindings configuration [[spec, observer, method], ...]
   */
  push : function (comp, data, bindings)
  {
    if (!comp) { return; }
    
    if (!util.isString (comp))
    {
      var index = this._states_array.length;
      comp.position = [0, 0];
      comp.setStyle ('z-index', 1000 - index);
    }
    StackController.prototype.push.call (this, comp, data, bindings);
  },
  
/*********************************************************
 *                  Event management
 *********************************************************/
  /**
   *  Private method use by the fsm to cross a transition.
   *  @note for the moment only one ouput lexem can be generation when
   *  crossing a transition
   * @private
   *
   * @name vs.fx.OpacityController#goTo
   * @function
   *
   * @param {String} id_sate the id of target state.
   * @param {String} output
   * @param {Object} event the event
   */
  goTo : function (state_id, output, event)
  {
    var state_to, index = this._states_array.indexOf (state_id), 
      state_from = this._list_of_state [this._current_state];
    // manage output
    // TODO WARNING
    StackController.prototype.goTo.call (this, state_id, output, event);
    if (!state_id) { return; }

//    this.owner.animationDuration = this._animation_duration;

    state_to = this._list_of_state [this._current_state];
    state_to.comp.setStyle ('position', 'absolute');
    state_to.comp.position = [0, 0];
    state_to.comp.setStyle ('z-index', 1000 - index);
        
    function initState (index)
    {
      var state_id = this._states_array [index],
          state = this._list_of_state [state_id];
      
      if (!state) { return; }

      if (!state.comp)
      {
        state.comp = this.owner.createAndAddComponent
          (state.comp_name, state.init_data, state.extension);
          
        state.comp.configure (state.init_data);
        state.comp.setStyle ('position', 'absolute');
        if (state.comp && state.comp.propertiesDidChange) 
        { 
          state.comp.propertiesDidChange ();
        }
        state.comp.propertyChange ();
      }
      if (state.view)
      {
        __setPos (state.view, 0, 0);
      }
      else
      {
        state.comp.position = [0, 0];
      }
      state.comp.show ();
      state.comp.setStyle ('z-index', 1000 - index);
    }
    
    /// left/top component 
    if (index > 0) { initState.call (this, index - 1); }

    /// right/bottom component 
    if (index < this._states_array.length - 1)
    { initState.call (this, index + 1); }
     
    if (event && event.on === StackController.NEXT && state_from)
    {
      OpacityController._opacity_animation.value = 0;
      OpacityController._opacity_animation.process (state_from.comp);
    }
    else if (event && event.on === StackController.PRED && state_to)
    {
      OpacityController._opacity_animation.value = 1;
      OpacityController._opacity_animation.process (state_to.comp);
    }

    if (output && this._output_action [output])
    {
      var clb = this._output_action [output];
      if (util.isFunction (clb))
      {
        clb.call (this.owner, event);
      }
      else if (util.isString (clb))
      {
        this.owner [this._output_action [output]] (event);
      }
    }
  }
};
util.extendClass (OpacityController, StackController);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperty (OpacityController, "animationDuration", {
  /** 
   * Set the animation/transition temporisation (in millisecond)
   * @name vs.fx.OpacityController#animationDuration 
   * @type {number}
   */ 
  set : function (time)
  {
    if (!time) { time = 0; }
    if (!util.isNumber (time)) { return };
    
    this._animation_duration = time;
    OpacityController._opacity_animation.durations = time / 1000 + "s";
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
fx.OpacityController = OpacityController;

})(window);/** @license
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

(function (window, undefined) {

var document = window.document;

/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/********************************************************************
                   
*********************************************************************/
/** @private */
var vs = window.vs,
  util = vs.util,
  core = vs.core,
  ui = vs.ui,
  av = vs.av;

/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
 
 Use code from Canto.js Copyright 2010 David Flanagan
*/

/**
 *  The vs.av.Video class
 *
 *  @extends vs.ui.View
 *  @class
 *  Implements {@link vs.core.Task}.
 *  <p>
 *  The vs.av.Video class allow to show a movie clip or other video streams.
 *  <p>
 *  Events:
 *  <ul>
 *    <li /> volumechange: Fired after the volume attribute or the muted attribute has changed.
 *    <li /> error: An error occurs while fetching the media data.
 *    <li /> ended : Fired when playback has stopped because the end of the media resource was reached.
 *    <li /> playing : Fired when playback has started.
 *    <li /> play : Playback has begun. Fired after the play() method has returned, or when the
 *           autoplay property has caused playback to begin.
 *    <li /> pause : Playback has been paused. Fired after the pause() method has returned.
 *  </ul>
 *  <p>
 * The delegate has to implement:
 *  <ul>
 *    <li/>taskDidStop : function (vs.core.Task)
 *    <li/>taskDidPause : function (vs.core.Task)
 *    <li/>taskDidEnd : function (vs.core.Task)
 *  </ul>
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.av.Video.
 *
 *  @example
 *   var myVideo = new vs.av.Video ({id:'my_video'});
 *   myVideo.init ();
 *
 *   myVideo.src = "http://yourlink.mp4";
 *   myVideo.poster = "http://yourlink.jpg";
 *   myVideo.controls = true;
 *   myVideo.loop = true;
 *   myVideo.play ();
 *
 * @name vs.av.Video 
 *
 * @param {Object} config The configuration structure [mandatory]
*/
function Video (config)
{
  if (config && !config.size) { config.size = [320, 200]; }
  
  this.parent = ui.View;
  this.parent (config);
  this.constructor = Video;
}

/**
 * Error code
 * @name vs.av.Video.UNKNOWN_ERR
 * @const
 */
Video.UNKNOWN_ERR = 0;

/**
 * Error code: The fetching process for the media resource was aborted by the 
 * user agent at the user's request.
 * @name vs.av.Video.MEDIA_ERR_ABORTED
 * @const
 */
Video.MEDIA_ERR_ABORTED = 1;

/**
 * Error code: A network error of some description caused the user agent to 
 * stop fetching the media resource, after the resource was established to
 * be usable
 * @name vs.av.Video.MEDIA_ERR_NETWORK
 * @const
 */
Video.MEDIA_ERR_NETWORK = 2;

/**
 * Error code: An error of some description occurred while decoding the
 * media resource, after the resource was established to be usable.
 * @name vs.av.Video.MEDIA_ERR_DECODE
 * @const
 */
Video.MEDIA_ERR_DECODE = 3;

/**
 * Error code: The media resource indicated by the src attribute was not 
 * suitable.
 * @name vs.av.Video.MEDIA_ERR_SRC_NOT_SUPPORTED
 * @const
 */
Video.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;

Video.prototype = {

  /**
   * TaskDelegate.
   * Methods are called when state changes (stop | pause)
   * Should implements: 
   *  <ul>
   *    <li/>taskDidStop : function (vs.core.Task)
   *    <li/>taskDidPause : function (vs.core.Task)
   *    <li/>taskDidEnd : function (vs.core.Task)
   *  </ul>
   * @name vs.av.Video#delegate 
   * @property {object}
   */
  delegate : null,
  
  /*****************************************************************
   *                          State
   ****************************************************************/

  /**
   *	@private
   */
  _state : core.Task.STOPPED,

  /*****************************************************************
   *
   ****************************************************************/
   
  /**
   * @private
   * @type {HTMLDivElement}
   */
   __video_node: null,

  /**
   * @protected
   * @type {string}
   */
  _src: "",
  
  /**
   * @protected
   * @type {string}
   */
  _poster: "",
  
  /**
   * @protected
   * @type {HTMLDivElement}
   */
  _preload: "",
  
  /**
   * @protected
   * @type {boolean}
   */
  _autoplay: false,
  
  /**
   * @protected
   * @type {boolean}
   */
  _loop: false,
  
  /**
   * @protected
   * @type {boolean}
   */
  _controls: false,

  /**
   * @protected
   * @type {number}
   */
  _volume: 1,

  /**
   * @protected
   * @type {boolean}
   */
  _muted: false,

  /**
   * @protected
   * @type {number}
   */
  _current_time: 0,

  /*****************************************************************
   *              Media player methods
   ****************************************************************/

  /**
   * When the play method is invoked, the video start to play.
   * A error event can be fired if a error occurs.
   *
   * @name vs.av.Video#play 
   * @function
   */
  play : function ()
  {
    if (this._state === core.Task.STARTED) { return false; }
    if (!this.__video_node) { return; }

    this._state = core.Task.STARTED;
    this.__video_node.play ();
  },
  
  /**
   *  Starts the task
   *
   * @name vs.av.Video#start
   * @function
   *
   * @param {any} param any parameter (scalar, Array, Object)
   * @ignore
   */
  start : function ()
  {
    this.play ();
  },

  /**
   *  When the pause method is invoked, the video is paused.
   *
   * @name vs.av.Video#pause 
   * @function
   */
  pause : function ()
  {
    if (this._state === core.Task.PAUSED) { return false; }

    if (!this.__video_node) { return; }
    this.__video_node.pause ();
    this._state = core.Task.PAUSED;

    if (this.delegate && this.delegate.taskDidPause) {
      try {
        this.delegate.taskDidPause (this); 
      }
      catch (e) {
        if (e.stack) console.log (e.stack)
        console.error (e);
      }
    }
  },

  /**
   *  When the stop method is invoked, the video is stopped.
   *
   * @name vs.av.Video#stop 
   * @function
   */
  stop : function ()
  {
    if (this._state === core.Task.STOPPED) { return false; }

    if (!this.__video_node) { return; }
    if (this.__video_node.stop) this.__video_node.stop ();
    else
    {
      this.__video_node.pause ();
      this.__video_node.currentTime = 0;
    }
    
    this._state = core.Task.STOPPED;

    if (this.delegate && this.delegate.taskDidStop) {
      try {
        this.delegate.taskDidStop (this); 
      }
      catch (e) {
        if (e.stack) console.log (e.stack)
        console.error (e);
      }
    }
 },

  /*****************************************************************
   *
   ****************************************************************/
  
  /**
   * @protected
   * @function
   */
  destructor : function ()
  {
    if (!this.__i__) { return; }
    
    // bindings
    this.__video_node.removeEventListener ('volumechange', this);
    this.__video_node.removeEventListener ('ended', this);
    this.__video_node.removeEventListener ('playing', this);
    this.__video_node.removeEventListener ('play', this);
    this.__video_node.removeEventListener ('pause', this);
    this.__video_node.removeEventListener ('error', this);

    ui.View.prototype.destructor.call (this);
  },

  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    ui.View.prototype.initComponent.call (this);
    
    this.__video_node = this.view.querySelector ('video');
    if (!this.__video_node)
    {
      console.error ('Uncompatible video view');
      return;
    }
    
    // bindings
    this.__video_node.addEventListener ('volumechange', this);
    this.__video_node.addEventListener ('ended', this);
    this.__video_node.addEventListener ('playing', this);
    this.__video_node.addEventListener ('play', this);
    this.__video_node.addEventListener ('pause', this);
    this.__video_node.addEventListener ('error', this);
    
    var self = this,
      _timeupdate = function ()
    {
      self._current_time = self.__video_node.currentTime;
      self.outPropertyChange ('currentTime');
    };
    this.__video_node.addEventListener ('timeupdate', _timeupdate, false);
  },
  
  /**
   * @protected
   * @function
   */
  handleEvent : function (event)
  {
    switch (event.type)
    {
      case 'volumechange':
        this._volume = this.__video_node.getAttribute ('volume');
        this.outPropertyChange ('volume');
        this.propagate ('volumechange', this._volume);
      break;

      case 'ended':
        this._state = core.Task.STOPED;
        if (this.delegate && this.delegate.taskDidEnd) {
          try {
            this.delegate.taskDidEnd (this); 
          }
          catch (e) {
            if (e.stack) console.log (e.stack)
            console.error (e);
          }
        }
        this.propagate (event.type);
      break;

      case 'pause':
        this._state = core.Task.PAUSED;
        if (this.delegate && this.delegate.taskDidPause) {
          try {
            this.delegate.taskDidPause (this); 
          }
          catch (e) {
            if (e.stack) console.log (e.stack)
            console.error (e);
          }
        }
        this.propagate (event.type);
      break;

      case 'playing':
      case 'play':
        this._state = core.Task.STARTED;
        this.propagate (event.type);
      break;

      case 'error': 
        if (!this.__video_node.error)
        {
          this.propagate (event.type, Video.UNKNOWN_ERR);
        }
        else
        {
          this.propagate (event.type, this.__video_node.error.code);
        }
      break;
    }
  }
};
util.extendClass (Video, ui.View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (Video, {

  'controls': {
  
    /**
     * The controls property indicates the address to expose or not the a user
     * interface for the video controls.
     *
     * @name vs.av.Video#controls 
     * @type {boolean}
     */
    set : function (v)
    {
      if (v) { this._controls = true; }
      else { this._controls = false; }
      
      if (!this.__video_node) { return; }
      this.__video_node.setAttribute ("controls", this._controls);
      
      this.propertyChange ('controls');
    },
    
    /**
     * @ignore
     */
    get : function ()
    {
      return this._controls;
    }
  },
  
  'size': {
  
   /** 
     * Getter|Setter for size. Gives the dimensions of the visual content
     *
     * @type {Array.<number>}
     */ 
    set : function (v)
    {
      if (!v) { return; } 
      if (!util.isArray (v) || v.length !== 2) { return; }
      if (!util.isNumber (v[0]) || !util.isNumber(v[1])) { return; }
  
      this._size [0] = v [0];
      this._size [1] = v [1];
      
      if (!this.view) { return; }
      this._updateSizeAndPos ();
  
      if (!this.__video_node)
      {
        this.__video_node = this.view.querySelector ('video');
        if (!this.__video_node)
        {
          console.error ('Uncompatible video view');
          return;
        }
      }
     this.__video_node.setAttribute ('width', this._size [0]);
     this.__video_node.setAttribute ('height', this._size [1]);    
    },
  
    /**
     * @ignore
     * @type {Array.<number>}
     */
    get : function ()
    {
      if (this.view && this.view.parentNode)
      {
        this._size [0] = this.view.offsetWidth;
        this._size [1] = this.view.offsetHeight;
      }
      return this._size.slice ();
    }
  },
  
  'src': {
  
    /**
     * The src property attribute gives the address of the media resource to 
     * show.
     *
     * @name vs.av.Video#src 
     * @type {string}
     */
    set : function (v)
    {
      if (!util.isString (v)) { return; }
      
      this._src = v;
      
      if (!this.__video_node) { return; }
      this.__video_node.setAttribute ("src", this._src);
  
      this.propertyChange ('src');
    },
  
    /**
     * @ignore
     */
    get : function ()
    {
      return this._src;
    }
  },
  
  'poster': {
  
    /**
     * The src property attribute gives the address of the media resource to 
     * show.
     *
     * @name vs.av.Video#poster
     * @type {string}
     */
    set : function (v)
    {
      if (!util.isString (v)) { return; }
      
      this._poster = v;
      
      if (!this.__video_node) { return; }
      this.__video_node.setAttribute ("poster", this._poster);
  
      this.propertyChange ('poster');
    },
  
    /**
     * @ignore
     */
    get : function ()
    {
      return this._poster;
    }
  },
  
  'loop': {
  
    /**
     * The loop property indicates that the media element is to seek back to
     * the start of the media resource upon reaching the end.
     *
     * @name vs.av.Video#loop 
     * @type {boolean}
     */
    set : function (v)
    {
      if (v) { this._loop = true; }
      else { this._loop = false; }
      
      if (!this.__video_node) { return; }
      this.__video_node.setAttribute ("loop", this._loop);
      
      this.propertyChange ('loop');
    },
  
    /**
     * @ignore
     */
    get : function ()
    {
      return this._loop;
    }
  },
  
  'autoplay': {
    /**
     * The autoplay property indicates the video will automatically begin 
     * playback as soon as it can do so without stopping
     *
     * @name vs.av.Video#autoplay 
     * @type {boolean}
     */
    set : function (v)
    {
      if (v) { this._autoplay = true; }
      else { this._autoplay = false; }
      
      if (!this.__video_node) { return; }
      this.__video_node.setAttribute ("autoplay", this._autoplay);
      
      this.propertyChange ('autoplay');
    },
  
    /**
     * @ignore
     */
    get : function ()
    {
      return this._autoplay;
    }
  },
  
  'volume': {
  
    /**
     * The volume property gives acces to the current playback volume
     * as a number in the range 0.0 to 1.0
     *
     * @name vs.av.Video#volume 
     * @type {number}
     */
    set : function (v)
    {
      if (!util.isNumber (v)) { return; }
      if (v < 0 || v > 1) { return; }
      
      this._volume = v;
      
      if (!this.__video_node) { return; }
      this.__video_node.setAttribute ("volume", this._volume);
      
      this.propertyChange ('volume');
    },
  
    /**
     * @ignore
     */
    get : function ()
    {
      return this._volume;
    }
  },
  
  'muted': {
  
    /**
     * The muted property is true if the audio channels are muted and
     * false otherwise
     *
     * @name vs.av.Video#muted 
     * @type {boolean}
     */
    set : function (v)
    {
      if (v) { this._muted = true; }
      else { this._muted = false; }
      
      this.propertyChange ('muted');
    },
  
    /**
     * @ignore
     */
    get : function ()
    {
      return this._muted;
    }
  },
  
  'currentTime': {
  
    /**
     * The current playback position 
     *
     * @name vs.av.Video#currentTime 
     * @type {number}
     */
    get : function ()
    {
      return this._current_time;
    }
  },
  
  'state': {
  
    /** 
     * Return the task State. <br />
     * Possible values: {@link vs.core.Task.STARTED},
     * {@link vs.core.Task.STOPPED},
     * {@link vs.core.Task.PAUSED}
     * @name vs.av.Video#state
     * @type {number}
     */ 
    get : function ()
    {
      return this._state;
    }
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
av.Video = Video;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
 
 Use code from Canto.js Copyright 2010 David Flanagan
*/

/**
 *  The vs.av.Audio class
 *
 *  @extends vs.core.EventSource
 *  @class
 *  Implements {@link vs.core.Task}.
 *  <p>
 *  The Audio class allow to show a movie clip or other video streams.
 *  <p>
 *  Events:
 *  <ul>
 *    <li /> volumechange: Fired after the volume attribute or the muted attribute has changed.
 *    <li /> error: An error occurs while fetching the media data.
 *    <li /> ended : Fired when playback has stopped because the end of the media resource was reached.
 *    <li /> playing : Fired when playback has started.
 *    <li /> play : Playback has begun. Fired after the play() method has returned, or when the
 *           autoplay property has caused playback to begin.
 *    <li /> pause : Playback has been paused. Fired after the pause() method has returned.
 *  </ul>
 *  <p>
 * The delegate has to implement:
 *  <ul>
 *    <li/>taskDidStop : function (vs.core.Task)
 *    <li/>taskDidPause : function (vs.core.Task)
 *    <li/>taskDidEnd : function (vs.core.Task)
 *  </ul>
 *  @author David Thevenin
 *
 *  @constructor
 *   Creates a new vs.av.Audio.
 *  @name vs.av.Audio
 *
 *  @example
 *   var myVideo = new vs.av.Audio ({id:'my_video'});
 *   myVideo.init ();
 *
 *   myVideo.src = "http://yourlink.mp4";
 *   myVideo.poster = "http://yourlink.jpg";
 *   myVideo.controls = true;
 *   myVideo.loop = true;
 *   myVideo.play ();
 *
 *	@param {Object} config The configuration structure [mandatory]
*/
function Audio (config)
{
  this.parent = core.EventSource;
  this.parent (config);
  this.constructor = Audio;
}

/**
 * Error code
 * @const
 * @name vs.av.Audio.UNKNOWN_ERR
 */
Audio.UNKNOWN_ERR = 0;

/**
 * Error code: The fetching process for the media resource was aborted by the 
 * user agent at the user's request.
 * @const
 * @name vs.av.Audio.MEDIA_ERR_ABORTED
 */
Audio.MEDIA_ERR_ABORTED = 1;

/**
 * Error code: A network error of some description caused the user agent to 
 * stop fetching the media resource, after the resource was established to
 * be usable
 * @const
 * @name vs.av.Audio.MEDIA_ERR_NETWORK
 */
Audio.MEDIA_ERR_NETWORK = 2;

/**
 * Error code: An error of some description occurred while decoding the
 * media resource, after the resource was established to be usable.
 * @const
 * @name vs.av.Audio.MEDIA_ERR_DECODE
 */
Audio.MEDIA_ERR_DECODE = 3;

/**
 * Error code: The media resource indicated by the src attribute was not 
 * suitable.
 * @const
 * @name vs.av.Audio.MEDIA_ERR_SRC_NOT_SUPPORTED
 */
Audio.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;

Audio.prototype = {

  /**
   * TaskDelegate.
   * Methods are called when state changes (stop | pause)
   * Should implements: 
   *  <ul>
   *    <li/>taskDidStop : function (vs.core.Task)
   *    <li/>taskDidPause : function (vs.core.Task)
   *    <li/>taskDidEnd : function (vs.core.Task)
   *  </ul>
   *	@property {object}
   * @name vs.av.Audio#delegate
   */
  delegate : null,
  
  /*****************************************************************
   *                          State
   ****************************************************************/

  /**
   * @private
   */
  _state : core.Task.STOPPED,

  /*****************************************************************
   *
   ****************************************************************/
   
  /**
   * @private
   * @type {AudioConstructor}
   */
   __audio: null,

  /**
   * @protected
   * @type {string}
   */
  _src: "",
  
  /**
   * @protected
   * @type {boolean}
   */
  _autoplay: false,
  
  /**
   * @protected
   * @type {boolean}
   */
  _loop: false,
  
  /**
   * @protected
   * @type {number}
   */
  _volume: 1,

  /**
   * @protected
   * @type {boolean}
   */
  _muted: false,

  /**
   * @protected
   * @type {number}
   */
  _current_time: 0,

  /*****************************************************************
   *              Media player methods
   ****************************************************************/

  /**
   * When the play method is invoked, the video start to play.
   * A error event can be fired if a error occurs.
   *
   * @name vs.av.Audio#play
   * @function
   */
  play : function ()
  {
    if (this._state === core.Task.STARTED) { return false; }
    if (!this.__audio) { return; }

    this._state = core.Task.STARTED;
    this.__audio.play ();
  },
  
  /**
   *  Starts the task
   *
   *@param {any} param any parameter (scalar, Array, Object)
   * @ignore
   * @name vs.av.Audio#start
   * @function
   */
  start : function ()
  {
    this.play ();
  },

  /**
   * When the pause method is invoked, the video is paused.
   * @name vs.av.Audio#pause
   * @function
   */
  pause : function ()
  {
    if (this._state === core.Task.PAUSED) { return false; }

    if (!this.__audio) { return; }
    this.__audio.pause ();
    this._state = core.Task.PAUSED;

    if (this.delegate && this.delegate.taskDidPause) {
      try {
        this.delegate.taskDidPause (this);
      }
      catch (e) {
        if (e.stack) console.log (e.stack)
        console.error (e);
      }
    }
  },

  /**
   * When the stop method is invoked, the video is stopped.
   * @name vs.av.Audio#stop
   * @function
   */
  stop : function ()
  {
    if (this._state === core.Task.STOPPED) { return false; }

    if (!this.__audio) { return; }
    if (window.Media)
    { this.__audio.stop (); }
    else
    { this.__audio.pause (); }
    this._state = core.Task.STOPPED;

    if (this.delegate && this.delegate.taskDidStop) {
      try {
        this.delegate.taskDidStop (this);
      }
      catch (e) {
        if (e.stack) console.log (e.stack)
        console.error (e);
      }
    }
  },

  /*****************************************************************
   *
   ****************************************************************/
  
  /**
   * @protected
   * @function
   */
  destructor : function ()
  {
    if (!this.__i__) { return; }
    
    // unbinding
    this.__audio.removeEventListener ('volumechange', this);
    this.__audio.removeEventListener ('ended', this);
    this.__audio.removeEventListener ('playing', this);
    this.__audio.removeEventListener ('play', this);
    this.__audio.removeEventListener ('pause', this);
    this.__audio.removeEventListener ('error', this);
    
    delete (this.__audio);
    this.__audio = null;

    core.EventSource.prototype.destructor.call (this);
  },

  /**
   * @protected
   * @name vs.av.Audio#initComponent
   * @function
   */
  initComponent: function ()
  {
    core.EventSource.prototype.initComponent.call (this);
    
    this.__audio = new window.Audio ();

    this.__audio.preload = "auto";
    this.__audio.autoplay = this._autoplay;

    // bindings     
    this.__audio.addEventListener ('volumechange', this);
    this.__audio.addEventListener ('ended', this);
    this.__audio.addEventListener ('playing', this);
    this.__audio.addEventListener ('play', this);
    this.__audio.addEventListener ('pause', this);
    this.__audio.addEventListener ('error', this);
    
    var self = this, _timeupdate = function ()
    {
      self._current_time = self.__audio.currentTime;
      self.outPropertyChange ('currentTime');
    };
    this.__audio.addEventListener ('timeupdate', _timeupdate, false);
  },
  
  /**
   * @protected
   * @name vs.av.Audio#handleEvent
   * @function
   */
  handleEvent : function (event)
  {
    switch (event.type)
    {
      case 'volumechange':
        this._volume = this.__audio.volume;
        this.outPropertyChange ('volume');
        this.propagate ('volumechange', this._volume);
      break;

      case 'ended':
        this._state = core.Task.STOPED;
        if (this.delegate && this.delegate.taskDidEnd) {        
          try {
            this.delegate.taskDidEnd (this);
          }
          catch (e) {
            if (e.stack) console.log (e.stack)
            console.error (e);
          }
        }
        this.propagate (event.type);
      break;

      case 'pause':
        this._state = core.Task.PAUSED;
        if (this.delegate && this.delegate.taskDidPause) {
          try {
            this.delegate.taskDidPause (this);
          }
          catch (e) {
            if (e.stack) console.log (e.stack)
            console.error (e);
          }
        }
        this.propagate (event.type);
      break;

      case 'playing':
      case 'play':
        this._state = core.Task.STARTED;
        this.propagate (event.type);
      break;

      case 'error': 
        if (!this.__audio.error)
        {
          this.propagate (event.type, Audio.UNKNOWN_ERR);
        }
        else
        {
          this.propagate (event.type, this.__audio.error.code);
        }
      break;
    }
  }
};
util.extendClass (Audio, core.EventSource);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (Audio, {

  'src': {
  
    /**
     * The src property attribute gives the address of the media resource to 
     * show.
     *
     * @name vs.av.Audio#src 
     * @type {string}
     */
    set : function (v)
    {
      if (!vs.util.isString (v)) { return; }
      
      this._src = v, self = this;
      
      if (window.Media)
      {
        function onSuccess ()
        {
          self._state = core.Task.STOPED;
          if (self.delegate && self.delegate.taskDidEnd) {
            try {
              self.delegate.taskDidEnd (self);
            }
            catch (e) {
              if (e.stack) console.log (e.stack)
              console.error (e);
            }
          }
          self.propagate (event.type);
        }
        this.__audio = new window.Media (this._src, onSuccess);
        if (this._autoplay) { this.play (); }
      }
      else
      {
        if (!this.__audio) { return; }
        this.__audio.src = this._src;
      }
      this.propertyChange ('src');
    },
  
    /**
     * @ignore 
     * @type {string}
     */
    get : function ()
    {
      return this._src;
    }
  },
  
  'loop': {

    /**
     * The loop property indicates that the media element is to seek back to
     * the start of the media resource upon reaching the end.
     *
     * @name vs.av.Audio#loop 
     * @type {boolean}
     */
    set : function (v)
    {
      if (v) { this._loop = true; }
      else { this._loop = false; }
      
      if (!this.__audio) { return; }
      this.__audio.loop = this._loop;
      
      this.propertyChange ('loop');
    },
  
    /**
     * @ignore 
     * @type {boolean}
     */
    get : function ()
    {
      return this._loop;
    }
  },
  
  'autoplay': {

    /**
     * The autoplay property indicates the video will automatically begin playback 
     * as soon as it can do so without stopping
     *
     * @name vs.av.Audio#autoplay 
     * @type {boolean}
     */
    set : function (v)
    {
      if (v) { this._autoplay = true; }
      else { this._autoplay = false; }
      
      if (!this.__audio) { return; }
      this.__audio.autoplay = this._autoplay;
      
      this.propertyChange ('autoplay');
    },
  
    /**
     * @ignore 
     * @type {boolean}
     */
    get : function ()
    {
      return this._autoplay;
    }
  },
  
  'volume': {

    /**
     * The volume property gives acces to the current playback volume
     * as a number in the range 0.0 to 1.0
     *
     * @name vs.av.Audio#volume 
     * @type {number}
     */
    set : function (v)
    {
      if (!vs.util.isNumber (v)) { return; }
      if (v < 0 || v > 1) { return; }
      
      this._volume = v;
      
      if (!this.__audio) { return; }
      this.__audio.volume = this._volume;
      
      this.propertyChange ('volume');
    },
  
    /**
     * @ignore 
     * @type {number}
     */
    get : function ()
    {
      return this._volume;
    }
  },
  
  'muted': {

    /**
     * The muted property is true if the audio channels are muted and
     * false otherwise
     *
     * @name vs.av.Audio#muted 
     * @type {boolean}
     */
    set : function (v)
    {
      if (v) { this._muted = true; }
      else { this._muted = false; }
      
      this.propertyChange ('muted');
    },
  
    /**
     * @ignore 
     * @type {boolean}
     */
    get : function ()
    {
      return this._muted;
    }
  },
  
  'currentTime': {

    /**
     * The current playback position 
     *
     * @name vs.av.Audio#currentTime 
     * @type {number}
     */
    get : function ()
    {
      return this._current_time;
    }
  },
  
  'state': {
  
    /** 
     * Return the task State. <br />
     * Possible values: {@link vs.core.Task.STARTED},
     * {@link vs.core.Task.STOPPED},
     * {@link vs.core.Task.PAUSED}
     * @name vs.av.Audio#state
     * @type {number}
     */ 
    get : function ()
    {
      return this._state;
    },
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
av.Audio = Audio;

Video.prototype.html_template = "\
<div class='vs_av_video'><video class='video_inner'></video></div>\
";

})(window);/** @license
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

(function (window, undefined) {

var document = window.document;

/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/********************************************************************
                   
*********************************************************************/
/** @private */
var vs = window.vs,
  util = vs.util,
  core = vs.core,
  ui = vs.ui,
  fx = vs.fx,
  ext = vs.ext,
  ext_ui = ext.ui,
  ext_fx = ext.fx;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.ext.ui.GMap class
 *
 *  @extends vs.ui.View
 *  @class
 *  GMap provides a widget for embedding maps directly into your application. 
 *  This widget uses the Google GMaps Javascript API V3, especially optimized 
 *  to run on mobile platform.
 *  <p>
 *  The widget allows to add annotations which are marker + information bubble
 *  which are added to the map.
 *  <p>
 *  Events:
 *  <ul> mapload : fire when the map is loaded and ready to use.</ul>
 *  <ul> annotationselect : fire when a marker's information bubble is 
 *       selected.</ul>
 *  <p>
 *  
 *  @author David Thevenin
 *
 * @name vs.ext.ui.GMap
 *  @constructor
 *   Creates a new GMap.
 *
 *  @param {Object} config the configuration structure [mandatory]
 */
var GMap = function (config)
{
  this.parent = vs.ui.View;
  this.parent (config);
  this.constructor = GMap;
  
  this._center = new Array ();
  this._center [0] = 48.83763339660763; 
  this._center [1] = 2.3397827148437544;
  
  if (!GMap.__google_loaded__)
  {
    if (!GMap.__google_wait_loaded__)
    {
      GMap.__google_wait_loaded__ = true;
      vs.util.importFile 
  ("http://maps.google.com/maps/api/js?sensor=true&callback=vs.ext.ui.GMap.__on_laoded", null, null, 'js');
    }
    
    GMap._to_finish_init.push (this);
  }
  
  this.__annotations = {};
};

/**
 * @private
 */
GMap.NO_MARKER = 0;
GMap.DEVICE_IMAGE_MARKER = 1;
GMap.IMAGE_MARKER = 2;

/**
 * @private
 */
GMap._anotation_templates_ = {};
GMap._anotation_templates_ ['default'] = {
  marker: {
    type: GMap.DEVICE_IMAGE_MARKER
  },
  infoWindow :
  "<div class=\"vs_ext_ui_gmap_info\">\
    <div>{title}</div>\
    <div>{subtitle}</div>\
  </div>"
};

/**
 * @private
 */
GMap.__google_wait_loaded__ = false;

/**
 * @private
 */
GMap.__google_loaded__ = false;

/**
 * @private
 */
GMap._to_finish_init = new Array ();

/**
 * @private
 * @function
 */
GMap.__on_laoded = function ()
{
  var i, l; 
  
  GMap.__google_loaded__ = true;
  GMap.__google_wait_loaded__ = false;
  
  createInfoWindowClass ();
  
  for (i = 0, l = GMap._to_finish_init.length; i < l; i ++)
  {
    GMap._to_finish_init [i].finishInit ();
  }
  
  GMap._to_finish_init = null;
}

GMap.prototype = {

 /**********************************************************************
 
 *********************************************************************/

  /**
   * @protected
   * @type {number}
   */
  _zoom: 10,

  /**
   * @protected
   * @type {number}
   */
  _tilt: -1,

  /**
   * @protected
   * @type {boolean}
   */
  _scroll: true,

  /**
   * @protected
   * @type {boolean}
   */
  _tap_to_zoom: true,

  /**
   * @protected
   * @type {number}
   */
  _max_zoom: 20,

  /**
   * @protected
   * @type {number}
   */
  _min_zoom: 1,

  /**
   * @protected
   * @type {boolean}
   */
  _zoom_control: false,

  /**
   * @protected
   * @type {boolean}
   */
  _street_view_control: false,
  
  /**
   * @protected
   * @type {Array.<number>}
   */
  _center: null,
  
  /**
   * @private
   */
  _gmap: null,
  __init_finished: false,

  /**
   * @private
   */
  __annotations: null,

  /*****************************************************************
   *
   ****************************************************************/

  /**
   * @protected
   */
  destructor : function ()
  {
    delete (this._gmap);
    
    vs.ui.View.prototype.destructor.call (this);
  },

  /**
   * @protected
   */
  initComponent : function ()
  {
    vs.ui.View.prototype.initComponent.call (this);
    if (GMap.__google_loaded__)
    {
      this.finishInit ();
    }
  },
  
  /**
   * @private
   */
  finishInit : function ()
  {
    var latLng = new google.maps.LatLng (this._center [0], this._center [1]);
    
    var myOptions = {
      zoom: this._zoom,
      center: latLng,
      disableDefaultUI: true,
      draggable: this._scroll,
      maxZoom: this._max_zoom,
      minZoom: this._min_zoom,
      disableDoubleClickZoom: !this._tap_to_zoom,
      streetViewControl: this._street_view_control,
      streetViewControlOptions: {
        position: google.maps.ControlPosition.LEFT_TOP
      },
      zoomControl: this._zoom_control,
      zoomControlOptions: {
        position: google.maps.ControlPosition.LEFT_BOTTOM,
        style: google.maps.ZoomControlStyle.SMALL
      },
      mapTypeControlOptions: {
        style: google.maps.ControlPosition.HORIZONTAL_BAR
      },
      mapTypeId: google.maps.MapTypeId.ROADMAP,
      mapTypeControlOptions: {
        style: google.maps.MapTypeControlStyle.DROPDOWN_MENU
     }    
    };
    
    this._gmap = new google.maps.Map (this.view, myOptions);
    
    var self = this;
    vs.scheduleAction (function () { clear_view_style (self)});
  },
  
  /**
   * @private
   */
  __init_did_finish : function ()
  {
    this.__init_finished = true;

//     this.center = this._center;
//     this.maxZoom = this._max_zoom;
//     this.minZoom = this._min_zoom;
//     this.scroll = this._scroll;
//     this.tapToZoom = this._tap_to_zoom;
    this.streetViewControl = this._street_view_control;
    this.zoomControl = this._zoom_control;    

    this.propagate ('mapload');
  },
    
  /**
   * Returns true if the map is ready to use
   *
   * @name vs.ext.ui.GMap#isReady 
   * @function
   * @return Boolean 
   */
  isReady : function ()
  {
    return this.__init_finished;
  },
  
  /**
   * Returns a reference to the Google Maps object.
   * <p/>
   * This object uses the Google GMaps Javascript API V3.
   *
   * @name vs.ext.ui.GMap#getGoogleMapObject 
   * @function
   * @return GMap the google.maps.Map object
   */
  getGoogleMapObject : function ()
  {
    return this._gmap;
  },
  
  /**
   * Shows the center marker of the map
   *
   * @name vs.ext.ui.GMap#showCenterMark 
   * @function
   */
  showCenterMark : function ()
  {
    if (!this._center_mark)
    {
      this._center_mark = new google.maps.Marker({
        position: new google.maps.LatLng (this._center [0], this._center [1]),
        icon: "css/kit/mapCenter.png",
      });
    }
    
    this._center_mark.setMap (this._gmap);
  },

  /**
   * Hides the center marker of the map
   *
   * @name vs.ext.ui.GMap#hideCenterMark 
   * @function
   */
  hideCenterMark : function ()
  {
    if (!this._center_mark)
    { return; }
    
    this._center_mark.setMap (null);
  },

  /**
   * @protected
   * @function
   */
  refresh : function ()
  {
    if (!this._gmap) return;
    
    google.maps.event.trigger (this._gmap, "resize");
    vs.ui.View.prototype.refresh.call (this);
  },

/********************************************************************
                  Annotations management
********************************************************************/

  /**
   * Adds the specified annotation to the map view.
   *
   * @name vs.ext.ui.GMap#addAnnotation 
   * @function
   *
   * @param {string} id The identifier of the marker
   * @param {number} lat The latitude between -90 degrees and +90 degrees
   * @param {number} lon The longitude between -180 degrees and +180 degrees
   * @param {Object} info The information window data (should follow template spec)
   * @param {string} name A annotation type (a specific image can be assign to  
   *    type) [Optional]
   * @return {GMap.Annotation} the annotation id (need for removing it)
   */
  addAnnotation : function (id, lat, lon, info, type)
  {
    if (!this.__init_finished) { return; }
    
    if (!util.isString (id) || !id) id = core.createId ();
    
    var annotation = new GMap.Annotation (this, id, lat, lon, info, type);
    this.__annotations [id] = annotation;
    return annotation;
  },
  
  /**
   * Adds the specified annotation to the map view.
   *
   * @name vs.ext.ui.GMap#setAnnotationTemplate 
   * @function
   *
   * @param {string} name The name
   * @param {Object} marker The marker information
   * @param {string} infoWindow The info window HTML template
   */
  setAnnotationTemplate : function (name, marker, infoWindow)
  {
    if (!util.isString (name) && !name) return;
    
    var default_tmp = GMap._anotation_templates_ ['default'];
    
    GMap._anotation_templates_ [name] = {
      marker: util.clone ((marker)?marker:default_tmp.marker),
      infoWindow: util.clone ((infoWindow)?infoWindow:default_tmp.infoWindow)
    };
  },

  /**
   * Removes a specified annotation from the map view.
   *
   * @name vs.ext.ui.GMap#removeAnnotation
   * @function
   * @param {string/GMap.Annotation} id/annotation The identifier or the annotation
   */
  removeAnnotation : function (id)
  {
    if (!util.isString (id) && id.id) id = id.id;
    var annotation = this.__annotations [id];
    if (!annotation) return;
    
    util.free (annotation);
    delete (this.__annotations [id]);
  },

  /**
   * Removes all annotations from the map view.
   *
   * @name vs.ext.ui.GMap#removeAnnotations 
   * @function
   */
  removeAnnotations : function ()
  {
    for (var id in this.__annotations)
    {
      this.removeAnnotation (id);
    }
  },
  
/********************************************************************
                  Annotations management
********************************************************************/

  /**
   * @name vs.ext.ui.GMap#annotationSelect 
   * @function
   * @protected
   */
  annotationSelect : function (id)
  {
    this.propagate ('annotationselect', id);
  }
};
util.extendClass (GMap, vs.ui.View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (GMap, {

  'scroll': {
    /** 
     * Allow to scroll the map.
     * By default its set to true
     * @name vs.ext.ui.GMap#scroll 
     * @type {boolean}
     */ 
    set : function (v)
    {
      if (v)
      { this._scroll = true; }
      else
      { this._scroll = false; }
      
      if (!this.__init_finished) { return; }
      
      this._gmap.setOptions ({draggable: this._scroll});
    },
  
    /** 
     * @ignore
     * @type {boolean}
     */ 
    get : function ()
    {
      return this._scroll
    }
  },
  'tapToZoom': {
    /** 
     * Enabled/disabled to zoom after user tap.
     * By default its set to true
     * @name vs.ext.ui.GMap#tapToZoom 
     * @type {boolean}
     */ 
    set : function (v)
    {
      if (v)
      { this._tap_to_zoom = true; }
      else
      { this._tap_to_zoom = false; }
      
      if (!this.__init_finished) { return; }
      
      this._gmap.setOptions ({disableDoubleClickZoom: !this._tap_to_zoom});
    },
  
    /** 
     * @ignore
     * @type {boolean}
     */ 
    get : function ()
    {
      return this._tap_to_zoom
    }
  },
  'maxZoom': {
    /** 
     * Set the maximum authorized map's zoom
     *
     * @name vs.ext.ui.GMap#maxZoom 
     * @type {number}
     */ 
    set : function (v)
    {
      if (!vs.util.isNumber (v)) { return; }
      
      this._max_zoom = v;
      
      if (!this.__init_finished) { return; }
      
      this._gmap.setOptions ({maxZoom: this._max_zoom});
    },
  
    /** 
     * @ignore
     * @type {number}
     */ 
    get : function ()
    {
      return this._max_zoom;
    }
  },
  'minZoom': {
    /** 
     * Set the minimum authorized map's zoom
     *
     * @name vs.ext.ui.GMap#minZoom 
     * @type {number}
     */ 
    set : function (v)
    {
      if (!vs.util.isNumber (v)) { return; }
      
      this._min_zoom = v;
      
      if (!this.__init_finished) { return; }
      
      this._gmap.setOptions ({maxZoom: this._min_zoom});
    },
  
    /** 
     * @ignore
     * @type {number}
     */ 
    get : function ()
    {
      return this._min_zoom;
    }
  },
  'zoomControl': {
    /** 
     * Enabled/disabled the zoom controls.
     * By default its set to false
     * @name vs.ext.ui.GMap#zoomControl 
     * @type {boolean}
     */ 
    set : function (v)
    {
      if (v)
      { this._zoom_control = true; }
      else
      { this._zoom_control = false; }
      
      if (!this.__init_finished) { return; }
      
      this._gmap.setOptions ({zoomControl: this._zoom_control});
    },
  
    /** 
     * @ignore
     * @type {boolean}
     */ 
    get : function ()
    {
      return this._zoom_control
    }
  },
  'zoom': {
    /** 
     * Set the current map zoom
     *
     * @name vs.ext.ui.GMap#zoom 
     * @type {number}
     */ 
    set : function (v)
    {
     if (!vs.util.isNumber (v)) { return; }
      
      if (!this.__init_finished) { return; }
      
      v = Math.floor (v);
      if (v === this._zoom) { return; }
      
      this._zoom = v;
      
      this._gmap.setZoom (this._zoom);
    },
  
    /** 
     * @ignore
     * @type {number}
     */ 
    get : function ()
    {
      if (!this._gmap) { return -1; }
      
      this._zoom = this._gmap.getZoom ();
      return this._zoom
    }
  },
  'tilt': {
    /** 
     * Set the current map tilt
     *
     * @name vs.ext.ui.GMap#tilt 
     * @type {number}
     */ 
    set : function (v)
    {
     if (!vs.util.isNumber (v)) { return; }
      
      if (!this.__init_finished) { return; }
      
      this._tilt = v;
      
      this._gmap.setTilt (v);
    },
  
    /** 
     * @ignore
     * @type {number}
     */ 
    get : function ()
    {
      if (!this._gmap) { return -1; }
      
      this._tilt = this._gmap.getTilt ();
      return this._tilt;
    }
  },
  'streetViewControl': {
    /** 
     * Enabled/disabled the street view access controls.
     * By default its set to false
     * @name vs.ext.ui.GMap#streetViewControl 
     * @type {boolean}
     */ 
    set : function (v)
    {
      if (v)
      { this._street_view_control = true; }
      else
      { this._street_view_control = false; }
      
      if (!this.__init_finished) { return; }
      
      this._gmap.setOptions ({streetViewControl: this._street_view_control});
    },
  
    /** 
     * @ignore
     * @type {boolean}
     */ 
    get : function ()
    {
      return this._street_view_control
    }
  },
  'center': {
    /** 
     * Changes / access the center coordinate of the map
     *
     * Positions is a array of latitude and longitude in degrees.
     * @name vs.ext.ui.GMap#center 
     * @type {Array}
     */ 
    set : function (v)
    {
      if (!this.__init_finished) { return; }
      if (!v) { return; } 
      if (!vs.util.isArray (v) || v.length !== 2) { return; }
      if (!vs.util.isNumber (v[0]) || !vs.util.isNumber(v[1])) { return; }
      
      this._center [0] = v [0];
      this._center [1] = v [1];
      
      var latLng = new google.maps.LatLng (v [0], v [1]);
      this._gmap.setCenter (latLng);
      
      if (this._center_mark)
      {
        this._center_mark.setPosition (latLng);
      }
    },
    
    /** 
     * @ignore
     * @type {Array}
     */ 
    get : function ()
    {
      if (!this._gmap) { return [0, 0]; }
      
      var pos = this._gmap.getCenter();
  
      this._center [0] = pos.lat ();
      this._center [1] = pos.lng ();
      
      return this._center.slice ();
    }
  }
});

/**
 * @private
 */
var clear_view_style_nb_cur = 0;

/**
 * @private
 * @function
 */
var clear_view_style = function (map)
{
  map.__init_did_finish ();
}

/********************************************************************
                      Export
*********************************************************************/

/**
 *  The GMap.Annotation class
 *
 *  @extends vs.ui.View
 *  @class
 *  Creates a marker with the options specified. If a map is specified, the 
 *  marker is added to the map upon construction. Note that the position must be 
 *  set for the marker to display
 *
 * Events:
 *  <ul> mapload : fire when the map is loaded and ready to use.
 *  </ul>
 *  <p>
 *  
 * @author David Thevenin
 * @name vs.ext.ui.GMap.Annotation
 * @private
 *
 * @constructor
 *  Creates a new GMap.Annotation.
 *
 */
GMap.Annotation = function (map, id, lat, lon, info, type)
{
  this.map = map;
  this.id = id;
  this.info = info;
  this.type = (type)?type:'default';
  
  this._coordinate = new google.maps.LatLng (lat, lon);
  
  var template = GMap._anotation_templates_ [this.type];
  if (!template) template = GMap._anotation_templates_ ['default'];
  
  this.image = null;

  if (template.marker.type == GMap.DEVICE_IMAGE_MARKER)
  {
    var os_device = window.deviceConfiguration.os;
    if (os_device == vs.core.DeviceConfiguration.OS_SYMBIAN)
    {
      this.image = new google.maps.MarkerImage ('css/kit/symbian_marker.png',
        new google.maps.Size (48, 51),
        new google.maps.Point (0,0),
        new google.maps.Point (24, 48));
    }
    else if (os_device == vs.core.DeviceConfiguration.OS_WP7)
    {
      this.image = new google.maps.MarkerImage ('css/kit/wp7_marker.png',
        new google.maps.Size (15, 31),
        new google.maps.Point (0,0),
        new google.maps.Point (0, 31));
    }
    else
    {
      this.image = new google.maps.MarkerImage ('css/kit/ios_marker.png',
        new google.maps.Size (32, 41),
        new google.maps.Point (0,0),
        new google.maps.Point (8, 36));
    }
  }
  else if (template.marker.type == GMap.IMAGE_MARKER)
  {
    this.image = new google.maps.MarkerImage (template.marker.url);
  }
  
  if (this.image)
  {     
    this._gmarker = new google.maps.Marker({
      position: this._coordinate,
      icon: this.image,
      map: map._gmap,
      animation: google.maps.Animation.DROP
    });
  
    var self = this;
    google.maps.event.addListener (this._gmarker, 'click', function() {
      self.onselect ();
    });
  }
  else
  {
    this._infoWindow = new GMap.InfoWindow (this.map, id, lat, lon, type);
    this._infoWindow.setCoordinate (lat, lon);
    this._infoWindow.setInfo (info);
  }
}

GMap.Annotation.prototype = {
  
  /**
   * @ignore
   */
  destructor : function ()
  {
    if (this._gmarker)
    {
      this._gmarker.setMap (null);
      delete (this._gmarker);
    }
    if (this._infoWindow) free (this._infoWindow);
    if (this.image) delete (this.image);
    delete (this._coordinate);
    
    this.map = undefined;
  },

  /**
   *  on select management
   *  @ignore
   */
  onselect : function ()
  {
    this.showInfoWindow ();
  },
  
  /**
   *  Show the info Window
   *  @ignore
   */
  showInfoWindow : function ()
  {
    if (!this.map._infoWindow)
    {
      this.map._infoWindow = new GMap.InfoWindowWithMarker (this.map);
      this.map._infoWindow.setMarker (this);
    }
    else
    {
      this.map._infoWindow.setMarker (this);
    }
  }
}

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (GMap.Annotation, {

  'coordinate': {
    /** 
     * Sets/get the new center point of the annotation. [latitude, longitude]
     * @name vs.ext.ui.GMap.Annotation#coordinate 
     * @type {Array}
     */ 
    set : function (pos)
    {
      if (!util.isArray (pos) && pos.length != 2) return;
      
      delete (this._coordinate);
      this._coordinate = new google.maps.LatLng (pos[0], pos[1]);
      
      if (this._gmarker)
      {
        this._gmarker.setPosition (this._coordinate);
      }
    },
  
    /** 
     * @ignore
     * @type {Array}
     */ 
    get : function ()
    {
      return [this._coordinate.lat (), this._coordinate.lng ()]; 
    }
  },
  'info': {
    /** 
     * Set/returns annotation information
     * @type {Object}
     */ 
    set : function (v)
    {
      this._info = v;
      if (this._infoWindow) this._infoWindow.setInfo (v);
    },
  
    /** 
     * @ignore
     * @type {boolean}
     */ 
    get : function ()
    {
      return this._info
    }
  }
});


/**
 * @private
 */
function createInfoWindowClass ()
{
  /**
   *  The GMap.InfoWindow class
   *
   *  @extends vs.ui.View
   *  @class
   *  Creates an info window with the given options
   *
   * Events:
   *  <ul> mapload : fire when the map is loaded and ready to use.
   *  </ul>
   *  <p>
   *  
   * @author David Thevenin
   * @name GMap.InfoWindow
   *
   * @ignore
   * @constructor
   *  Creates a new GMap.InfoWindow.
   *
   */
  GMap.InfoWindow = function (map, id, type, lat, lon)
  {    
    this.vs_map = map;
    this.id = id;
    this.type = type;
    
    if (!map) return;
    this.setCoordinate (lat, lon);

    // Initialization
    this.setValues ({map: this.vs_map._gmap});
  };
  GMap.InfoWindow.prototype = new google.maps.OverlayView;
  
  /**
   * @ignore
   */
  GMap.InfoWindow.prototype.destructor = function ()
  {
    this.setMap (null);
    
    this.marker = undefined;
    this.vs_map = undefined;
  },
    
  /**
   * @ignore
   */
  GMap.InfoWindow.prototype.hide = function ()
  {
    if (!this.view) return;
 
    this.view.style.display = 'none';
  };
  
  /**
   * @ignore
   */
  GMap.InfoWindow.prototype.show = function ()
  {
    if (!this.view) return;
 
    this.view.style.display = 'block';
  };
  
  /**
   * @ignore
   */
  GMap.InfoWindow.prototype.setMarker = function (marker)
  {
    if (this.marker)
    {
      this.unbind ('position');
    }
    this.marker = marker;
    this.id = this.marker.id;
    this.type = this.marker.type;
    this.info = this.marker.info;
    this.bindTo ('position', this.marker._gmarker, 'position');
    
    this.instanciateView (this.type, this.info);
  };
  
  /**
   * @ignore
   */
  GMap.InfoWindow.prototype.setCoordinate = function (lat, lon)
  {
    if (this.position) delete (this.position);
    this.position = new google.maps.LatLng (lat, lon);
  };
  
  /**
   * @ignore
   */
  GMap.InfoWindow.prototype.setType = function (type)
  {
    this.type = type;
    this.instanciateView (this.type, this.info);
  };
  
  /**
   * @ignore
   */
  GMap.InfoWindow.prototype.setInfo = function (data)
  {
    this.info = data;
    this.instanciateView (this.type, this.info);
  };
    
  /**
   * @ignore
   */
  GMap.InfoWindow.prototype.instanciateView = function (type, info)
  {
    var div = document.createElement ('div');
    var template = GMap._anotation_templates_ [type];
    if (!template) template = GMap._anotation_templates_ ['default'];
    var text = template.infoWindow;
    
    if (info) for (key in info)
    {
      var value = info[key]; value = (value)?value:"";
      text = text.replace ('{' + key + '}', value);
    }
    util.safeInnerHTML (div, text);
    
    if (!this.view) this.createView ();
    
    util.safeInnerHTML (this.view, div.firstElementChild.innerHTML);
    this.view.className = div.firstElementChild.className;
  };
  
  /**
   * @ignore
   */
  GMap.InfoWindow.prototype.createView = function ()
  {
    if (this.view) return;
    
    this.view = document.createElement ('div');
 
    vs.addPointerListener (this.view, core.POINTER_START, this);
  };
  
  /**
   * @ignore
   */
  GMap.InfoWindow.prototype.handleEvent = function (e)
  {
    var self = this;
    
    switch (e.type)
    {
      case core.POINTER_START:
        // prevent multi touch events
        if (e.targetPointerList.length === 0 || e.nbPointers > 1) { return; }
        
        vs.addPointerListener (document, core.POINTER_END, this);
        vs.addPointerListener (document, core.POINTER_MOVE, this);
        this.__start_x = e.targetPointerList[0].pageX;
        this.__start_y = e.targetPointerList[0].pageY;
        
        if (this.marker) this.removeMapEvent ();
        util.addClassName (this.view, "selected");
        return false;
      break;

      case core.POINTER_MOVE:
      
        // do not manage event for other targets
        if (e.targetPointerList.length === 0) { return; }

        var dx = e.targetPointerList[0].pageX - this.__start_x;
        var dy = e.targetPointerList[0].pageY - this.__start_y;
          
        if (Math.abs (dx) + Math.abs (dy) < 10)
        {
          // we keep the event
          e.preventDefault ();
          return false;
        }
 
        vs.removePointerListener (document, core.POINTER_END, this);
        vs.removePointerListener (document, core.POINTER_MOVE, this);
        if (this.marker) vs.scheduleAction (function () {self.initMapEvent ();});
        util.removeClassName (this.view, "selected");
 
        return false;
      break;

      case core.POINTER_END:

        // we keep the event
        e.stopPropagation ();
        e.preventDefault ();

        vs.removePointerListener (document, core.POINTER_END, this);
        vs.removePointerListener (document, core.POINTER_MOVE, this);
        if (this.marker) vs.scheduleAction (function () {self.initMapEvent ();});
        util.removeClassName (this.view, "selected");
        
        this.vs_map.annotationSelect (this.id);

        return false;
      break;
    }
  };

  /**
   * Implement this method to initialize the overlay DOM elements.
   * This method is called once after setMap() is called with a valid map.
   * @ignore
   */
  GMap.InfoWindow.prototype.onAdd = function ()
  {
    if (!this.view) this.createView ();
    
    var pane = this.getPanes().floatPane;
    pane.appendChild (this.view);
    
    // Ensures the label is redrawn if the text or position is changed.
    var self = this;
    this.listeners_ = [
    google.maps.event.addListener(this, 'position_changed',
      function() { self.draw(); }),
    ];
  };
  
  /**
   * Implement this method to remove your elements from the DOM. This method
   * is called once following a call to setMap(null)
   * @ignore
   */
  GMap.InfoWindow.prototype.onRemove = function ()
  {
    this.view.parentNode.removeChild(this.view);
    
    // Label is removed from the map, stop updating its position/text.
    for (var i = 0, I = this.listeners_.length; i < I; ++i) {
      google.maps.event.removeListener(this.listeners_[i]);
    }
  };
  
  /**
   * Implement this method to draw or update the overlay. 
   * @ignore
   */
  GMap.InfoWindow.prototype.draw = function ()
  {
    var projection = this.getProjection ();
    var position = projection.fromLatLngToDivPixel (this.get ('position'));
    
    var div = this.view;
    div.style.display = 'block';
    div.style.visibility = 'hidden';
    
    var icon_w = 0;
    if (this.marker)
    {
      icon_w = 10;
      var icon = this.marker._gmarker.getIcon ();
      if (icon) icon_w += icon.size.height;
    }

    // update position to correctly manage the info bubble size
    vs.scheduleAction (function ()
    {
      var width = div.offsetWidth;
      var height = div.offsetHeight;
      
      div.style.left = position.x - Math.ceil(width/2) + 'px';
      div.style.top = position.y - height - icon_w + 'px';
      div.style.visibility = 'visible';
    });
  };

  /**
   * @ignore
   */
  GMap.InfoWindow.prototype.initMapEvent = function ()
  {
    if (this.map_listener) return;

    var self = this;
    this.map_listener = google.maps.event.addListener
      (this.vs_map._gmap, 'click', function() {
        self.hide ();
      });
  };

  /**
   * @ignore
   */
  GMap.InfoWindow.prototype.removeMapEvent = function ()
  {
    if (!this.map_listener) return;
 
    google.maps.event.removeListener (this.map_listener);
    this.map_listener = undefined;
  };

  /**
   *  The GMap.InfoWindowWithMarker class
   *
   *  @extends vs.ui.View
   *  @class
   *  Creates an info window with the given options
   *
   * Events:
   *  <ul> mapload : fire when the map is loaded and ready to use.
   *  </ul>
   *  <p>
   *  
   * @author David Thevenin
   * @name GMap.InfoWindow
   *
   * @ignore
   * @constructor
   *  Creates a new GMap.InfoWindow.
   *
   */
  GMap.InfoWindowWithMarker = function (map)
  {    
    this.vs_map = map;

    // Initialization
    this.setValues ({map: this.vs_map._gmap});
    this.initMapEvent ();
  };
  util.extendClass (GMap.InfoWindowWithMarker, GMap.InfoWindow);
}
/********************************************************************
                      Export
*********************************************************************/
/** @private */
ext_ui.GMap = GMap;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.ext.ui.Carousel class
 *
 *  @extends vs.ui.View
 *  @class
 *  Carousel presents a slide carousel. This carousel can be controller
 *  by a swipe on the screen or through methods (goToNextView, ...)
 *  <p>
 *  Carousel is a vs.ui.View. You can set the view size, to defined the bound
 *  inside children's view will be draw. Children are fixed
 *  on top left of the carousel.
 *  <p>
 *  Although carousel views are displayed vertically by default, you can
 *  use the orientation property to have it display horizontally.
 *  <p>
 *  You can set a delegate to be informed when the view will change
 *  (after a swipe or a method call).
 *
 *  <p>
 *  Delegate should implement:
 *  <ul>
 *    <li/>carouselViewWillChange : function (view /*vs.ui.View /)
 *  </ul>
 *  <p>
 *  @example
 *  var carousel = new Carousel (config);
 *  // set child component view (you can add instantiated view or component name
 *  carousel.add (view1);
 *  carousel.add (view2);
 *  carousel.add (view3);
 *  carousel.add (view4);
 *  // change the orientation
 *  carousel.orientation = vs.fx.SwipeController.VERTICAL
 *  // set a delegate
 *  var delegate = {};
 *  delegate.carouselViewWillChange = function (view) { ... };
 *  carousel.delegate = delegate;
 *  
 *  @author David Thevenin
 *  @name vs.ext.ui.Carousel
 *
 *  @constructor
 *   Creates a new Carousel.
 *
 *  @param {Object} config the configuration structure [mandatory]
 */
function Carousel (config)
{
  this.parent = vs.ui.View;
  this.parent (config);
  this.constructor = Carousel;
  
  this.__indicators_list = {};
}

/**
 * Horizontal carousel (defaut)
 * @name vs.ext.ui.Carousel.HORIZONTAL
 * @const
 */
Carousel.HORIZONTAL = vs.fx.SwipeController.HORIZONTAL;

/**
 * Vertical carousel
 * @name vs.ext.ui.Carousel.VERTICAL
 * @const
 */
Carousel.VERTICAL = vs.fx.SwipeController.VERTICAL;

Carousel.prototype = {

 /**********************************************************************
 
 *********************************************************************/

   /**
   * @protected
   * @type {boolean}
   */
  _indicators_visibility : true,
  
   /**
   * @protected
   * @type {Object}
   */
  _delegate: null,

  /**
   *
   * @protected
   * @type {number}
   */
  _orientation : Carousel.HORIZONTAL,

  /**
   * The vs.fx.SwipeController that will manage the carousel slide
   * @private
   * @type {vs.fx.SwipeController}
   */
  _swipe_controller : null,
  
  /**
   * The indicators view
   * @private
   * @type {DivHtmlElement}
   */
  __indicators : null,
  
  /**
   * The selected indicator view
   * @private
   * @type {SpanHtmlElement}
   */
  __selected_indicator : null,
  
  /**
   * The list of indicators
   * @private
   * @type {Object.<string>}
   */
  __indicators_list : null,
  
  /**
   * Indicator change timer
   * @private
   * @type {number}
   */
  __indicators_timer : 0,  
  
 /**********************************************************************
                  In/Out properties declarations 
  *********************************************************************/


 /**********************************************************************
 
 *********************************************************************/
  
  /**
   * @protected
   */
  destructor : function ()
  {
    util.free (this._swipe_controller);

    vs.ui.View.prototype.destructor.call (this);
  },
  
  /**
   * @protected
   * @function
   */
  initComponent : function ()
  {
    vs.ui.View.prototype.initComponent.call (this);
        
    this.__indicators =
      this.view.querySelector ('.vs_ext_ui_carousel >.indicators');
    vs.util.addClassName (this.__indicators, 'horizontal');

    this._swipe_controller = new vs.fx.SwipeController (this);
    this._swipe_controller.delegate = this;
    this._swipe_controller.isTactile = true;
    this._swipe_controller.animationMode = vs.fx.SwipeController.PIXEL;
    this._swipe_controller.init ();
  },
  
  /**
   * @protected
   * @function
   */
  refresh : function ()
  {
    if (this._swipe_controller && this._swipe_controller.refresh)
    { this._swipe_controller.refresh (); }

    vs.ui.View.prototype.refresh.call (this);
  },
  
 /**********************************************************************
 
 *********************************************************************/
 
  /**
   * @private
   * @function
   */
  controllerViewWillChange : function (from_comp, to_comp, controller)
  {
    if (this.__indicators_timer)
    {
      clearTimeout (this.__indicators_timer);
      __indicators_timer = 0;
    }
    
    var i_id = to_comp.id, self = this;
    this.__indicators_timer = setTimeout (function ()
    {
      if (self.__selected_indicator)
      {
        vs.util.removeClassName (self.__selected_indicator, 'selected');
      }
      self.__selected_indicator = self.__indicators_list [i_id];
      vs.util.addClassName (self.__selected_indicator, 'selected');
    }, 500);
    
    if (this._delegate && this._delegate.carouselViewWillChange)
    {
      this._delegate.carouselViewWillChange (to_comp);
    }
  },
   
   /**
   *  Add a child component to the carousel
   *  <p>
   *  The component can be a graphic component (vs.ui.View) or
   *  a non graphic component (vs.core.EventSource).
   *  In case of vs.ui.View its mandatory to set the extension.
   *  <p>
   *  @example
   *  var carousel = new Carousel (config);
   *  carousel.init ();
   *  // instanced component
   *  var comp = new AComponent (data);
   *  carousel.add (comp);
   *
   * @name vs.ext.ui.Carousel#add
   * @function
   * @param {vs.ui.View} child The component to add.
   */
  add : function (child)
  {
    vs.ui.View.prototype.add.call (this, child, 'children');
    this.push (child)
  },

   /**
   *  Add a child component to the carousel
   *  <p>
   *  The component must be a graphic component (vs.ui.View).
   *  It will be instantiated, init and added automaticaly
   *  <p>
   *  @example
   *  var carousel = new Carousel (config);
   *  carousel.init ();
   *  myController.push ('AComponent1', data1);
   *  myController.push ('AComponent1', data2);
   *  myController.push ('AComponent2', data3);
   *
   * @name vs.ext.ui.Carousel#push
   * @function
   * @param {vs.ui.View | String} comp The GUI component or the component
   *     name to instanciate   
   * @param {Object} config Configuration structure need to build the 
   *     component.
   */
  push : function (child, config)
  {
    // Test if the component is already added
    if (this.isChild (child))
    {
      if (this._swipe_controller.isStateExit (child.id))
      { return; }
    }
    
    var span, state_id = this._swipe_controller.push (child, config);
    
    span = document.createElement ('span');
    
    this.__indicators.appendChild (span);
    this.__indicators_list [state_id] = span;
  },

  /**
   *  Remove the specified child component from this component.
   * 
   *  @example
   *  myObject.remove (myButton);
   *
   * @name vs.ext.ui.Carousel#remove
   * @function
   * @param {vs.core.EventSource} child The component to be removed.
   */
  remove : function (child)
  {
    if (!child || !child.id)
    { return; }
    
    var span = this.__indicators_list [child.id];
    
    this.__indicators.removeChild (span);
    delete (this.__indicators_list [child.id]);

    vs.ui.View.prototype.remove.call (this, child);
  },

  /**
   * Remove all panels
   * @name vs.ext.ui.Carousel#removeAllChildren
   * @param {Boolean} should_free free children
   * @return {Array} list of removed child if not should_free
   * @function
   */
  removeAllChildren : function (should_free)
  {
    var children = [];
    
    for (var id in this.__indicators_list)
    {
      var comp = vs.core.Object._obs [id];
      this.remove (comp);
      if (should_free) util.free (comp);
      else children.push (comp);
    }
    
    return (should_free)?undefined:children;
  },

 /**********************************************************************
 
 *********************************************************************/
 
  /**
   * Go to the next view
   * @name vs.ext.ui.Carousel#goToNextView
   * @function
   */
  goToNextView : function ()
  {
    this._swipe_controller.goToNextView ();
  },
 
  /**
   * Go to the previous view
   * @name vs.ext.ui.Carousel#goToPreviousView
   * @function
   */
  goToPreviousView : function ()
  {
    this._swipe_controller.goToPreviousView ();
  },

  /**
   *  Go to the view specified by its id
   *
   * @name vs.ext.ui.Carousel#goToView
   * @param {string} id The component id
   * @function
   */
  goToView : function (id)
  {
    this._swipe_controller.goToViewId (id);
  },

  /**
   *  Go to the view specified by its position (index start at 0)
   *
   * @name vs.ext.ui.Carousel#goToViewAt
   * @param {number} index The component index
   * @function
   */
  goToViewAt : function (index)
  {
    this._swipe_controller.goToViewAt (index);
  }
};
util.extendClass (Carousel, vs.ui.View);

/********************************************************************
                  Define class properties
********************************************************************/

util.defineClassProperties (Carousel, {

  'size': {
    /** 
     * Getter|Setter for size. Gives access to the size of the GUI Object
     * @name vs.ext.ui.Carousel#size 
     * @function.
     * @type {Array.<number>}
     */ 
    set : function (v)
    {
      if (!v) { return; } 
      if (!util.isArray (v) || v.length !== 2) { return; }
      if (!util.isNumber (v[0]) || !util.isNumber(v[1])) { return; }
      
      this._size [0] = v [0];
      this._size [1] = v [1];
      
      if (!this.view) { return; }
      this._updateSizeAndPos ();
  
      if (this._swipe_controller && this._swipe_controller.refresh)
      { this._swipe_controller.refresh (); }
    },
    
    /**
     * @type {Array.<number>}
     * @ignore
     */
    get : function ()
    {
      var view = this.view;
       if (view && view.parentNode)
      {
        this._size [0] = view.offsetWidth;
        this._size [1] = view.offsetHeight;
      }
      return this._size.slice ();
    }
  },
  'delegate': {

    /** 
     * Set the delegate.
     * It should implements following methods
     *  <ul>
     *    <li/>carouselViewWillChange : function (view /* vs.ui.View /)
     *  </ul>
     * @name vs.ext.ui.Carousel#delegate 
     * @type Object
     */ 
    set : function (v)
    {
      this._delegate = v;
    }
  },
  'indicatorsVisibility': {

    /** 
     * Set indicators visible or not
     * <p>
     * By default its set to true
     * @name vs.ext.ui.Carousel#indicatorsVisibility 
     * @type boolean
     */ 
    set : function (v)
    { 
      if (v)
      {
        this._indicators_visibility = true;
        util.setElementVisibility (this.__indicators, true);
      }
      else
      {
        this._indicators_visibility = false
        util.setElementVisibility (this.__indicators, false);
      }
    }
  },
      
  'isCircular': {
    /** 
     * Getter|Setter for circular swipe
     * @name vs.ext.ui.Carousel#isCircular 
     * @type {boolean}
     */ 
    set : function (v)
    {
      this._swipe_controller.isCircular = v;
    },
  
    /** 
     * @ignore
     * @return {boolean}
     */ 
    get : function ()
    {
      return this._swipe_controller.isCircular;
    }
  },
  
  'isContinuousSwipe': {
    /** 
     * Getter|Setter Continuous Swipe
     * @name vs.ext.ui.Carousel#isContinuousSwipe 
     * @type {boolean}
     */ 
    set : function (v)
    {
      this._swipe_controller.isContinuousSwipe = v;
    },
  
    /** 
     * @ignore
     * @return {boolean}
     */ 
    get : function ()
    {
      return this._swipe_controller.isContinuousSwipe;
    }
  },

  'orientation': {

    /** 
     * Getter|Setter for the tab bar style
     * @name vs.ext.ui.Carousel#orientation 
     * @type String
     */ 
    set : function (v)
    {
      if (v !== Carousel.HORIZONTAL &&
          v !== Carousel.VERTICAL) { return; }
      
      if (this._orientation === v) { return; }
      if (v === Carousel.HORIZONTAL)
      {
        vs.util.removeClassName (this.__indicators, 'vertical');
        vs.util.addClassName (this.__indicators, 'horizontal');
      }
      else
      {
        vs.util.removeClassName (this.__indicators, 'horizontal');
        vs.util.addClassName (this.__indicators, 'vertical');
      }
      this._orientation = v;
      this._swipe_controller.orientation = v;
    },
  
    /** 
     * @return {String}
     * @ignore
     */ 
    get : function ()
    {
      return this._orientation;
      }
    }
  }
);

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ext_ui.Carousel = Carousel;
/**
  Copyright (C) 2009-2012. David Thevenin, ViniSketch SARL (c), and 
  contributors. All rights reserved
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  The vs.ext.ui.Accordion class
 *
 *  @extends vs.ui.View
 *  @class
 *  The Accordion class is a subclass of View that allows you to show
 *  a set of panels which can be collapsed or expanded.
 *  <p/>
 *  Events:
 *  <ul>
 *    <li /> panel_select: Fired after a panel is expanded. Data = index
 *           of the panel (zero-indexed number)
 *  </ul>
 *  <p>
 *  @example
 *  var config = {};
 *  var config.id = vs.core.createId ();
 *
 *  var accordion = new vs.ext.ui.Accordion ();
 *  accordion.init ();
 *  accordion.size = [300, 500];
 *  
 *  accordion.add (obj1);
 *  accordion.add (tabList3);
 *  accordion.add (vv);
 *
 *  @author David Thevenin
 *
 * @name vs.ext.ui.Accordion 
 *  @constructor
 *   Creates a new vs.ext.ui.Accordion.
 *
 * @param  {Object} config The configuration structure [mandatory]
*/
var Accordion = function (config)
{
  this.parent = ui.View;
  this.parent (config);
  this.constructor = Accordion;
  
  this.__ab_a_items = [];
}

/** 
 * Widgets keep there size and position
 * @see vs.ext.ui.Accordion#stretch 
 * @name vs.ext.ui.Accordion.STRETCH_NONE 
 * @const
 */
Accordion.STRETCH_NONE = 0;

/** 
 * Widgets size fit the panel view size
 * @see vs.ext.ui.Accordion#stretch 
 * @name vs.ext.ui.Accordion.STRETCH_FILL 
 * @const
 */
Accordion.STRETCH_FILL = 1;


Accordion.prototype = {
  
  /*****************************************************************
   *               private/protected members
   ****************************************************************/

  /**
   * @protected
   */
  _stretch: Accordion.STRETCH_NONE,
  
  /**
   * @private
   */
  __ab_a_items: undefined,
  
  /**
   * @private
   */
  __ab_a_current_index: undefined,
    
  /**
   * @private
   */
  __ab_a_head_height: 33,
    
  /*****************************************************************
   *                 
   ****************************************************************/
  
  /**
   *  Add the child component to the accordion and set the panel title.
   *  <p>
   *  Call push is similar to call add followed by setPanelTitle.
   *  <p>
   *
   * @name vs.ext.ui.Accordion#push 
   * @function
   * @param {vs.ui.View} child The component to be added.
   * @param {String} title the new panel title
   */
  push : function (child, title)
  {
    if (!child) { return; }
    this.add (child);
    var index = this._getIndexForChild (child)
    this.setPanelTitle (index, title);
  },
  
  /**
   *  Add the specified child component to this component.
   *  <p>
   *  The add is a lazy add! The child's view can be already in
   *  the HTML DOM. In that case, the add methode do not modify the DOM.
   *  <p>
   *
   * @name vs.ext.ui.Accordion#add
   * @function
   * @param  {vs.ui.View} child The component to be added.
   */
  add : function (child)
  {
    if (!child) { return; }
    var view, index, result;
    
    if (!child.id) { child.id = vs.core.createId (); }
    
    index = this.__ab_a_items.length;
    
    result = this._createView (child, 'Section ' + (index + 1), index);
    this.view.appendChild (result.dt);
    ui.View.prototype.add.call (this, child, 'children', result.dd);
    
    this.__ab_a_items.push (result);
    this._updateSizePanel ();
  },
  
  /**
   *  Remove the specified child component from this component.
   * 
   *  @example
   *  myObject.remove (myButton);
   *
   * @name vs.ext.ui.Accordion#remove 
   * @function
   * @param  {vs.core.EventSource} child The component to be removed.
   */
  remove : function (child)
  {
    var index = this._getIndexForChild (child), panel;
    if (index === -1)
    { return; }
    
    ui.View.prototype.remove.call (this, child);
    panel = this.__ab_a_items [index];
    panel.dd.removeChild (child.view);
    this.view.removeChild (panel.dt);
    vs.removePointerListener (panel.dt, core.POINTER_START, this);
    delete (panel.dt);
    delete (panel.dd);
    delete (panel);
    
    this.__ab_a_items.remove (index);

    if (index === this.__ab_a_current_index)
    // Show the first panel
    {
      this.__ab_a_current_index = null;
      this.expandPanel (0);
    }
    else
    // update widget size (and children) to fit with the new available space
    { this._updateSizePanel (); }
  },
  
  /**
   * @private
   */
  _getIndexForChild : function (child)
  {
    if (!child) { return -1; }
    
    var index, panel;
    
    for (index = 0; index < this.__ab_a_items.length; index++)
    {
      panel = this.__ab_a_items [index];
      if (!panel || !panel.dd)
      { continue; }
      if (panel.dd.__child === child)
      { return index; }
    }
    return -1;
  },
  
  /**
   * @private
   */
  _createView : function (child, title, index)
  {
    var panel = {}, mode;
    
    panel.dt = document.createElement ('dt');
    util.setElementInnerText (panel.dt, title);
    panel.title = title;

    panel.dd = document.createElement ('dd');      
    if (this._stretch === Accordion.STRETCH_FILL)
    {
      child.position = [0, 0];
    }
    panel.dd.appendChild (child.view);
    
    mode = (index)?'collapsed':'expanded'

    panel.dd.setAttribute ("class", mode);
    panel.dt.setAttribute ("class", mode);
    panel.dd.__child = child
    panel.child = child;

    if (mode === 'collapsed')
    {
      panel.dd.style.width = '100%';
      panel.dd.style.height = '0px';
    }
    else
    {
      panel.dd.style.width = '100%';
      panel.dd.style.height = child._size [1] + 'px';
      this.__ab_a_current_index = index;
    }
        
    if (this._stretch === Accordion.STRETCH_FILL)
    {
      child.size = [this._size[0] - 2, this._size[1]];
    }
    panel.dt.__dd = panel.dd;
    panel.dt.__index = index;
    vs.addPointerListener (panel.dt, core.POINTER_START, this);
    return panel;
  },
  
  /**
   *  Expand a part of the accordion.
   *  <p>
   *  The index can be zero-indexed number to match the position or the title of 
   *  the panel you want to open.
   *  <p>
   *  @example
   *  var accordion = new vs.ext.ui.Accordion (conf);
   *  ....
   *  accordion.expandPanel (2);
   *  accordion.expandPanel ('Section 2');
   *
   * @name vs.ext.ui.Accordion#expandPanel 
   * @function
   * @param  {number | String} index position or title of the panel to open
   */
  expandPanel: function (index)
  {
    var panel, i;
    
    if (util.isNumber (index) && index >= 0 && 
        index < this.__ab_a_items.length)
    {
      if (index === this.__ab_a_current_index)
      {
        return;
      }
      
      panel = this.__ab_a_items [this.__ab_a_current_index];
      if (panel)
      {
        util.removeClassName (panel.dt, 'expanded');
        util.addClassName (panel.dt, 'collapsed');
        util.removeClassName (panel.dd, 'expanded');
        util.addClassName (panel.dd, 'collapsed');
        panel.dd.style.height = '0px';
      }
  
      panel = this.__ab_a_items [index];
      util.removeClassName (panel.dt, 'collapsed');
      util.addClassName (panel.dt, 'expanded');
      util.removeClassName (panel.dd, 'collapsed');
      util.addClassName (panel.dd, 'expanded');
  
      this.__ab_a_current_index = index;
      this._updateSizePanel ();
      this.propagate ('panel_select', index);
      return;
    }
    if (util.isString (index))
    {
      for (i = 0; i < this.__ab_a_items.length; i++)
      {
        panel = this.__ab_a_items [i];
        if (panel.title === index)
        {
          this.expandPanel (i);
          return;
        }
      }
    }
  },
  
  /**
   *  Set a title for a give panel
   *  <p>
   *  The index can be zero-indexed number to match the position or the title of 
   *  the panel you want to open.
   *  <p>
   *  @example
   *  var accordion = new vs.ext.ui.Accordion (conf);
   *  ....
   *  accordion.setPanelTitle (2, 'info 2');
   *  accordion.setPanelTitle ('Section 1', 'info 1');
   *
   * @name vs.ext.ui.Accordion#setPanelTitle 
   * @function
   * @param  {number | String} index position or title of the panel to open
   * @param  {String} title the new panel title
   */
  setPanelTitle: function (index, title)
  {
    var panel, i;
    
    if (util.isNumber (index) && index >= 0 && 
        index < this.__ab_a_items.length)
    {
      panel = this.__ab_a_items [index];
      panel.title = title;
      util.setElementInnerText (panel.dt, title);
      
      return;
    }
    if (util.isString (index))
    {
      for (i = 0; i < this.__ab_a_items.length; i++)
      {
        panel = this.__ab_a_items [i];
        if (panel.title === index)
        {
          this.setPanelTitle (i, title);
          return;
        }
      }
    }
  },
  
  /********************************************************************
                    GUI Utilities
  ********************************************************************/

  /**
   * @ignore
   */
  show: function ()
  {
    vs.ui.View.prototype.show.call (this);
    
    this._updateSizePanel ();
  },
  
  /**
   * @ignore
   */
  refresh: function ()
  {
    vs.ui.View.prototype.refresh.call (this);
    
    this._updateSizePanel ();
  },
  
  /**
   * @private
   */
  _updateSize: function ()
  {
    vs.ui.View.prototype._updateSize.call (this);
    
    this._updateSizePanel ();
  },
  
  /**
   * @private
   */
  _updateSizePanel: function ()
  {
    var height, panel, i;
    panel = this.__ab_a_items [this.__ab_a_current_index];
    if (panel)
    {
      height = this._size [1];
      this.__ab_a_head_height = panel.dt.offsetHeight;
      height -= this.__ab_a_items.length * this.__ab_a_head_height + 2;
      panel.dd.style.height = height + 'px';
      if (this._stretch === Accordion.STRETCH_FILL)
      {
        panel.child.size = [this._size[0] - 2, height];
      }
    }
  },
  
  /*****************************************************************
   *               Events management
   ****************************************************************/

  /**
   * @private
   */
  handleEvent : function (e)
  {
    var elem = e.target, self = this, pageY, pageX, delta;

    if (elem.nodeType !== 1)
    {
      elem = elem.parentElement;
    }
    if (e.type === core.POINTER_START)
    {
      // prevent multi touch events
      if (e.targetPointerList.length === 0 || e.nbPointers > 1) { return; }
      
      e.stopPropagation ();
      e.preventDefault ();
      
      if (util.hasClassName (elem, 'expanded'))
      { return false; }

      vs.addPointerListener (document, core.POINTER_MOVE, this, false);
      vs.addPointerListener (document, core.POINTER_END, this, false);
      
      this.__touch_start_x = e.targetPointerList[0].pageX;
      this.__touch_start_y = e.targetPointerList[0].pageY;

      this.__elem = elem;

      if (this.__elem_to_unselect)
      {
        util.removeClassName (this.__elem_to_unselect, 'selected');
        this.__elem_to_unselect = null;
      }
      this.__list_time_out = setTimeout (function ()
      {
        util.addClassName (self.__elem, 'selected');
        self.__list_time_out = 0;
      }, 0); //ui.View.SELECT_DELAY);
    }
    else if (e.type === core.POINTER_MOVE)
    {
      // do not manage event for other targets
      if (e.targetPointerList.length === 0) { return; }
      
      e.stopPropagation ();
      e.preventDefault ();

      pageX = e.targetPointerList[0].pageX;
      pageY = e.targetPointerList[0].pageY;
      delta = 
        Math.abs (pageY - this.__touch_start_y) + 
        Math.abs (pageX - this.__touch_start_x);  
                
      // this is a move, not a selection => deactivate the selected element
      // if needs
      if (this.__elem && (delta > ui.View.MOVE_THRESHOLD * 2))
      {
        if (this.__list_time_out)
        {
          clearTimeout (this.__list_time_out);
          this.__list_time_out = 0;
        }
        else
        {
          util.removeClassName (this.__elem, 'selected');
        }
        this.__elem = null;
      }            
    }
    else if (e.type === core.POINTER_END)
    {
      e.stopPropagation ();
      e.preventDefault ();

      // Stop tracking when the last finger is removed from this element
      vs.removePointerListener (document, core.POINTER_MOVE, this);
      vs.removePointerListener (document, core.POINTER_END, this);
                  
      // a item is selected. propagate the change
      if (this.__elem)
      {
        if (this.__list_time_out)
        {
          clearTimeout (this.__list_time_out);

          util.addClassName (self.__elem, 'selected');
        }

        this.__elem_to_unselect = this.__elem;
        this.__list_time_out = setTimeout (function ()
        {
          util.removeClassName (self.__elem_to_unselect, 'selected');
          self.__elem_to_unselect = null;
          self.__list_time_out = 0;
        }, ui.View.UNSELECT_DELAY);
        
        if (util.isNumber (elem.__index))
        {
          this.expandPanel (elem.__index);
        }
      }

      this.__elem = null;
    }
          
    return false;
  }
}
util.extendClass (Accordion, vs.ui.View);

util.defineClassProperty (Accordion, 'stretch',
{
  /**
   * Configure widgets to fit the view or to keep its original size.
   * <p>The property can take four values : 
   * <ul>
   *   <li/>vs.ext.ui.Accordion.STRETCH_NONE;
   *   <li/>vs.ext.ui.Accordion.STRETCH_FILL;
   * </ul>
   * @name vs.ext.ui.Accordion#stretch 
   * @type {number}
   */
  set : function (v)
  {
    if (!util.isNumber (v)) { return; }
    if (v !== Accordion.STRETCH_FILL &&
        v !== Accordion.STRETCH_NONE)
    { return; }
    
    this._stretch = v;
    
    if (this._stretch === Accordion.STRETCH_FILL)
    {
      util.addClassName (this.view, 'fill');
    }
    else
    {
      util.removeClassName (this.view, 'fill');
    }
    this._updateSizePanel ();
  },

  /*****************************************************************
   *
   ****************************************************************/

  /**
   * Get the image stretch mode (vs.ext.ui.Accordion.STRETCH_FILL or 
   * vs.ext.ui.Accordion.STRETCH_NONE)
   * @return {number}
   */
  get : function ()
  {
    return this._stretch;
  }
});

/********************************************************************
                      Export
*********************************************************************/
/** @private */
ext_ui.Accordion = Accordion;


GMap.prototype.html_template = "\
<div class='vs_ext_ui_gmap'></div>\
";

Carousel.prototype.html_template = "\
<div class='vs_ext_ui_carousel'>\
  <div class='views' x-hag-hole='children'></div>\
  <div class='indicators'></div>\
</div>\
";

Accordion.prototype.html_template = "\
<dl class='vs_ext_ui_accordion' x-hag-hole='children'></dl>\
";

})(window);